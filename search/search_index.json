{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DAODST Documentation","text":""},{"location":"api/","title":"Home","text":""},{"location":"api/#cli","title":"cli","text":""},{"location":"api/#eth-json-grpc","title":"eth json grpc","text":""},{"location":"api/#cosmos-grpc","title":"cosmos grpc","text":""},{"location":"auth/","title":"<code>auth</code>","text":""},{"location":"auth/#abstract","title":"Abstract","text":"<p>This document specifies the auth module.</p> <p>The auth module is responsible for specifying the base transaction and account types for an application, since the SDK itself is agnostic to these particulars. It contains the ante handler, where all basic transaction validity checks (signatures, nonces, auxiliary fields) are performed, and exposes the account keeper, which allows other modules to read, write, and modify accounts.</p>"},{"location":"auth/#concepts","title":"Concepts","text":""},{"location":"auth/#gas-fees","title":"Gas &amp; Fees","text":"<p>Fees serve two purposes for an operator of the network.</p> <p>Fees limit the growth of the state stored by every full node and allow for general purpose censorship of transactions of little economic value. Fees are best suited as an anti-spam mechanism where validators are disinterested in the use of the network and identities of users.</p> <p>Fees are determined by the gas limits and gas prices transactions provide, where <code>fees = ceil(gasLimit * gasPrices)</code>. Txs incur gas costs for all state reads/writes, signature verification, as well as costs proportional to the tx size. Operators should set minimum gas prices when starting their nodes. They must set the unit costs of gas in each token denomination they wish to support:</p> <p><code>simd start ... --minimum-gas-prices=0.00001stake;0.05photinos</code></p> <p>When adding transactions to mempool or gossipping transactions, validators check if the transaction's gas prices, which are determined by the provided fees, meet any of the validator's minimum gas prices. In other words, a transaction must provide a fee of at least one denomination that matches a validator's minimum gas price.</p> <p>Tendermint does not currently provide fee based mempool prioritization, and fee based mempool filtering is local to node and not part of consensus. But with minimum gas prices set, such a mechanism could be implemented by node operators.</p> <p>Because the market value for tokens will fluctuate, validators are expected to dynamically adjust their minimum gas prices to a level that would encourage the use of the network.</p>"},{"location":"auth/#state","title":"State","text":""},{"location":"auth/#accounts","title":"Accounts","text":"<p>Accounts contain authentication information for a uniquely identified external user of an SDK blockchain, including public key, address, and account number / sequence number for replay protection. For efficiency, since account balances must also be fetched to pay fees, account structs also store the balance of a user as <code>sdk.Coins</code>.</p> <p>Accounts are exposed externally as an interface, and stored internally as either a base account or vesting account. Module clients wishing to add more account types may do so.</p> <ul> <li><code>0x01 | Address -&gt; ProtocolBuffer(account)</code></li> </ul>"},{"location":"auth/#account-interface","title":"Account Interface","text":"<p>The account interface exposes methods to read and write standard account information. Note that all of these methods operate on an account struct confirming to the interface - in order to write the account to the store, the account keeper will need to be used.</p> <pre><code>// AccountI is an interface used to store coins at a given address within state.\n// It presumes a notion of sequence numbers for replay protection,\n// a notion of account numbers for replay protection for previously pruned accounts,\n// and a pubkey for authentication purposes.\n//\n// Many complex conditions can be used in the concrete struct which implements AccountI.\ntype AccountI interface {\n    proto.Message\n\n    GetAddress() sdk.AccAddress\n    SetAddress(sdk.AccAddress) error // errors if already set.\n\n    GetPubKey() crypto.PubKey // can return nil.\n    SetPubKey(crypto.PubKey) error\n\n    GetAccountNumber() uint64\n    SetAccountNumber(uint64) error\n\n    GetSequence() uint64\n    SetSequence(uint64) error\n\n    // Ensure that account implements stringer\n    String() string\n}\n</code></pre>"},{"location":"auth/#base-account","title":"Base Account","text":"<p>A base account is the simplest and most common account type, which just stores all requisite fields directly in a struct.</p> <pre><code>// BaseAccount defines a base account type. It contains all the necessary fields\n// for basic account functionality. Any custom account type should extend this\n// type for additional functionality (e.g. vesting).\nmessage BaseAccount {\n  string address = 1;\n  google.protobuf.Any pub_key = 2;\n  uint64 account_number = 3;\n  uint64 sequence       = 4;\n}\n</code></pre>"},{"location":"auth/#antehandlers","title":"AnteHandlers","text":"<p>The <code>x/auth</code> module presently has no transaction handlers of its own, but does expose the special <code>AnteHandler</code>, used for performing basic validity checks on a transaction, such that it could be thrown out of the mempool. The <code>AnteHandler</code> can be seen as a set of decorators that check transactions within the current context, per ADR 010.</p> <p>Note that the <code>AnteHandler</code> is called on both <code>CheckTx</code> and <code>DeliverTx</code>, as Tendermint proposers presently have the ability to include in their proposed block transactions which fail <code>CheckTx</code>.</p>"},{"location":"auth/#decorators","title":"Decorators","text":"<p>The auth module provides <code>AnteDecorator</code>s that are recursively chained together into a single <code>AnteHandler</code> in the following order:</p> <ul> <li> <p><code>SetUpContextDecorator</code>: Sets the <code>GasMeter</code> in the <code>Context</code> and wraps the next <code>AnteHandler</code> with a defer clause to recover from any downstream <code>OutOfGas</code> panics in the <code>AnteHandler</code> chain to return an error with information on gas provided and gas used.</p> </li> <li> <p><code>RejectExtensionOptionsDecorator</code>: Rejects all extension options which can optionally be included in protobuf transactions.</p> </li> <li> <p><code>MempoolFeeDecorator</code>: Checks if the <code>tx</code> fee is above local mempool <code>minFee</code> parameter during <code>CheckTx</code>.</p> </li> <li> <p><code>ValidateBasicDecorator</code>: Calls <code>tx.ValidateBasic</code> and returns any non-nil error.</p> </li> <li> <p><code>TxTimeoutHeightDecorator</code>: Check for a <code>tx</code> height timeout.</p> </li> <li> <p><code>ValidateMemoDecorator</code>: Validates <code>tx</code> memo with application parameters and returns any non-nil error.</p> </li> <li> <p><code>ConsumeGasTxSizeDecorator</code>: Consumes gas proportional to the <code>tx</code> size based on application parameters.</p> </li> <li> <p><code>DeductFeeDecorator</code>: Deducts the <code>FeeAmount</code> from first signer of the <code>tx</code>. If the <code>x/feegrant</code> module is enabled and a fee granter is set, it will deduct fees from the fee granter account.</p> </li> <li> <p><code>SetPubKeyDecorator</code>: Sets the pubkey from a <code>tx</code>'s signers that does not already have its corresponding pubkey saved in the state machine and in the current context.</p> </li> <li> <p><code>ValidateSigCountDecorator</code>: Validates the number of signatures in <code>tx</code> based on app-parameters.</p> </li> <li> <p><code>SigGasConsumeDecorator</code>: Consumes parameter-defined amount of gas for each signature. This requires pubkeys to be set in context for all signers as part of <code>SetPubKeyDecorator</code>.</p> </li> <li> <p><code>SigVerificationDecorator</code>: Verifies all signatures are valid. This requires pubkeys to be set in context for all signers as part of <code>SetPubKeyDecorator</code>.</p> </li> <li> <p><code>IncrementSequenceDecorator</code>: Increments the account sequence for each signer to prevent replay attacks.</p> </li> </ul>"},{"location":"auth/#keepers","title":"Keepers","text":"<p>The auth module only exposes one keeper, the account keeper, which can be used to read and write accounts.</p>"},{"location":"auth/#account-keeper","title":"Account Keeper","text":"<p>Presently only one fully-permissioned account keeper is exposed, which has the ability to both read and write all fields of all accounts, and to iterate over all stored accounts.</p> <pre><code>// AccountKeeperI is the interface contract that x/auth's keeper implements.\ntype AccountKeeperI interface {\n    // Return a new account with the next account number and the specified address. Does not save the new account to the store.\n    NewAccountWithAddress(sdk.Context, sdk.AccAddress) types.AccountI\n\n    // Return a new account with the next account number. Does not save the new account to the store.\n    NewAccount(sdk.Context, types.AccountI) types.AccountI\n\n    // Check if an account exists in the store.\n    HasAccount(sdk.Context, sdk.AccAddress) bool\n\n    // Retrieve an account from the store.\n    GetAccount(sdk.Context, sdk.AccAddress) types.AccountI\n\n    // Set an account in the store.\n    SetAccount(sdk.Context, types.AccountI)\n\n    // Remove an account from the store.\n    RemoveAccount(sdk.Context, types.AccountI)\n\n    // Iterate over all accounts, calling the provided function. Stop iteration when it returns true.\n    IterateAccounts(sdk.Context, func(types.AccountI) bool)\n\n    // Fetch the public key of an account at a specified address\n    GetPubKey(sdk.Context, sdk.AccAddress) (crypto.PubKey, error)\n\n    // Fetch the sequence of an account at a specified address.\n    GetSequence(sdk.Context, sdk.AccAddress) (uint64, error)\n\n    // Fetch the next account number, and increment the internal counter.\n    GetNextAccountNumber(sdk.Context) uint64\n}\n</code></pre>"},{"location":"auth/#client","title":"Client","text":""},{"location":"auth/#auth_1","title":"Auth","text":""},{"location":"auth/#cli","title":"CLI","text":"<p>A user can query and interact with the <code>auth</code> module using the CLI.</p>"},{"location":"auth/#query","title":"Query","text":"<p>The <code>query</code> commands allow users to query <code>auth</code> state.</p> <pre><code>simd query auth --help\n</code></pre>"},{"location":"auth/#account","title":"account","text":"<p>The <code>account</code> command allow users to query for an account by it's address.</p> <pre><code>simd query auth account [address] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query auth account cosmos1...\n</code></pre> <p>Example Output:</p> <pre><code>'@type': /cosmos.auth.v1beta1.BaseAccount\naccount_number: \"0\"\naddress: cosmos1zwg6tpl8aw4rawv8sgag9086lpw5hv33u5ctr2\npub_key:\n  '@type': /cosmos.crypto.secp256k1.PubKey\n  key: ApDrE38zZdd7wLmFS9YmqO684y5DG6fjZ4rVeihF/AQD\nsequence: \"1\"\n</code></pre>"},{"location":"auth/#accounts_1","title":"accounts","text":"<p>The <code>accounts</code> command allow users to query all the available accounts.</p> <pre><code>simd query auth accounts [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query auth accounts\n</code></pre> <p>Example Output:</p> <pre><code>accounts:\n- '@type': /cosmos.auth.v1beta1.BaseAccount\n  account_number: \"0\"\n  address: cosmos1zwg6tpl8aw4rawv8sgag9086lpw5hv33u5ctr2\n  pub_key:\n    '@type': /cosmos.crypto.secp256k1.PubKey\n    key: ApDrE38zZdd7wLmFS9YmqO684y5DG6fjZ4rVeihF/AQD\n  sequence: \"1\"\n- '@type': /cosmos.auth.v1beta1.ModuleAccount\n  base_account:\n    account_number: \"8\"\n    address: cosmos1yl6hdjhmkf37639730gffanpzndzdpmhwlkfhr\n    pub_key: null\n    sequence: \"0\"\n  name: transfer\n  permissions:\n  - minter\n  - burner\n- '@type': /cosmos.auth.v1beta1.ModuleAccount\n  base_account:\n    account_number: \"4\"\n    address: cosmos1fl48vsnmsdzcv85q5d2q4z5ajdha8yu34mf0eh\n    pub_key: null\n    sequence: \"0\"\n  name: bonded_tokens_pool\n  permissions:\n  - burner\n  - staking\n- '@type': /cosmos.auth.v1beta1.ModuleAccount\n  base_account:\n    account_number: \"5\"\n    address: cosmos1tygms3xhhs3yv487phx3dw4a95jn7t7lpm470r\n    pub_key: null\n    sequence: \"0\"\n  name: not_bonded_tokens_pool\n  permissions:\n  - burner\n  - staking\n- '@type': /cosmos.auth.v1beta1.ModuleAccount\n  base_account:\n    account_number: \"6\"\n    address: cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn\n    pub_key: null\n    sequence: \"0\"\n  name: gov\n  permissions:\n  - burner\n- '@type': /cosmos.auth.v1beta1.ModuleAccount\n  base_account:\n    account_number: \"3\"\n    address: cosmos1jv65s3grqf6v6jl3dp4t6c9t9rk99cd88lyufl\n    pub_key: null\n    sequence: \"0\"\n  name: distribution\n  permissions: []\n- '@type': /cosmos.auth.v1beta1.BaseAccount\n  account_number: \"1\"\n  address: cosmos147k3r7v2tvwqhcmaxcfql7j8rmkrlsemxshd3j\n  pub_key: null\n  sequence: \"0\"\n- '@type': /cosmos.auth.v1beta1.ModuleAccount\n  base_account:\n    account_number: \"7\"\n    address: cosmos1m3h30wlvsf8llruxtpukdvsy0km2kum8g38c8q\n    pub_key: null\n    sequence: \"0\"\n  name: mint\n  permissions:\n  - minter\n- '@type': /cosmos.auth.v1beta1.ModuleAccount\n  base_account:\n    account_number: \"2\"\n    address: cosmos17xpfvakm2amg962yls6f84z3kell8c5lserqta\n    pub_key: null\n    sequence: \"0\"\n  name: fee_collector\n  permissions: []\npagination:\n  next_key: null\n  total: \"0\"\n</code></pre>"},{"location":"auth/#params","title":"params","text":"<p>The <code>params</code> command allow users to query the current auth parameters.</p> <pre><code>simd query auth params [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query auth params\n</code></pre> <p>Example Output:</p> <pre><code>max_memo_characters: \"256\"\nsig_verify_cost_ed25519: \"590\"\nsig_verify_cost_secp256k1: \"1000\"\ntx_sig_limit: \"7\"\ntx_size_cost_per_byte: \"10\"\n</code></pre>"},{"location":"auth/#grpc","title":"gRPC","text":"<p>A user can query the <code>auth</code> module using gRPC endpoints.</p>"},{"location":"auth/#account_1","title":"Account","text":"<p>The <code>account</code> endpoint allow users to query for an account by it's address.</p> <pre><code>cosmos.auth.v1beta1.Query/Account\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    -d '{\"address\":\"cosmos1..\"}' \\\n    localhost:9090 \\\n    cosmos.auth.v1beta1.Query/Account\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"account\":{\n    \"@type\":\"/cosmos.auth.v1beta1.BaseAccount\",\n    \"address\":\"cosmos1zwg6tpl8aw4rawv8sgag9086lpw5hv33u5ctr2\",\n    \"pubKey\":{\n      \"@type\":\"/cosmos.crypto.secp256k1.PubKey\",\n      \"key\":\"ApDrE38zZdd7wLmFS9YmqO684y5DG6fjZ4rVeihF/AQD\"\n    },\n    \"sequence\":\"1\"\n  }\n}\n</code></pre>"},{"location":"auth/#accounts_2","title":"Accounts","text":"<p>The <code>accounts</code> endpoint allow users to query all the available accounts.</p> <pre><code>cosmos.auth.v1beta1.Query/Accounts\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    localhost:9090 \\\n    cosmos.auth.v1beta1.Query/Accounts\n</code></pre> <p>Example Output:</p> <pre><code>{\n   \"accounts\":[\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.BaseAccount\",\n         \"address\":\"cosmos1zwg6tpl8aw4rawv8sgag9086lpw5hv33u5ctr2\",\n         \"pubKey\":{\n            \"@type\":\"/cosmos.crypto.secp256k1.PubKey\",\n            \"key\":\"ApDrE38zZdd7wLmFS9YmqO684y5DG6fjZ4rVeihF/AQD\"\n         },\n         \"sequence\":\"1\"\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.ModuleAccount\",\n         \"baseAccount\":{\n            \"address\":\"cosmos1yl6hdjhmkf37639730gffanpzndzdpmhwlkfhr\",\n            \"accountNumber\":\"8\"\n         },\n         \"name\":\"transfer\",\n         \"permissions\":[\n            \"minter\",\n            \"burner\"\n         ]\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.ModuleAccount\",\n         \"baseAccount\":{\n            \"address\":\"cosmos1fl48vsnmsdzcv85q5d2q4z5ajdha8yu34mf0eh\",\n            \"accountNumber\":\"4\"\n         },\n         \"name\":\"bonded_tokens_pool\",\n         \"permissions\":[\n            \"burner\",\n            \"staking\"\n         ]\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.ModuleAccount\",\n         \"baseAccount\":{\n            \"address\":\"cosmos1tygms3xhhs3yv487phx3dw4a95jn7t7lpm470r\",\n            \"accountNumber\":\"5\"\n         },\n         \"name\":\"not_bonded_tokens_pool\",\n         \"permissions\":[\n            \"burner\",\n            \"staking\"\n         ]\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.ModuleAccount\",\n         \"baseAccount\":{\n            \"address\":\"cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn\",\n            \"accountNumber\":\"6\"\n         },\n         \"name\":\"gov\",\n         \"permissions\":[\n            \"burner\"\n         ]\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.ModuleAccount\",\n         \"baseAccount\":{\n            \"address\":\"cosmos1jv65s3grqf6v6jl3dp4t6c9t9rk99cd88lyufl\",\n            \"accountNumber\":\"3\"\n         },\n         \"name\":\"distribution\"\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.BaseAccount\",\n         \"accountNumber\":\"1\",\n         \"address\":\"cosmos147k3r7v2tvwqhcmaxcfql7j8rmkrlsemxshd3j\"\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.ModuleAccount\",\n         \"baseAccount\":{\n            \"address\":\"cosmos1m3h30wlvsf8llruxtpukdvsy0km2kum8g38c8q\",\n            \"accountNumber\":\"7\"\n         },\n         \"name\":\"mint\",\n         \"permissions\":[\n            \"minter\"\n         ]\n      },\n      {\n         \"@type\":\"/cosmos.auth.v1beta1.ModuleAccount\",\n         \"baseAccount\":{\n            \"address\":\"cosmos17xpfvakm2amg962yls6f84z3kell8c5lserqta\",\n            \"accountNumber\":\"2\"\n         },\n         \"name\":\"fee_collector\"\n      }\n   ],\n   \"pagination\":{\n      \"total\":\"9\"\n   }\n}\n</code></pre>"},{"location":"auth/#params_1","title":"Params","text":"<p>The <code>params</code> endpoint allow users to query the current auth parameters.</p> <pre><code>cosmos.auth.v1beta1.Query/Params\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    localhost:9090 \\\n    cosmos.auth.v1beta1.Query/Params\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"params\": {\n    \"maxMemoCharacters\": \"256\",\n    \"txSigLimit\": \"7\",\n    \"txSizeCostPerByte\": \"10\",\n    \"sigVerifyCostEd25519\": \"590\",\n    \"sigVerifyCostSecp256k1\": \"1000\"\n  }\n}\n</code></pre>"},{"location":"auth/#rest","title":"REST","text":"<p>A user can query the <code>auth</code> module using REST endpoints.</p>"},{"location":"auth/#account_2","title":"Account","text":"<p>The <code>account</code> endpoint allow users to query for an account by it's address.</p> <pre><code>/cosmos/auth/v1beta1/account?address={address}\n</code></pre>"},{"location":"auth/#accounts_3","title":"Accounts","text":"<p>The <code>accounts</code> endpoint allow users to query all the available accounts.</p> <pre><code>/cosmos/auth/v1beta1/accounts\n</code></pre>"},{"location":"auth/#params_2","title":"Params","text":"<p>The <code>params</code> endpoint allow users to query the current auth parameters.</p> <pre><code>/cosmos/auth/v1beta1/params\n</code></pre>"},{"location":"auth/#vesting","title":"Vesting","text":""},{"location":"auth/#cli_1","title":"CLI","text":"<p>A user can query and interact with the <code>vesting</code> module using the CLI.</p>"},{"location":"auth/#transactions","title":"Transactions","text":"<p>The <code>tx</code> commands allow users to interact with the <code>vesting</code> module.</p> <pre><code>simd tx vesting --help\n</code></pre>"},{"location":"auth/#create-periodic-vesting-account","title":"create-periodic-vesting-account","text":"<p>The <code>create-periodic-vesting-account</code> command creates a new vesting account funded with an allocation of tokens, where a sequence of coins and period length in seconds. Periods are sequential, in that the duration of of a period only starts at the end of the previous period. The duration of the first period starts upon account creation.</p> <pre><code>simd tx vesting create-periodic-vesting-account [to_address] [periods_json_file] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx vesting create-periodic-vesting-account cosmos1.. periods.json\n</code></pre>"},{"location":"auth/#create-vesting-account","title":"create-vesting-account","text":"<p>The <code>create-vesting-account</code> command creates a new vesting account funded with an allocation of tokens. The account can either be a delayed or continuous vesting account, which is determined by the '--delayed' flag. All vesting accouts created will have their start time set by the committed block's time. The end_time must be provided as a UNIX epoch timestamp.</p> <pre><code>simd tx vesting create-vesting-account [to_address] [amount] [end_time] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx vesting create-vesting-account cosmos1.. 100stake 2592000\n</code></pre>"},{"location":"auth/#parameters","title":"Parameters","text":"<p>The auth module contains the following parameters:</p> Key Type Example MaxMemoCharacters uint64 256 TxSigLimit uint64 7 TxSizeCostPerByte uint64 10 SigVerifyCostED25519 uint64 590 SigVerifyCostSecp256k1 uint64 1000"},{"location":"bank/","title":"<code>x/bank</code>","text":""},{"location":"bank/#abstract","title":"Abstract","text":"<p>This document specifies the bank module.</p> <p>The bank module is responsible for handling multi-asset coin transfers between accounts and tracking special-case pseudo-transfers which must work differently with particular kinds of accounts (notably delegating/undelegating for vesting accounts). It exposes several interfaces with varying capabilities for secure interaction with other modules which must alter user balances.</p> <p>In addition, the bank module tracks and provides query support for the total supply of all assets used in the application.</p>"},{"location":"bank/#supply","title":"Supply","text":"<p>The <code>supply</code> functionality:</p> <ul> <li>passively tracks the total supply of coins within a chain,</li> <li>provides a pattern for modules to hold/interact with <code>Coins</code>, and</li> <li>introduces the invariant check to verify a chain's total supply.</li> </ul>"},{"location":"bank/#total-supply","title":"Total Supply","text":"<p>The total <code>Supply</code> of the network is equal to the sum of all coins from the account. The total supply is updated every time a <code>Coin</code> is minted (eg: as part of the inflation mechanism) or burned (eg: due to slashing or if a governance proposal is vetoed).</p>"},{"location":"bank/#module-accounts","title":"Module Accounts","text":"<p>The supply functionality introduces a new type of <code>auth.Account</code> which can be used by modules to allocate tokens and in special cases mint or burn tokens. At a base level these module accounts are capable of sending/receiving tokens to and from <code>auth.Account</code>s and other module accounts. This design replaces previous alternative designs where, to hold tokens, modules would burn the incoming tokens from the sender account, and then track those tokens internally. Later, in order to send tokens, the module would need to effectively mint tokens within a destination account. The new design removes duplicate logic between modules to perform this accounting.</p> <p>The <code>ModuleAccount</code> interface is defined as follows:</p> <pre><code>type ModuleAccount interface {\n  auth.Account               // same methods as the Account interface\n\n  GetName() string           // name of the module; used to obtain the address\n  GetPermissions() []string  // permissions of module account\n  HasPermission(string) bool\n}\n</code></pre> <p>WARNING! Any module or message handler that allows either direct or indirect sending of funds must explicitly guarantee those funds cannot be sent to module accounts (unless allowed).</p> <p>The supply <code>Keeper</code> also introduces new wrapper functions for the auth <code>Keeper</code> and the bank <code>Keeper</code> that are related to <code>ModuleAccount</code>s in order to be able to:</p> <ul> <li>Get and set <code>ModuleAccount</code>s by providing the <code>Name</code>.</li> <li>Send coins from and to other <code>ModuleAccount</code>s or standard <code>Account</code>s   (<code>BaseAccount</code> or <code>VestingAccount</code>) by passing only the <code>Name</code>.</li> <li><code>Mint</code> or <code>Burn</code> coins for a <code>ModuleAccount</code> (restricted to its permissions).</li> </ul>"},{"location":"bank/#permissions","title":"Permissions","text":"<p>Each <code>ModuleAccount</code> has a different set of permissions that provide different object capabilities to perform certain actions. Permissions need to be registered upon the creation of the supply <code>Keeper</code> so that every time a <code>ModuleAccount</code> calls the allowed functions, the <code>Keeper</code> can lookup the permissions to that specific account and perform or not the action.</p> <p>The available permissions are:</p> <ul> <li><code>Minter</code>: allows for a module to mint a specific amount of coins.</li> <li><code>Burner</code>: allows for a module to burn a specific amount of coins.</li> <li><code>Staking</code>: allows for a module to delegate and undelegate a specific amount of coins.</li> </ul>"},{"location":"bank/#contents","title":"Contents","text":""},{"location":"bank/#state","title":"State","text":"<p>The <code>x/bank</code> module keeps state of three primary objects, account balances, denom metadata and the total supply of all balances.</p> <ul> <li>Supply: <code>0x0 | byte(denom) -&gt; byte(amount)</code></li> <li>Denom Metadata: <code>0x1 | byte(denom) -&gt; ProtocolBuffer(Metadata)</code></li> <li>Balances: <code>0x2 | byte(address length) | []byte(address) | []byte(balance.Denom) -&gt; ProtocolBuffer(balance)</code></li> </ul>"},{"location":"bank/#keepers","title":"Keepers","text":"<p>The bank module provides these exported keeper interfaces that can be passed to other modules that read or update account balances. Modules should use the least-permissive interface that provides the functionality they require.</p> <p>Best practices dictate careful review of <code>bank</code> module code to ensure that permissions are limited in the way that you expect.</p>"},{"location":"bank/#blocklisting-addresses","title":"Blocklisting Addresses","text":"<p>The <code>x/bank</code> module accepts a map of addresses that are considered blocklisted from directly and explicitly receiving funds through means such as <code>MsgSend</code> and <code>MsgMultiSend</code> and direct API calls like <code>SendCoinsFromModuleToAccount</code>.</p> <p>Typically, these addresses are module accounts. If these addresses receive funds outside the expected rules of the state machine, invariants are likely to be broken and could result in a halted network.</p> <p>By providing the <code>x/bank</code> module with a blocklisted set of addresses, an error occurs for the operation if a user or client attempts to directly or indirectly send funds to a blocklisted account, for example, by using IBC.</p>"},{"location":"bank/#common-types","title":"Common Types","text":""},{"location":"bank/#input","title":"Input","text":"<p>An input of a multiparty transfer</p> <pre><code>// Input models transaction input.\nmessage Input {\n  string   address                        = 1;\n  repeated cosmos.base.v1beta1.Coin coins = 2;\n}\n</code></pre>"},{"location":"bank/#output","title":"Output","text":"<p>An output of a multiparty transfer.</p> <pre><code>// Output models transaction outputs.\nmessage Output {\n  string   address                        = 1;\n  repeated cosmos.base.v1beta1.Coin coins = 2;\n}\n</code></pre>"},{"location":"bank/#basekeeper","title":"BaseKeeper","text":"<p>The base keeper provides full-permission access: the ability to arbitrary modify any account's balance and mint or burn coins.</p> <p>Restricted permission to mint per module could be achieved by using baseKeeper with <code>WithMintCoinsRestriction</code> to give specific restrictions to mint (e.g. only minting certain denom).</p> <pre><code>// Keeper defines a module interface that facilitates the transfer of coins\n// between accounts.\ntype Keeper interface {\n    SendKeeper\n\n    InitGenesis(sdk.Context, *types.GenesisState)\n    ExportGenesis(sdk.Context) *types.GenesisState\n\n    GetSupply(ctx sdk.Context, denom string) sdk.Coin\n    GetPaginatedTotalSupply(ctx sdk.Context, pagination *query.PageRequest) (sdk.Coins, *query.PageResponse, error)\n    IterateTotalSupply(ctx sdk.Context, cb func(sdk.Coin) bool)\n    GetDenomMetaData(ctx sdk.Context, denom string) (types.Metadata, bool)\n    SetDenomMetaData(ctx sdk.Context, denomMetaData types.Metadata)\n    IterateAllDenomMetaData(ctx sdk.Context, cb func(types.Metadata) bool)\n\n    SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error\n    SendCoinsFromModuleToModule(ctx sdk.Context, senderModule, recipientModule string, amt sdk.Coins) error\n    SendCoinsFromAccountToModule(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error\n    DelegateCoinsFromAccountToModule(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error\n    UndelegateCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error\n    MintCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error\n    BurnCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error\n\n    DelegateCoins(ctx sdk.Context, delegatorAddr, moduleAccAddr sdk.AccAddress, amt sdk.Coins) error\n    UndelegateCoins(ctx sdk.Context, moduleAccAddr, delegatorAddr sdk.AccAddress, amt sdk.Coins) error\n\n    types.QueryServer\n}\n</code></pre>"},{"location":"bank/#sendkeeper","title":"SendKeeper","text":"<p>The send keeper provides access to account balances and the ability to transfer coins between accounts. The send keeper does not alter the total supply (mint or burn coins).</p> <pre><code>// SendKeeper defines a module interface that facilitates the transfer of coins\n// between accounts without the possibility of creating coins.\ntype SendKeeper interface {\n    ViewKeeper\n\n    InputOutputCoins(ctx sdk.Context, inputs []types.Input, outputs []types.Output) error\n    SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error\n\n    GetParams(ctx sdk.Context) types.Params\n    SetParams(ctx sdk.Context, params types.Params)\n\n    IsSendEnabledCoin(ctx sdk.Context, coin sdk.Coin) bool\n    IsSendEnabledCoins(ctx sdk.Context, coins ...sdk.Coin) error\n\n    BlockedAddr(addr sdk.AccAddress) bool\n}\n</code></pre>"},{"location":"bank/#viewkeeper","title":"ViewKeeper","text":"<p>The view keeper provides read-only access to account balances. The view keeper does not have balance alteration functionality. All balance lookups are <code>O(1)</code>.</p> <pre><code>// ViewKeeper defines a module interface that facilitates read only access to\n// account balances.\ntype ViewKeeper interface {\n    ValidateBalance(ctx sdk.Context, addr sdk.AccAddress) error\n    HasBalance(ctx sdk.Context, addr sdk.AccAddress, amt sdk.Coin) bool\n\n    GetAllBalances(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins\n    GetAccountsBalances(ctx sdk.Context) []types.Balance\n    GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin\n    LockedCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins\n    SpendableCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins\n\n    IterateAccountBalances(ctx sdk.Context, addr sdk.AccAddress, cb func(coin sdk.Coin) (stop bool))\n    IterateAllBalances(ctx sdk.Context, cb func(address sdk.AccAddress, coin sdk.Coin) (stop bool))\n}\n</code></pre>"},{"location":"bank/#messages","title":"Messages","text":""},{"location":"bank/#msgsend","title":"MsgSend","text":"<p>Send coins from one address to another. +++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28</p> <p>The message will fail under the following conditions:</p> <ul> <li>The coins do not have sending enabled</li> <li>The <code>to</code> address is restricted</li> </ul>"},{"location":"bank/#events","title":"Events","text":"<p>The bank module emits the following events:</p>"},{"location":"bank/#handlers","title":"Handlers","text":""},{"location":"bank/#msgsend_1","title":"MsgSend","text":"Type Attribute Key Attribute Value transfer recipient {recipientAddress} transfer amount {amount} message module bank message action send message sender {senderAddress}"},{"location":"bank/#keeper-events","title":"Keeper events","text":"<p>In addition to handlers events, the bank keeper will produce events when the following methods are called (or any method which ends up calling them)</p>"},{"location":"bank/#mintcoins","title":"MintCoins","text":"<pre><code>{\n  \"type\": \"coinbase\",\n  \"attributes\": [\n    {\n      \"key\": \"minter\",\n      \"value\": \"{{sdk.AccAddress of the module minting coins}}\",\n      \"index\": true\n    },\n    {\n      \"key\": \"amount\",\n      \"value\": \"{{sdk.Coins being minted}}\",\n      \"index\": true\n    }\n  ]\n}\n</code></pre> <pre><code>{\n  \"type\": \"coin_received\",\n  \"attributes\": [\n    {\n      \"key\": \"receiver\",\n      \"value\": \"{{sdk.AccAddress of the module minting coins}}\",\n      \"index\": true\n    },\n    {\n      \"key\": \"amount\",\n      \"value\": \"{{sdk.Coins being received}}\",\n      \"index\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"bank/#burncoins","title":"BurnCoins","text":"<pre><code>{\n  \"type\": \"burn\",\n  \"attributes\": [\n    {\n      \"key\": \"burner\",\n      \"value\": \"{{sdk.AccAddress of the module burning coins}}\",\n      \"index\": true\n    },\n    {\n      \"key\": \"amount\",\n      \"value\": \"{{sdk.Coins being burned}}\",\n      \"index\": true\n    }\n  ]\n}\n</code></pre> <pre><code>{\n  \"type\": \"coin_spent\",\n  \"attributes\": [\n    {\n      \"key\": \"spender\",\n      \"value\": \"{{sdk.AccAddress of the module burning coins}}\",\n      \"index\": true\n    },\n    {\n      \"key\": \"amount\",\n      \"value\": \"{{sdk.Coins being burned}}\",\n      \"index\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"bank/#addcoins","title":"addCoins","text":"<pre><code>{\n  \"type\": \"coin_received\",\n  \"attributes\": [\n    {\n      \"key\": \"receiver\",\n      \"value\": \"{{sdk.AccAddress of the address beneficiary of the coins}}\",\n      \"index\": true\n    },\n    {\n      \"key\": \"amount\",\n      \"value\": \"{{sdk.Coins being received}}\",\n      \"index\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"bank/#subunlockedcoinsdelegatecoins","title":"subUnlockedCoins/DelegateCoins","text":"<pre><code>{\n  \"type\": \"coin_spent\",\n  \"attributes\": [\n    {\n      \"key\": \"spender\",\n      \"value\": \"{{sdk.AccAddress of the address which is spending coins}}\",\n      \"index\": true\n    },\n    {\n      \"key\": \"amount\",\n      \"value\": \"{{sdk.Coins being spent}}\",\n      \"index\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"bank/#parameters","title":"Parameters","text":"<p>The bank module contains the following parameters:</p> Key Type Example SendEnabled []SendEnabled [{denom: \"stake\", enabled: true }] DefaultSendEnabled bool true"},{"location":"bank/#sendenabled","title":"SendEnabled","text":"<p>The send enabled parameter is an array of SendEnabled entries mapping coin denominations to their send_enabled status. Entries in this list take precedence over the <code>DefaultSendEnabled</code> setting.</p>"},{"location":"bank/#defaultsendenabled","title":"DefaultSendEnabled","text":"<p>The default send enabled value controls send transfer capability for all coin denominations unless specifically included in the array of <code>SendEnabled</code> parameters.</p>"},{"location":"chat/","title":"Chat","text":""},{"location":"chat/#abstract","title":"Abstract","text":"<p>This document specifies the chat module of the DaoDst.</p>"},{"location":"chat/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>State</li> <li>Keeper</li> <li>Messages</li> <li>Parameters</li> </ol>"},{"location":"chat/#module-architecture","title":"Module Architecture","text":"<p>NOTE:: If you're not familiar with the overall module structure from the SDK modules, please check this document as prerequisite reading.</p> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502   \u2514\u2500\u2500 rest\n\u2502        \u251c\u2500\u2500 error.go          # errors for api\n\u2502        \u251c\u2500\u2500 grpc.go           # query method fro grpc\n\u2502        \u251c\u2500\u2500 handle_account.go # Account details acquisition and processing\n\u2502        \u251c\u2500\u2500 handle_chat.go    # Chat module message preprocessing\n\u2502        \u251c\u2500\u2500 query.go          # Interface Query Function\n\u2502        \u251c\u2500\u2500 rest.go           # Registration of Message and Query Routes\n\u2502        \u2514\u2500\u2500 tx.go             # Tx related methods, including broadcasting, etc\n\u251c\u2500\u2500 keeper\n\u2502   \u251c\u2500\u2500 genesis.go        # Genesis state for the module\n\u2502   \u251c\u2500\u2500 keeper.go         # Store keeper that handles the business logic of the module and has access to a specific subtree of the state tree.\n\u2502   \u251c\u2500\u2500 msg_server.go     # Provide message service processing logic\n\u2502   \u251c\u2500\u2500 params.go         # Parameter getter and setter\n\u2502   \u251c\u2500\u2500 query.go          # State query functions\n\u251c\u2500\u2500 types\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codec.go          # Type registration for encoding\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 errors.go         # Module-specific errors\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 events.go         # Events exposed to the Tendermint PubSub/Websocket\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 genesis.go        # Genesis state for the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 interface.go      # interface of the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 keys.go           # Store keys and utility functions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 msg.go            # chat module transaction messages\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 params.go         # Module parameters that can be customized with governance parameter change proposals\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 types.go          # Type collection of modules\n\u251c\u2500\u2500 genesis.go            # ABCI InitGenesis and ExportGenesis functionality\n\u251c\u2500\u2500 handler.go            # Message routing\n\u2514\u2500\u2500 module.go             # Module setup for the module manager\n</code></pre>"},{"location":"chat/#concepts","title":"Concepts","text":""},{"location":"chat/#chat","title":"Chat","text":"<p>DaoDst, as a blockchain with decentralized chat, mainly manages the chat data on the chain through the 'x/chat' module, When a user registers for a chat, a broadcast will be initiated, recording the user's address, gateway, DID, chat, and other information on the chain. When other functions or modules need to call these data, they also need to be obtained through the chat module</p>"},{"location":"chat/#state","title":"State","text":"<p>The Chat module stores basic on chain data about chat users</p> <pre><code>// User Info\ntype UserInfo struct {\n    //Wallet address\n    FromAddress string `json:\"from_address\" yaml:\"from_address\"`\n    //Register Gateway\n    RegisterNodeAddress string `json:\"register_node_address\" yaml:\"register_node_address\"`\n    //Current gateway\n    NodeAddress string `json:\"node_address\" yaml:\"node_address\"`\n    //address book\n    AddressBook string `json:\"address_book\" yaml:\"address_book\"`\n    //Address book blacklist (user public key encryption)\n    ChatBlacklist string `json:\"chat_blacklist\" yaml:\"chat_blacklist\"`\n    //Chat restriction mode (feel | any | list)\n    ChatRestrictedMode string `json:\"chat_restricted_mode\" yaml:\"chat_restricted_mode\"`\n    //Address book whitelist (user public key encryption)\n    ChatWhitelist string `json:\"chat_whitelist\" yaml:\"chat_whitelist\"`\n    //Chat fee\n    ChatFee types.Coin `json:\"chat_fee\" yaml:\"chat_fee\"`\n    //Holding a mobile phone number\n    Mobile []string `json:\"mobile\" yaml:\"mobile\"`\n    //Last update time\n    UpdateTime int64 `json:\"update_time\" yaml:\"update_time\"`\n    //Address book blacklist (gateway public key encryption)\n    ChatBlackEncList string `json:\"chat_black_enc_list\" yaml:\"chat_black_enc_list\"`\n    //Address book whitelist (gateway public key encryption)\n    ChatWhiteEncList string `json:\"chat_white_enc_list\" yaml:\"chat_white_enc_list\" `\n    //remarks\n    Remarks string `json:\"remarks\" yaml:\"remarks\"`\n}\n</code></pre> <p>Users will initialize it during registration, The ChatRestrictedMode and ChatFee parameters regarding chat fees will have default values Most of the business logic of the Chat module is based on this structure</p>"},{"location":"chat/#did","title":"DID","text":"<p>When registering, users need to select the gateway they belong to and select a number range that belongs to the gateway Under this number range, users will receive a unique number (DID) that belongs to the wallet address (even if the gateway no longer exists) Outside of the preceding number range, subsequent numbers are incremented</p> <p>For example, in the 8888888 number segment of a certain gateway, the number in this segment has already reached 1234 So the next person to choose this number range will receive a number of 8888881235</p> <p>In addition to registration, you can also proactively destroy to obtain DID</p> <p>Did can voluntarily transfer</p>"},{"location":"chat/#destruction-and-pledge","title":"Destruction and Pledge","text":"<p>When registering for chat, a certain number of DSTs need to be destroyed. At the same time, the registration contract will automatically pledge the destroyed hash coins to the Pledge module, thereby obtaining a pledge reward</p>"},{"location":"chat/#chat-charging-mode","title":"Chat charging mode","text":"<p>When users register, the default chat charging mode is \"fee\", and users can change it themselves</p> <p>There are three modes as follows</p> <ul> <li>fee</li> </ul> <p>After activating the fee mode, initiating a chat or pulling into a room requires a certain fee to be paid</p> <ul> <li>any</li> </ul> <p>After opening any mode, anyone can initiate a chat with you voluntarily</p> <ul> <li>list</li> </ul> <p>After turning on the whitelist mode, only the addresses on the whitelist can initiate a chat with you (the whitelist settings belong to the chat module)</p>"},{"location":"chat/#keeper","title":"Keeper","text":"<p>The Chat module <code>Keeper</code> grants access to the Chat module state and implements <code>statedb.Keeper</code> interface to support the <code>StateDB</code> implementation. The Keeper contains a store key that allows the DB to write to a concrete subtree of the multistore that is only accessible by the Chat module. Instead of using a trie and database for querying and persistence (the <code>StateDB</code> implementation), Daodst uses the Cosmos <code>KVStore</code> (key-value store) and Cosmos SDK <code>Keeper</code> to facilitate state transitions.</p> <p>To support the interface functionality, it imports 4 module Keepers:</p> <ul> <li><code>auth</code>: CURD for accounts</li> <li><code>bank</code>: CURD for supply and balance</li> <li><code>comm</code>: Management of gateway related data</li> <li><code>pledge</code>: Pledge, Destruction, and Rewards</li> </ul> <pre><code>type Keeper struct {\n    storeKey   sdk.StoreKey\n    cdc        codec.BinaryCodec\n    paramstore paramtypes.Subspace\n\n    accountKeeper types.AccountKeeper\n    bankKeeper    types.BankKeeper\n    commKeeper    commkeeper.Keeper\n    pledgeKeeper  pledgekeeper.Keeper\n}\n\n</code></pre>"},{"location":"chat/#messages","title":"Messages","text":""},{"location":"chat/#msgsendgift","title":"MsgSendGift","text":"<pre><code>Register the address to the chat module and initialize the corresponding information through this message\n</code></pre> <pre><code>      type MsgRegister struct {\n          FromAddress    string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n          NodeAddress    string     `protobuf:\"bytes,2,opt,name=node_address,json=nodeAddress,proto3\" json:\"node_address,omitempty\" yaml:\"node_address\"`\n          MortgageAmount types.Coin `protobuf:\"bytes,3,opt,name=mortgage_amount,json=mortgageAmount,proto3\" json:\"mortgage_amount\" yaml:\"mortgage_amount\"`\n          MobilePrefix   string     `protobuf:\"bytes,4,opt,name=mobile_prefix,json=mobilePrefix,proto3\" json:\"mobile_prefix,omitempty\" yaml:\"mobile_prefix\"`\n      }\n</code></pre>"},{"location":"chat/#msgsetchatinfo","title":"MsgSetChatInfo","text":"<pre><code>Modify the data stored in the chat module corresponding to the address through this message, which accepts the full amount of user data and overwrites the original data\n</code></pre> <pre><code>    type MsgSetChatInfo struct {\n        FromAddress        string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        NodeAddress        string     `protobuf:\"bytes,2,opt,name=node_address,json=nodeAddress,proto3\" json:\"node_address,omitempty\" yaml:\"node_address\"`\n        AddressBook        string     `protobuf:\"bytes,3,opt,name=address_book,json=addressBook,proto3\" json:\"address_book,omitempty\" yaml:\"address_book\"`\n        ChatBlacklist      string     `protobuf:\"bytes,4,opt,name=chat_blacklist,json=chatBlacklist,proto3\" json:\"chat_blacklist,omitempty\" yaml:\"chat_blacklist\"`\n        ChatRestrictedMode string     `protobuf:\"bytes,5,opt,name=chat_restricted_mode,json=chatRestrictedMode,proto3\" json:\"chat_restricted_mode,omitempty\" yaml:\"chat_limit\"`\n        ChatFee            types.Coin `protobuf:\"bytes,6,opt,name=chat_fee,json=chatFee,proto3\" json:\"chat_fee\" yaml:\"chat_fee\"`\n        ChatWhitelist      string     `protobuf:\"bytes,7,opt,name=chat_whitelist,json=chatWhitelist,proto3\" json:\"chat_whitelist,omitempty\" yaml:\"chat_whitelist\"`\n        UpdateTime         int64      `protobuf:\"varint,8,opt,name=update_time,json=updateTime,proto3\" json:\"update_time,omitempty\" yaml:\"update_time\"`\n        ChatBlacklistEnc   string     `protobuf:\"bytes,9,opt,name=chat_blacklist_enc,json=chatBlacklistEnc,proto3\" json:\"chat_blacklist_enc,omitempty\" yaml:\"chat_blacklist_enc\"`\n        ChatWhitelistEnc   string     `protobuf:\"bytes,10,opt,name=chat_whitelist_enc,json=chatWhitelistEnc,proto3\" json:\"chat_whitelist_enc,omitempty\" yaml:\"chat_whitelist_enc\"`\n    }\n</code></pre>"},{"location":"chat/#msgburngetmobile","title":"MsgBurnGetMobile","text":"<pre><code>By destroying this message, the did is obtained. The prefix of the obtained did is the selected did number segment, and the suffix is incremented under this number segment\nIf the number segment does not match the gateway or the number under the segment is full, the acquisition fails\n</code></pre> <pre><code>    type MsgBurnGetMobile struct {\n        FromAddress  string `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        MobilePrefix string `protobuf:\"bytes,2,opt,name=mobile_prefix,json=mobilePrefix,proto3\" json:\"mobile_prefix,omitempty\" yaml:\"mobile_prefix\"`\n    }\n</code></pre>"},{"location":"chat/#msgmobiletransfer","title":"MsgMobileTransfer","text":"<pre><code>The held DID can be transferred\nIf the other party's hold of DID has reached the maximum holding amount, the transfer fails\n</code></pre> <pre><code>    type MsgMobileTransfer struct {\n        FromAddress string `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        ToAddress   string `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        Mobile      string `protobuf:\"bytes,3,opt,name=mobile,proto3\" json:\"mobile,omitempty\" yaml:\"mobile\"`\n    }\n</code></pre>"},{"location":"chat/#msgchatsendgift","title":"MsgChatSendGift","text":"<pre><code>Chat payment. If the other party has set a chat fee, this message needs to be sent to pay a certain token to the other party\n</code></pre> <pre><code>    type MsgChatSendGift struct {\n        FromAddress string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        ToAddress   string     `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        GiftValue   types.Coin `protobuf:\"bytes,3,opt,name=gift_value,json=giftValue,proto3\" json:\"gift_value\" yaml:\"gift_value\"`\n    }\n</code></pre>"},{"location":"chat/#parameters","title":"Parameters","text":"<p>The chat module contains the following module parameters</p>"},{"location":"chat/#params","title":"Params","text":"Key Type Default Value <code>MaxPhoneNumber</code> uint64 <code>10</code> <code>DestroyPhoneNumberCoin</code> github.com/cosmos/cosmos-sdk/types.Coin <code>100000000000000000000dst</code> <code>ChatFee</code> github.com/cosmos/cosmos-sdk/types.Coin <code>1000000000000000000dst</code> <code>MinRegisterBurnAmount</code> github.com/cosmos/cosmos-sdk/types.Coin <code>100000000000000000000dst</code>"},{"location":"contract/","title":"Contract","text":""},{"location":"contract/#abstract","title":"Abstract","text":"<p>This module is responsible for transactions and queries related to evm</p>"},{"location":"contract/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>Keeper</li> <li>Messages</li> </ol> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502 \u2514\u2500\u2500 rest\n\u2502 \u251c\u2500\u2500 error.go # interface error collection\n\u2502 \u251c\u2500\u2500 grpc.go # grpc query method\n\u2502 \u251c\u2500\u2500 handle_comm.go # comm module message pre-processing\n\u2502 \u251c\u2500\u2500 query.go # interface query function\n\u2502 \u251c\u2500\u2500 rest.go # Registration of message and query routing\n\u2502 \u2514\u2500\u2500 tx.go # tx related methods, including broadcasting, etc.\n\u251c\u2500\u2500keeper\n\u2502 \u251c\u2500\u2500 genesis.go # Status and export of modules\n\u2502 \u251c\u2500\u2500 keeper.go # storage manager, handles the business logic of the module, and has permission to access specific subtrees of the state tree\n\u2502 \u251c\u2500\u2500 msg_server.go # Provide service processing logic for uplink messages\n\u2502 \u251c\u2500\u2500 params.go # Setting and obtaining module parameters\n\u2502 \u251c\u2500\u2500 query.go # Status query function\n\u2502 \u251c\u2500\u2500 medal.go # Hash coin pledge calculation related logic algorithm\n\u2502 \u2514\u2500\u2500 mingkeeper.go # Foundry related logic algorithm\n\u251c\u2500\u2500 types\n\u2502 \u251c\u2500\u2500 codec.go # code registration type\n\u2502 \u251c\u2500\u2500 errors.go # module-specific errors\n\u2502 \u251c\u2500\u2500 events.go # Events exposed to Tendermint PubSub/Websocket\n\u2502 \u251c\u2500\u2500 genesis.go # Genesis state of the module\n\u2502 \u251c\u2500\u2500 interface.go # interface collection of modules\n\u2502 \u251c\u2500\u2500 keys.go # module stores key and some other constants\n\u2502 \u251c\u2500\u2500 msg.go # Chat module transaction message\n\u2502 \u251c\u2500\u2500 params.go # The custom parameters that the module can modify through the governance module\n\u2502 \u251c\u2500\u2500 interface.go # The method implemented by the imported external module\n\u2502 \u2514\u2500\u2500 types.go # module type collection\n\u251c\u2500\u2500 genesis.go # ABCI's genesis state initialization and export function\n\u251c\u2500\u2500 handler.go # message routing\n\u2514\u2500\u2500 module.go # Module settings of the module manager\n</code></pre>"},{"location":"contract/#overview","title":"Overview","text":""},{"location":"contract/#contract","title":"Contract","text":"<pre><code> Contract is responsible for the content related to the evm contract\n</code></pre>"},{"location":"contract/#one-click-coin-issuance","title":"One-click coin issuance","text":"<pre><code> Users can directly publish their own tokens on evm through messages, only need to upload some basic information of tokens, no need to deploy token contracts\n Everything is done automatically inside the contract\n</code></pre>"},{"location":"contract/#cross-chain-transfer","title":"Cross-chain transfer","text":"<pre><code> This module can be used to realize the token mapping transfer (such as ETH) from DaoDst to the external chain, and the cross-chain supports two-way\n\n When DaoDst transfers funds to the external chain, the balance inside DaoDst will be frozen, and at the same time, the external chain contract will issue corresponding tokens\n Correspondingly, when the opposite operation is performed, the external chain is destroyed and Daodst is unfrozen\n</code></pre>"},{"location":"contract/#keeper","title":"Keeper","text":"<p>The contract module 'Keeper' grants access to the state of the chat module And implement 'statedb. Interface to support 'StateDB' implementation. Keeper contains a storage key that allows the repository Write to the concrete subtree of the multibase that can only be accessed by the Chat module. Instead of using trees and databases for querying and persistence (the 'StateDB' implementation), DaoDst uses Cosmos' \"KVStore\" (key-value store) and Cosmos SDK's \"Keeper\" to facilitate state transitions.</p> <p>In order to support the interface function, it imports 7 module Keepers:</p> <ul> <li><code>auth</code>: addition, deletion, modification and query of accounts</li> <li><code>bank</code>: addition, deletion, modification and query of supply and balance</li> <li><code>staking</code>: management of gateway related data</li> <li><code>pledge</code>: management of chat related data</li> <li><code>evm</code>: management of evm related data</li> <li><code>chat</code>: management of chat related data</li> <li><code>gateway</code>: gateway data management</li> </ul> <pre><code>    type Keeper struct {\n        storeKey   sdk.StoreKey\n        cdc        codec.BinaryCodec\n        paramstore paramtypes.Subspace\n\n        stakingKeeper *stakingKeeper.Keeper\n        accountKeeper types.AccountKeeper\n        BankKeeper    types.BankKeeper\n        pledgeKeeper  types.PledgeKeeper\n        evmKeeper     types.EVMKeeper\n        chatKeeper    types.ChatKeeper\n        gatewayKeeper types.GatewayKeeper\n        erc20Keeper   erc20keeper.Keeper\n    }\n</code></pre>"},{"location":"contract/#messages","title":"Messages","text":""},{"location":"contract/#msgapptokenissue","title":"MsgAppTokenIssue","text":"<pre><code>Through this message, initiate one-click coin issuance\n</code></pre> <pre><code>    type MsgAppTokenIssue struct {\n        FromAddress   string `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        Name          string `protobuf:\"bytes,2,opt,name=name,proto3\" json:\"name,omitempty\" yaml:\"name\"`\n        Symbol        string `protobuf:\"bytes,3,opt,name=symbol,proto3\" json:\"symbol,omitempty\" yaml:\"symbol\"`\n        PreMintAmount string `protobuf:\"bytes,4,opt,name=pre_mint_amount,json=preMintAmount,proto3\" json:\"pre_mint_amount,omitempty\" yaml:\"pre_mint_amount\"`\n        Decimals      string `protobuf:\"bytes,5,opt,name=decimals,proto3\" json:\"decimals,omitempty\" yaml:\"decimals\"`\n        LogoUrl       string `protobuf:\"bytes,6,opt,name=logo_url,json=logoUrl,proto3\" json:\"logo_url,omitempty\" yaml:\"logo_url\"`\n    }\n</code></pre>"},{"location":"contract/#msgcrosschainout","title":"MsgCrossChainOut","text":"<pre><code>Through this message, initiate a cross-chain transfer from DaoDst\n</code></pre> <pre><code>    type MsgCrossChainOut struct {\n        SendAddress string `protobuf:\"bytes,1,opt,name=send_address,json=sendAddress,proto3\" json:\"send_address,omitempty\" yaml:\"send_address\"`\n        ToAddress   string `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        Coins       string `protobuf:\"bytes,3,opt,name=coins,proto3\" json:\"coins,omitempty\" yaml:\"coins\"`\n        ChainType   string `protobuf:\"bytes,4,opt,name=chain_type,json=chainType,proto3\" json:\"chain_type,omitempty\" yaml:\"chain_type\"`\n        Remark      string `protobuf:\"bytes,5,opt,name=remark,proto3\" json:\"remark,omitempty\" yaml:\"remark\"`\n    }\n</code></pre>"},{"location":"contract/#msgcrosschainin","title":"MsgCrossChainIn","text":"<p>Through this message, a cross-chain transfer to DaoDst is initiated from the external chain</p> <pre><code>    type MsgCrossChainIn struct {\n        SendAddress string `protobuf:\"bytes,1,opt,name=send_address,json=sendAddress,proto3\" json:\"send_address,omitempty\" yaml:\"send_address\"`\n        Coins       string `protobuf:\"bytes,2,opt,name=coins,proto3\" json:\"coins,omitempty\" yaml:\"coins\"`\n        ChainType   string `protobuf:\"bytes,3,opt,name=chain_type,json=chainType,proto3\" json:\"chain_type,omitempty\" yaml:\"chain_type\"`\n        Remark      string `protobuf:\"bytes,4,opt,name=remark,proto3\" json:\"remark,omitempty\" yaml:\"remark\"`\n        TxHash      string `protobuf:\"bytes,5,opt,name=tx_hash,json=txHash,proto3\" json:\"tx_hash,omitempty\" yaml:\"tx_hash\"`\n    }\n</code></pre>"},{"location":"distribute/","title":"<code>distribution</code>","text":""},{"location":"distribute/#overview","title":"Overview","text":"<p>This simple distribution mechanism describes a functional way to passively distribute rewards between validators and delegators. Note that this mechanism does not distribute funds in as precisely as active reward distribution mechanisms and will therefore be upgraded in the future.</p> <p>The mechanism operates as follows. Collected rewards are pooled globally and divided out passively to validators and delegators. Each validator has the opportunity to charge commission to the delegators on the rewards collected on behalf of the delegators. Fees are collected directly into a global reward pool and validator proposer-reward pool. Due to the nature of passive accounting, whenever changes to parameters which affect the rate of reward distribution occurs, withdrawal of rewards must also occur.</p> <ul> <li>Whenever withdrawing, one must withdraw the maximum amount they are entitled    to, leaving nothing in the pool.</li> <li>Whenever bonding, unbonding, or re-delegating tokens to an existing account, a    full withdrawal of the rewards must occur (as the rules for lazy accounting    change).</li> <li>Whenever a validator chooses to change the commission on rewards, all accumulated    commission rewards must be simultaneously withdrawn.</li> </ul> <p>The above scenarios are covered in <code>hooks.md</code>.</p> <p>The distribution mechanism outlined herein is used to lazily distribute the following rewards between validators and associated delegators:</p> <ul> <li>multi-token fees to be socially distributed</li> <li>proposer reward pool</li> <li>inflated atom provisions</li> <li>validator commission on all rewards earned by their delegators stake</li> </ul> <p>Fees are pooled within a global pool, as well as validator specific proposer-reward pools. The mechanisms used allow for validators and delegators to independently and lazily withdraw their rewards.</p>"},{"location":"distribute/#shortcomings","title":"Shortcomings","text":"<p>As a part of the lazy computations, each delegator holds an accumulation term specific to each validator which is used to estimate what their approximate fair portion of tokens held in the global fee pool is owed to them.</p> <pre><code>entitlement = delegator-accumulation / all-delegators-accumulation\n</code></pre> <p>Under the circumstance that there was constant and equal flow of incoming reward tokens every block, this distribution mechanism would be equal to the active distribution (distribute individually to all delegators each block). However, this is unrealistic so deviations from the active distribution will occur based on fluctuations of incoming reward tokens as well as timing of reward withdrawal by other delegators.</p> <p>If you happen to know that incoming rewards are about to significantly increase, you are incentivized to not withdraw until after this event, increasing the worth of your existing accum. See #2764 for further details.</p>"},{"location":"distribute/#effect-on-staking","title":"Effect on Staking","text":"<p>Charging commission on Atom provisions while also allowing for Atom-provisions to be auto-bonded (distributed directly to the validators bonded stake) is problematic within BPoS. Fundamentally, these two mechanisms are mutually exclusive. If both commission and auto-bonding mechanisms are simultaneously applied to the staking-token then the distribution of staking-tokens between any validator and its delegators will change with each block. This then necessitates a calculation for each delegation records for each block - which is considered computationally expensive.</p> <p>In conclusion, we can only have Atom commission and unbonded atoms provisions or bonded atom provisions with no Atom commission, and we elect to implement the former. Stakeholders wishing to rebond their provisions may elect to set up a script to periodically withdraw and rebond rewards.</p>"},{"location":"distribute/#contents","title":"Contents","text":""},{"location":"distribute/#concepts","title":"Concepts","text":"<p>In Proof of Stake (PoS) blockchains, rewards gained from transaction fees are paid to validators. The fee distribution module fairly distributes the rewards to the validators' constituent delegators.</p> <p>Rewards are calculated per period. The period is updated each time a validator's delegation changes, for example, when the validator receives a new delegation. The rewards for a single validator can then be calculated by taking the total rewards for the period before the delegation started, minus the current total rewards.</p> <p>The commission to the validator is paid when the validator is removed or when the validator requests a withdrawal. The commission is calculated and incremented at every <code>BeginBlock</code> operation to update accumulated fee amounts.</p> <p>The rewards to a delegator are distributed when the delegation is changed or removed, or a withdrawal is requested. Before rewards are distributed, all slashes to the validator that occurred during the current delegation are applied.</p>"},{"location":"distribute/#reference-counting-in-f1-fee-distribution","title":"Reference Counting in F1 Fee Distribution","text":"<p>In F1 fee distribution, the rewards a delegator receives are calculated when their delegation is withdrawn. This calculation must read the terms of the summation of rewards divided by the share of tokens from the period which they ended when they delegated, and the final period that was created for the withdrawal.</p> <p>Additionally, as slashes change the amount of tokens a delegation will have (but we calculate this lazily, only when a delegator un-delegates), we must calculate rewards in separate periods before / after any slashes which occurred in between when a delegator delegated and when they withdrew their rewards. Thus slashes, like delegations, reference the period which was ended by the slash event.</p> <p>All stored historical rewards records for periods which are no longer referenced by any delegations or any slashes can thus be safely removed, as they will never be read (future delegations and future slashes will always reference future periods). This is implemented by tracking a <code>ReferenceCount</code> along with each historical reward storage entry. Each time a new object (delegation or slash) is created which might need to reference the historical record, the reference count is incremented. Each time one object which previously needed to reference the historical record is deleted, the reference count is decremented. If the reference count hits zero, the historical record is deleted.</p>"},{"location":"distribute/#state","title":"State","text":""},{"location":"distribute/#feepool","title":"FeePool","text":"<p>All globally tracked parameters for distribution are stored within <code>FeePool</code>. Rewards are collected and added to the reward pool and distributed to validators/delegators from here.</p> <p>Note that the reward pool holds decimal coins (<code>DecCoins</code>) to allow for fractions of coins to be received from operations like inflation. When coins are distributed from the pool they are truncated back to <code>sdk.Coins</code> which are non-decimal.</p> <ul> <li>FeePool: <code>0x00 -&gt; ProtocolBuffer(FeePool)</code></li> </ul> <pre><code>// coins with decimal\ntype DecCoins []DecCoin\n\ntype DecCoin struct {\n    Amount sdk.Dec\n    Denom  string\n}\n</code></pre> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/distribution/v1beta1/distribution.proto#L94-L101</p>"},{"location":"distribute/#validator-distribution","title":"Validator Distribution","text":"<p>Validator distribution information for the relevant validator is updated each time:</p> <ol> <li>delegation amount to a validator is updated,</li> <li>a validator successfully proposes a block and receives a reward,</li> <li>any delegator withdraws from a validator, or</li> <li> <p>the validator withdraws its commission.</p> </li> <li> <p>ValidatorDistInfo: <code>0x02 | ValOperatorAddrLen (1 byte) | ValOperatorAddr -&gt; ProtocolBuffer(validatorDistribution)</code></p> </li> </ol> <pre><code>type ValidatorDistInfo struct {\n    OperatorAddress     sdk.AccAddress\n    SelfBondRewards     sdk.DecCoins\n    ValidatorCommission types.ValidatorAccumulatedCommission\n}\n</code></pre>"},{"location":"distribute/#delegation-distribution","title":"Delegation Distribution","text":"<p>Each delegation distribution only needs to record the height at which it last withdrew fees. Because a delegation must withdraw fees each time it's properties change (aka bonded tokens etc.) its properties will remain constant and the delegator's accumulation factor can be calculated passively knowing only the height of the last withdrawal and its current properties.</p> <ul> <li>DelegationDistInfo: <code>0x02 | DelegatorAddrLen (1 byte) | DelegatorAddr | ValOperatorAddrLen (1 byte) | ValOperatorAddr -&gt; ProtocolBuffer(delegatorDist)</code></li> </ul> <pre><code>type DelegationDistInfo struct {\n    WithdrawalHeight int64    // last time this delegation withdrew rewards\n}\n</code></pre>"},{"location":"distribute/#begin-block","title":"Begin Block","text":"<p>At each <code>BeginBlock</code>, all fees received in the previous block are transferred to the distribution <code>ModuleAccount</code> account. When a delegator or validator withdraws their rewards, they are taken out of the <code>ModuleAccount</code>. During begin block, the different claims on the fees collected are updated as follows:</p> <ul> <li>The block proposer of the previous height and its delegators receive between 1% and 5% of fee rewards.</li> <li>The reserve community tax is charged.</li> <li>The remainder is distributed proportionally by voting power to all bonded validators</li> </ul> <p>To incentivize validators to wait and include additional pre-commits in the block, the block proposer reward is calculated from Tendermint pre-commit messages.</p>"},{"location":"distribute/#the-distribution-scheme","title":"The Distribution Scheme","text":"<p>See params for description of parameters.</p> <p>Let <code>fees</code> be the total fees collected in the previous block, including inflationary rewards to the stake. All fees are collected in a specific module account during the block. During <code>BeginBlock</code>, they are sent to the <code>\"distribution\"</code> <code>ModuleAccount</code>. No other sending of tokens occurs. Instead, the rewards each account is entitled to are stored, and withdrawals can be triggered through the messages <code>FundCommunityPool</code>, <code>WithdrawValidatorCommission</code> and <code>WithdrawDelegatorReward</code>.</p>"},{"location":"distribute/#reward-to-the-community-pool","title":"Reward to the Community Pool","text":"<p>The community pool gets <code>community_tax * fees</code>, plus any remaining dust after validators get their rewards that are always rounded down to the nearest integer value.</p>"},{"location":"distribute/#reward-to-the-validators","title":"Reward To the Validators","text":"<p>The proposer receives a base reward of <code>fees * baseproposerreward</code> and a bonus of <code>fees * bonusproposerreward * P</code>, where <code>P = (total power of validators with included precommits / total bonded validator power)</code>. The more precommits the proposer includes, the larger <code>P</code> is. <code>P</code> can never be larger than <code>1.00</code> (since only bonded validators can supply valid precommits) and is always larger than <code>2/3</code>.</p> <p>Any remaining fees are distributed among all the bonded validators, including the proposer, in proportion to their consensus power.</p> <pre><code>powFrac = validator power / total bonded validator power\nproposerMul = baseproposerreward + bonusproposerreward * P\nvoteMul = 1 - communitytax - proposerMul\n</code></pre> <p>In total, the proposer receives <code>fees  * (voteMul * powFrac + proposerMul)</code>. All other validators receive <code>fees * voteMul * powFrac</code>.</p>"},{"location":"distribute/#rewards-to-delegators","title":"Rewards to Delegators","text":"<p>Each validator's rewards are distributed to its delegators. The validator also has a self-delegation that is treated like a regular delegation in distribution calculations.</p> <p>The validator sets a commission rate. The commission rate is flexible, but each validator sets a maximum rate and a maximum daily increase. These maximums cannot be exceeded and protect delegators from sudden increases of validator commission rates to prevent validators from taking all of the rewards.</p> <p>The outstanding rewards that the operator is entitled to are stored in <code>ValidatorAccumulatedCommission</code>, while the rewards the delegators are entitled to are stored in <code>ValidatorCurrentRewards</code>. The F1 fee distribution scheme is used to calculate the rewards per delegator as they withdraw or update their delegation, and is thus not handled in <code>BeginBlock</code>.</p>"},{"location":"distribute/#example-distribution","title":"Example Distribution","text":"<p>For this example distribution, the underlying consensus engine selects block proposers in proportion to their power relative to the entire bonded power.</p> <p>All validators are equally performant at including pre-commits in their proposed blocks. Then hold <code>(precommits included) / (total bonded validator power)</code> constant so that the amortized block reward for the validator is <code>( validator power / total bonded power) * (1 - community tax rate)</code> of the total rewards. Consequently, the reward for a single delegator is:</p> <pre><code>(delegator proportion of the validator power / validator power) * (validator power / total bonded power)\n  * (1 - community tax rate) * (1 - validator commision rate)\n= (delegator proportion of the validator power / total bonded power) * (1 -\ncommunity tax rate) * (1 - validat\n\n\n# Messages\n\n## MsgSetWithdrawAddress\n\nBy default, the withdraw address is the delegator address. To change its withdraw address, a delegator must send a `MsgSetWithdrawAddress` message.\nChanging the withdraw address is possible only if the parameter `WithdrawAddrEnabled` is set to `true`.\n\nThe withdraw address cannot be any of the module accounts. These accounts are blocked from being withdraw addresses by being added to the distribution keeper's `blockedAddrs` array at initialization.\n\nResponse:\n\n+++ https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37\n\n```go\nfunc (k Keeper) SetWithdrawAddr(ctx sdk.Context, delegatorAddr sdk.AccAddress, withdrawAddr sdk.AccAddress) error\n    if k.blockedAddrs[withdrawAddr.String()] {\n        fail with \"`{withdrawAddr}` is not allowed to receive external funds\"\n    }\n\n    if !k.GetWithdrawAddrEnabled(ctx) {\n        fail with `ErrSetWithdrawAddrDisabled`\n    }\n\n    k.SetDelegatorWithdrawAddr(ctx, delegatorAddr, withdrawAddr)\n</code></pre>"},{"location":"distribute/#msgwithdrawdelegatorreward","title":"MsgWithdrawDelegatorReward","text":"<p>A delegator can withdraw its rewards. Internally in the distribution module, this transaction simultaneously removes the previous delegation with associated rewards, the same as if the delegator simply started a new delegation of the same value. The rewards are sent immediately from the distribution <code>ModuleAccount</code> to the withdraw address. Any remainder (truncated decimals) are sent to the community pool. The starting height of the delegation is set to the current validator period, and the reference count for the previous period is decremented. The amount withdrawn is deducted from the <code>ValidatorOutstandingRewards</code> variable for the validator.</p> <p>In the F1 distribution, the total rewards are calculated per validator period, and a delegator receives a piece of those rewards in proportion to their stake in the validator. In basic F1, the total rewards that all the delegators are entitled to between to periods is calculated the following way. Let <code>R(X)</code> be the total accumulated rewards up to period <code>X</code> divided by the tokens staked at that time. The delegator allocation is <code>R(X) * delegator_stake</code>. Then the rewards for all the delegators for staking between periods <code>A</code> and <code>B</code> are <code>(R(B) - R(A)) * total stake</code>. However, these calculated rewards don't account for slashing.</p> <p>Taking the slashes into account requires iteration. Let <code>F(X)</code> be the fraction a validator is to be slashed for a slashing event that happened at period <code>X</code>. If the validator was slashed at periods <code>P1, ..., PN</code>, where <code>A &lt; P1</code>, <code>PN &lt; B</code>, the distribution module calculates the individual delegator's rewards, <code>T(A, B)</code>, as follows:</p> <pre><code>stake := initial stake\nrewards := 0\nprevious := A\nfor P in P1, ..., PN`:\n    rewards = (R(P) - previous) * stake\n    stake = stake * F(P)\n    previous = P\nrewards = rewards + (R(B) - R(PN)) * stake\n</code></pre> <p>The historical rewards are calculated retroactively by playing back all the slashes and then attenuating the delegator's stake at each step. The final calculated stake is equivalent to the actual staked coins in the delegation with a margin of error due to rounding errors.</p> <p>Response:</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50</p>"},{"location":"distribute/#withdrawvalidatorcommission","title":"WithdrawValidatorCommission","text":"<p>The validator can send the WithdrawValidatorCommission message to withdraw their accumulated commission. The commission is calculated in every block during <code>BeginBlock</code>, so no iteration is required to withdraw. The amount withdrawn is deducted from the <code>ValidatorOutstandingRewards</code> variable for the validator. Only integer amounts can be sent. If the accumulated awards have decimals, the amount is truncated before the withdrawal is sent, and the remainder is left to be withdrawn later.</p>"},{"location":"distribute/#fundcommunitypool","title":"FundCommunityPool","text":"<p>This message sends coins directly from the sender to the community pool.</p> <p>The transaction fails if the amount cannot be transferred from the sender to the distribution module account.</p> <pre><code>func (k Keeper) FundCommunityPool(ctx sdk.Context, amount sdk.Coins, sender sdk.AccAddress) error {\n    if err := k.bankKeeper.SendCoinsFromAccountToModule(ctx, sender, types.ModuleName, amount); err != nil {\n        return err\n    }\n\n    feePool := k.GetFeePool(ctx)\n    feePool.CommunityPool = feePool.CommunityPool.Add(sdk.NewDecCoinsFromCoins(amount...)...)\n    k.SetFeePool(ctx, feePool)\n\n    return nil\n}\n</code></pre>"},{"location":"distribute/#common-distribution-operations","title":"Common distribution operations","text":"<p>These operations take place during many different messages.</p>"},{"location":"distribute/#initialize-delegation","title":"Initialize delegation","text":"<p>Each time a delegation is changed, the rewards are withdrawn and the delegation is reinitialized. Initializing a delegation increments the validator period and keeps track of the starting period of the delegation.</p> <pre><code>// initialize starting info for a new delegation\nfunc (k Keeper) initializeDelegation(ctx sdk.Context, val sdk.ValAddress, del sdk.AccAddress) {\n    // period has already been incremented - we want to store the period ended by this delegation action\n    previousPeriod := k.GetValidatorCurrentRewards(ctx, val).Period - 1\n\n    // increment reference count for the period we're going to track\n    k.incrementReferenceCount(ctx, val, previousPeriod)\n\n    validator := k.stakingKeeper.Validator(ctx, val)\n    delegation := k.stakingKeeper.Delegation(ctx, del, val)\n\n    // calculate delegation stake in tokens\n    // we don't store directly, so multiply delegation shares * (tokens per share)\n    // note: necessary to truncate so we don't allow withdrawing more rewards than owed\n    stake := validator.TokensFromSharesTruncated(delegation.GetShares())\n    k.SetDelegatorStartingInfo(ctx, val, del, types.NewDelegatorStartingInfo(previousPeriod, stake, uint64(ctx.BlockHeight())))\n}\n</code></pre>"},{"location":"distribute/#hooks","title":"Hooks","text":"<p>Available hooks that can be called by and from this module.</p>"},{"location":"distribute/#create-or-modify-delegation-distribution","title":"Create or modify delegation distribution","text":"<ul> <li>triggered-by: <code>staking.MsgDelegate</code>, <code>staking.MsgBeginRedelegate</code>, <code>staking.MsgUndelegate</code></li> </ul>"},{"location":"distribute/#before","title":"Before","text":"<ul> <li>The delegation rewards are withdrawn to the withdraw address of the delegator.   The rewards include the current period and exclude the starting period.</li> <li>The validator period is incremented.   The validator period is incremented because the validator's power and share distribution might have changed.</li> <li>The reference count for the delegator's starting period is decremented.</li> </ul>"},{"location":"distribute/#after","title":"After","text":"<p>The starting height of the delegation is set to the previous period. Because of the <code>Before</code>-hook, this period is the last period for which the delegator was rewarded.</p>"},{"location":"distribute/#validator-created","title":"Validator created","text":"<ul> <li>triggered-by: <code>staking.MsgCreateValidator</code></li> </ul> <p>When a validator is created, the following validator variables are initialized:</p> <ul> <li>Historical rewards</li> <li>Current accumulated rewards</li> <li>Accumulated commission</li> <li>Total outstanding rewards</li> <li>Period</li> </ul> <p>By default, all values are set to a <code>0</code>, except period, which is set to <code>1</code>.</p>"},{"location":"distribute/#validator-removed","title":"Validator removed","text":"<ul> <li>triggered-by: <code>staking.RemoveValidator</code></li> </ul> <p>Outstanding commission is sent to the validator's self-delegation withdrawal address. Remaining delegator rewards get sent to the community fee pool.</p> <p>Note: The validator gets removed only when it has no remaining delegations. At that time, all outstanding delegator rewards will have been withdrawn. Any remaining rewards are dust amounts.</p>"},{"location":"distribute/#validator-is-slashed","title":"Validator is slashed","text":"<ul> <li> <p>triggered-by: <code>staking.Slash</code></p> </li> <li> <p>The current validator period reference count is incremented.   The reference count is incremented because the slash event has created a reference to it.</p> </li> <li>The validator period is incremented.</li> <li>The slash event is stored for later use.   The slash event will be referenced when calculating delegator rewards.</li> </ul>"},{"location":"distribute/#events","title":"Events","text":"<p>The distribution module emits the following events:</p>"},{"location":"distribute/#beginblocker","title":"BeginBlocker","text":"Type Attribute Key Attribute Value proposer_reward validator {validatorAddress} proposer_reward reward {proposerReward} commission amount {commissionAmount} commission validator {validatorAddress} rewards amount {rewardAmount} rewards validator {validatorAddress}"},{"location":"distribute/#handlers","title":"Handlers","text":""},{"location":"distribute/#msgsetwithdrawaddress","title":"MsgSetWithdrawAddress","text":"Type Attribute Key Attribute Value set_withdraw_address withdraw_address {withdrawAddress} message module distribution message action set_withdraw_address message sender {senderAddress}"},{"location":"distribute/#msgwithdrawdelegatorreward_1","title":"MsgWithdrawDelegatorReward","text":"Type Attribute Key Attribute Value withdraw_rewards amount {rewardAmount} withdraw_rewards validator {validatorAddress} message module distribution message action withdraw_delegator_reward message sender {senderAddress}"},{"location":"distribute/#msgwithdrawvalidatorcommission","title":"MsgWithdrawValidatorCommission","text":"Type Attribute Key Attribute Value withdraw_commission amount {commissionAmount} message module distribution message action withdraw_validator_commission message sender {senderAddress}"},{"location":"distribute/#parameters","title":"Parameters","text":"<p>The distribution module contains the following parameters:</p> Key Type Example communitytax string (dec) \"0.020000000000000000\" [0] baseproposerreward string (dec) \"0.010000000000000000\" [0] bonusproposerreward string (dec) \"0.040000000000000000\" [0] withdrawaddrenabled bool true <ul> <li>[0] <code>communitytax</code>, <code>baseproposerreward</code> and <code>bonusproposerreward</code> must be   positive and their sum cannot exceed 1.00.</li> </ul>"},{"location":"evm/","title":"Evm","text":""},{"location":"evm/#abstract","title":"Abstract","text":"<p>This document defines the specification of the Ethereum Virtual Machine (EVM) as a Cosmos SDK module.</p> <p>Since the introduction of Ethereum in 2015, the ability to control digital assets through [smart contracts] has attracted a large number of developers to build decentralized applications on the Ethereum Virtual Machine (EVM). This community continues to create a wide range of tools and introduce standards, which further increases the adoption rate of EVM-compatible technologies.</p> <p>However, the growth of EVM-based chains such as Ethereum has revealed some scalability challenges, often referred to as the decentralization, security, and scalability trilemma. Developers are frustrated by high gas fees, slow transaction speeds and throughput, and chain-specific governance that undergoes only slow changes due to their widely deployed applications. A solution is needed to allay these concerns for developers building applications in the familiar EVM environment.</p> <p>The <code>x/evm</code> module provides this EVM familiarity on scalable, high-throughput proof-of-stake blockchains. It is built as a Cosmos SDK module, allowing deployment of smart contracts, interaction with the EVM state machine (state transitions), and use of EVM tools . It is available for Cosmos application-specific blockchains through Tendermint Core high transaction throughput, fast transaction finality and IBC to alleviate the above problems.</p>"},{"location":"evm/#content","title":"content","text":"<ol> <li>Concepts</li> <li>state</li> <li>state transitions</li> <li>Transactions</li> <li>ABCI</li> <li>hooks</li> <li>Events</li> <li>Parameters</li> <li>client</li> </ol>"},{"location":"evm/#module-architecture","title":"Module architecture","text":"<p>Note:: If you are not familiar with the overall module structure of SDK modules, please read this document first as a prerequisite .</p> <pre><code>evm/\n\u251c\u2500\u2500 client\n\u2502 \u2514\u2500\u2500 cli\n\u2502 \u251c\u2500\u2500 query.go # Module CLI query command\n\u2502 \u2514\u2500\u2500 tx.go # CLI transaction command of the module\n\u251c\u2500\u2500keeper\n\u2502 \u251c\u2500\u2500 abci.go # ABCI start and end block logic\n\u2502 \u251c\u2500\u2500 keeper.go # Process the business logic of the module.\n\u2502 \u251c\u2500\u2500 params.go # parameter getter and setter\n\u2502 \u251c\u2500\u2500 queryer.go # status query function\n\u2502 \u2514\u2500\u2500 statedb.go # Functions from types/statedb passed into sdk.Context\n\u251c\u2500\u2500 types\n\u2502 \u251c\u2500\u2500 chain_config.go\n\u2502 \u251c\u2500\u2500 codec.go # Encoding type registration\n\u2502 \u251c\u2500\u2500 errors.go # Module-specific errors\n\u2502 \u251c\u2500\u2500 events.go # Events exposed to Tendermint PubSub/Websocket\n\u2502 \u251c\u2500\u2500 genesis.go # Genesis state of the module\n\u2502 \u251c\u2500\u2500 journal.go # Ethereum state transition transactions\n\u2502 \u251c\u2500\u2500 keys.go # Store keys and utility functions\n\u2502 \u251c\u2500\u2500 logs.go # Persistent Ethereum tx login status type after chain upgrade\n\u2502 \u251c\u2500\u2500 msg.go #EVM module transaction message\n\u2502 \u251c\u2500\u2500 params.go # Governance parameters can be used to change suggested custom module parameters\n\u2502 \u251c\u2500\u2500 state_object.go # EVM state object\n\u2502 \u251c\u2500\u2500 statedb.go # Implementation of StateDb interface\n\u2502 \u251c\u2500\u2500 storage.go # Use arrays to implement Ethereum state storage mapping to prevent non-determinism\n\u2502 \u2514\u2500\u2500 tx_data.go # Ethereum transaction data type\n\u251c\u2500\u2500 genesis.go # ABCI InitGenesis and ExportGenesis functions\n\u251c\u2500\u2500 handler.go # message routing\n\u2514\u2500\u2500 module.go # Module settings for the module manager\n</code></pre>"},{"location":"evm/#concept","title":"concept","text":""},{"location":"evm/#evm","title":"EVM","text":"<p>The Ethereum Virtual Machine (EVM) is a computing engine that can be thought of as a single entity maintained by thousands of connected computers (nodes) running Ethereum clients. As a virtual machine (VM), the EVM is responsible for computing state changes deterministically, regardless of its environment (hardware and operating system). This means that given the same starting state and transaction (tx), each node must achieve the exact same result.</p> <p>The EVM is considered part of the Ethereum protocol that handles deployment and execution of smart contracts.</p> <p>To clearly distinguish between:</p> <ul> <li>The Ethereum protocol describes a blockchain in which all Ethereum accounts and smart contracts exist.   It has only one canonical state (a data structure that holds all accounts) in any given block in the chain.</li> <li>However, the EVM is a state machine, which defines the rules for computing a new valid state from one block to another.   It is an isolated runtime, which means that code running inside the EVM cannot access the network, file system, or other processes (not external APIs).</li> </ul> <p>The <code>x/evm</code> module implements the EVM as a Cosmos SDK module. It allows users to interact with the EVM by submitting Ethereum transactions and executing the contained messages on a given state to induce state transitions.</p>"},{"location":"evm/#state","title":"state","text":"<p>The Ethereum state is a data structure, implemented as a Merkle Patricia Tree, that keeps all accounts on-chain. The EVM makes changes to this data structure, resulting in a new state with a different state root. Therefore, Ethereum can be viewed as a state chain that transitions from one state to another by executing transactions in blocks using the EVM. A new txs block can be described by its block header (parent hash, block number, timestamp, nonce, receipt...).</p>"},{"location":"evm/#account","title":"account","text":"<p>There are two types of accounts that can be stored in the state for a given address:</p> <ul> <li>Externally Owned Account (EOA): Has nonce (tx counter) and balance</li> <li>Smart Contract: with nonce, balance, (immutable) code hash, storage root (another Merkle Patricia Trie)</li> </ul> <p>A smart contract is like a regular account on the blockchain, it also stores executable code in an Ethereum-specific binary format called EVM bytecode. They are usually written in an Ethereum high-level language, such as Solidity, which is compiled to EVM bytecode and deployed on the blockchain by submitting transactions using the Ethereum client.</p>"},{"location":"evm/#structure","title":"structure","text":"<p>The EVM operates as a stack-based machine. Its main architectural components include:</p> <ul> <li>Virtual ROM: Contract code is pulled into this read-only memory when processing txs</li> <li>Machine state (volatile): changes as the EVM runs and is cleared after processing each tx<ul> <li>Program counter (PC)</li> <li>Gas\u200b\u200b: track how much gas is used<ul> <li>stack and memory: computing state changes</li> </ul> </li> </ul> </li> <li>Access account storage (persistent)</li> </ul>"},{"location":"evm/#state-transition-of-smart-contract","title":"State transition of smart contract","text":"<p>Typically, smart contracts expose a public ABI, which is a list of supported ways users can interact with the contract. To interact with a contract and invoke a state transition, a user submits a transaction carrying an arbitrary amount of gas and a data payload formatted according to the ABI, specifying the interaction type and any other parameters. When a tx is received, the EVM executes the EVM bytecode of the smart contract using the tx payload.</p>"},{"location":"evm/#execute-evm-bytecode","title":"Execute EVM bytecode","text":"<p>A contract's EVM bytecode consists of basic operations (addition, multiplication, store, etc.), called opcodes. Each Opcode execution requires gas paid for in tx. Therefore, the EVM is considered quasi-Turing-complete because it allows arbitrary computations, but the amount of computation during contract execution is limited to the amount of gas provided in tx.</p> <p>The gas cost of each opcode reflects the cost of running these operations on actual computer hardware (e.g. <code>ADD = 3gas</code> and <code>SSTORE = 100gas</code> `). To calculate the gas consumption of a transaction, multiply the gas cost by the gas price, which may vary based on the demand of the network at the time. If the network is heavily loaded, you may need to pay a higher gas price to execute your transaction. If the gas limit is reached (gas exception), no changes will be made to the Ethereum state unless the sender's nonce increases and their balance decreases to pay for wasting EVM time.</p> <p>Smart contracts can also call other smart contracts. Every call to a new contract creates a new EVM instance (including new stack and memory). Each invocation passes the sandbox state to the next EVM. If the gas runs out, all state changes will be discarded. Otherwise, they will be preserved.</p> <p>For further reading, see:</p> <ul> <li>EVM</li> <li>EVM Architecture</li> <li>What is Ethereum</li> <li>Opcodes</li> </ul>"},{"location":"evm/#daodst-implemented-as-geth","title":"Daodst implemented as Geth","text":"<p>Daodst includes an implementation of the Ethereum Protocol in Golang (Geth) as a Cosmos SDK module. Geth includes an implementation of the EVM to compute state transitions. Check out the go-ethereum source code to see how the EVM opcodes are implemented. Just as Geth can run as an Ethereum node, Daodst can also run as a node to compute state transitions of the EVM. Daodst supports Geth's standard for compatibility with Web3 and EVM.</p>"},{"location":"evm/#json-rpc","title":"JSON-RPC","text":"<p>JSON-RPC is a stateless, lightweight remote procedure call (RPC) protocol. The specification mainly defines several data structures and their processing rules. It's transport-agnostic, as the concepts can be used in the same process, over sockets, over HTTP, or in many different messaging environments. It uses JSON (RFC 4627) as the data format.</p> <p>** JSON-RPC example: <code>eth_call</code> **</p> <p>The JSON-RPC method allows you to execute messages against contracts. Typically, you need to send a transaction to a Geth node to include it in the mempool, then the nodes propagate to each other, and eventually the transaction is included in a block and executed. However, <code>eth_call</code> allows you to send data to a contract and see what happens without committing the transaction.</p> <p>In the Geth implementation, the call endpoint roughly goes through the following steps:</p> <ol> <li>The <code>eth_call</code> request is converted to call the <code>func (s *PublicBlockchainAPI) Call()</code> function using the <code>eth</code> namespace</li> <li><code>Call()</code> is given the transaction parameters, the block to call and an optional Parameters to modify the state to call.    Then it calls <code>DoCall()</code>.</li> <li><code>DoCall()</code>    Convert arguments to <code>ethtypes.message</code>, instantiate the EVM and apply the message using <code>core.ApplyMessage</code></li> <li><code>ApplyMessage()</code>    Call state transition <code>TransitionDb()</code></li> <li><code>TransitionDb()</code> <code>Create()</code> is a new contract or <code>Call()</code> is a contract</li> <li><code>evm.Call()</code>    Run the interpreter evm.interpreter.Run() to execute the message.    If the execution fails, the state will revert to the snapshot taken before execution and consume gas.</li> <li><code>Run()</code>    Execute a loop to execute opcodes.</li> </ol>"},{"location":"evm/#status-db","title":"Status DB","text":"<p>The <code>StateDB</code> interface from go-ethereum represents the EVM database for full state queries. EVM state transitions are enabled by this interface, implemented by <code>Keeper</code> in the <code>x/evm</code> module. The implementation of this interface makes Daodst EVM compatible.</p>"},{"location":"evm/#consensus-engine","title":"Consensus Engine","text":"<p>Applications using the <code>x/evm</code> module interact with the Tendermint core consensus engine through the Application Blockchain Interface (ABCI). Together, the application and Tendermint Core form a program that runs a full blockchain and combines business logic with decentralized data storage.</p> <p>Ethereum transactions submitted to the <code>x/evm</code> module participate in this consensus process before executing and changing application state. We encourage understanding the basics of the Tendermint consensus engine in order to understand state transitions in detail.</p>"},{"location":"evm/#transaction-record","title":"Transaction Record","text":"<p>In each <code>x/evm</code> transaction, the result contains the Ethereum <code>log</code> from the state machine execution, which is used by the JSON-RPC Web3 server for filter queries and processing EVM hooks.</p> <p>The tx log is stored in temporary storage during tx execution and then emitted via cosmos events after the transaction. They can be queried via gRPC and JSON-RPC.</p>"},{"location":"evm/#block-bloom","title":"Block Bloom","text":"<p>bloom is the bloom filter value (in bytes) per block available for filter queries. Block bloom values are stored in transient storage and then emitted via cosmos events during EndBlock processing. They can be queried via gRPC and JSON-RPC.</p> <p>:::hint</p> <p>\ud83d\udc49 NOTE: Since they are not stored in state, transaction logs and block blooms are not persisted after upgrades. Users must use an archive node after upgrading to get legacy chain events. :::</p>"},{"location":"evm/#state_1","title":"state","text":"<p>This section provides an overview of objects stored in the state of the <code>x/evm</code> module, functionality derived from the go-ethereum <code>StateDB</code> interface, and its implementation via Keeper and state implementation at genesis.</p>"},{"location":"evm/#state-object","title":"State object","text":"<p>The <code>x/evm</code> module maintains objects in the following states:</p>"},{"location":"evm/#state_2","title":"state","text":"Description Key Value Store Code Smart contract bytecode <code>[]byte{1} + []byte(address)</code> <code>[]byte{code}</code> KV Storage Smart contract storage <code>[]byte{2} + [32]byte{key}</code> <code>[32]byte(value)</code> KV Block Bloom Block bloom filter, used to accumulate the bloom filter of the current block and send to the end blocker event. <code>[]byte{1} + []byte(tx.Hash)</code> <code>protobuf([]Log)</code> Transient Tx Index The index of the current transaction in the current block. <code>[]byte{2}</code> <code>BigEndian(uint64)</code> Transient Log Size The number of logs emitted so far in the current block. Log index used to determine subsequent logs. <code>[]byte{3}</code> <code>BigEndian(uint64)</code> Transient Gas Used The amount of gas used by the ethereum message of the current cosmos-sdk tx, which is required when the cosmos-sdk tx contains multiple ethereum messages. <code>[]byte{4}</code> <code>BigEndian(uint64)</code> Transient"},{"location":"evm/#status-db_1","title":"Status DB","text":"<p>The <code>StateDB</code> interface is implemented by <code>StateDB</code> in the <code>x/evm/statedb</code> module, which represents an EVM database for complete state queries of contracts and accounts. In the Ethereum protocol, <code>StateDB</code> is used to store anything in the IAVL tree and is responsible for caching and storing nested states.</p> <pre><code>// github.com/ethereum/go-ethereum/core/vm/interface.go\ntype StateDB interface {\n CreateAccount(common.Address)\n\n SubBalance(common.Address, *big.Int)\n AddBalance(common.Address, *big.Int)\n GetBalance(common.Address) *big.Int\n\n GetNonce(common.Address) uint64\n SetNonce(common.Address, uint64)\n\n GetCodeHash(common.Address) common.Hash\n GetCode(common.Address) []byte\n SetCode(common.Address, []byte)\n GetCodeSize(common.Address) int\n\n AddRefund(uint64)\n SubRefund(uint64)\n GetRefund() uint64\n\n GetCommittedState(common.Address, common.Hash) common.Hash\n GetState(common.Address, common.Hash) common.Hash\n SetState(common.Address, common.Hash, common.Hash)\n\n Suicide(common.Address) bool\n HasSuicided(common.Address) bool\n\n // Exist reports whether the given account exists in state.\n // Notably this should also return true for suicided accounts.\n Exist(common.Address) bool\n // Empty returns whether the given account is empty. Empty\n // is defined according to EIP161 (balance = nonce = code = 0).\n Empty(common.Address) bool\n\n PrepareAccessList(sender common.Address, dest *common.Address, precompiles []common.Address, txAccesses types.AccessList)\n AddressInAccessList(addr common.Address) bool\n SlotInAccessList(addr common.Address, slot common.Hash) (addressOk bool, slotOk bool)\n // AddAddressToAccessList adds the given address to the access list. This operation is safe to perform\n // even if the feature/fork is not active yet\n AddAddressToAccessList(addr common.Address)\n // AddSlotToAccessList adds the given (address,slot) to the access list. This operation is safe to perform\n // even if the feature/fork is not active yet\n AddSlotToAccessList(addr common.Address, slot common.Hash)\n\n RevertToSnapshot(int)\n Snapshot() int\n\n AddLog(*types.Log)\n AddPreimage(common.Hash, []byte)\n\n ForEachStorage(common.Address, func(common.Hash, common.Hash) bool) error\n}\n</code></pre> <p>The <code>StateDB</code> in the <code>x/evm</code> provides the following functionalities:</p>"},{"location":"evm/#crud-for-ethereum-accounts","title":"CRUD for Ethereum accounts","text":"<p>You can create an <code>EthAccount</code> instance from a provided address and use <code>createAccount()</code> to set the value to be stored on the <code>AccountKeeper</code>. If an account with the given address already exists, this function also resets any pre-existing code and storage associated with that address.</p> <p>An account's currency balance can be managed through <code>BankKeeper</code>, which can be read using <code>GetBalance()</code> and updated using <code>AddBalance()</code> and <code>SubBalance()</code>.</p> <ul> <li><code>GetBalance()</code> returns the EVM currency balance of the provided address.   The currency name is taken from the module parameters.</li> <li><code>AddBalance()</code> adds the given amount to the address currency balance by minting new currency and transferring it to the address.   The currency name is taken from the module parameters.</li> <li><code>SubBalance()</code> subtracts the given amount from the address balance by transferring currency to escrow accounts and then destroying them.   The currency name is taken from the module parameters.   This function will perform a no-op if the amount is negative or the user does not have enough funds to transfer.</li> </ul> <p>The nonce (or transaction sequence) can be obtained from the account <code>Sequence</code> by the authentication module <code>AccountKeeper</code>.</p> <ul> <li><code>GetNonce()</code> retrieves the account with the given address and returns the tx sequence (i.e. the nonce).   If the account cannot be found, the function will perform a no-op.</li> <li><code>SetNonce()</code> sets the given nonce as sequence of address accounts.   If the account does not exist, a new account will be created from this address.</li> </ul> <p>Smart contract bytecode containing arbitrary contract logic is stored on <code>EVMKeeper</code> and can be queried using <code>GetCodeHash()</code>, <code>GetCode()</code> and <code>GetCodeSize()</code>, and updated using <code>SetCode()</code>.</p> <ul> <li><code>GetCodeHash()</code> gets an account from storage and returns its code hash.   Returns an empty code hash if the account does not exist or is not of type EthAccount.</li> <li><code>GetCode()</code> returns the code byte array associated with the given address.   This function returns nil if the code hash from the account is empty.</li> <li><code>SetCode()</code> stores the code byte array to the application KVStore and sets the code hash to the given account.   If the code is empty, it will be removed from storage.</li> <li><code>GetCodeSize()</code> returns the size of the contract code associated with this object, or zero if none.</li> </ul> <p>The refunded gas needs to be tracked and stored in a separate variable so that it can be subtracted/added to the gas usage value after the EVM execution is complete. The refund value is cleared at the end of each transaction and each block.</p> <ul> <li><code>AddRefund()</code> adds the given amount of gas to the refund value in memory.</li> <li><code>SubRefund()</code> subtracts the given amount of gas from the refund value in memory.   This function will panic if the gas amount is greater than the current refund.</li> <li><code>GetRefund()</code> returns the amount of gas available for return after tx execution completes.   The value resets to 0 on every transaction.</li> </ul> <p>State is stored on <code>EVMKeeper</code>. Can be queried with <code>GetCommittedState()</code>, <code>GetState()</code> and updated with <code>SetState()</code>.</p> <ul> <li><code>GetCommittedState()</code> returns the value set in storage for the given key hash.   If the key is not registered, this function returns an empty hash.</li> <li><code>GetState()</code> returns the in-memory dirty state for the given key hash,   If not present, the submitted value is loaded from the KVStore.</li> <li><code>SetState()</code> sets the given hash (key, value) as state.   This function removes the key from the state if the value hash is empty,   The new value is first kept dirty and finally committed to KVStore.</li> </ul> <p>Accounts can also be set to commit suicide. When the contract commits suicide, the account is marked as suicide, and when the code is committed, the storage and account are deleted (starting from the next block).</p> <ul> <li><code>Suicide()</code> marks the given account as having committed suicide and clears the account balance in EVM tokens.</li> <li><code>HasSuicided()</code> queries the flags in memory to check if the account has been marked as suicidal in the current transaction.   Suicided accounts will return non-zero during queries and be \"cleared\" after the block is committed.</li> </ul> <p>To check if an account exists, use <code>Exist()</code> and <code>Empty()</code>.</p> <ul> <li><code>Exist()</code> returns true if the given account exists in storage or has been marked as suicidal.</li> <li><code>Empty()</code> returns true if the address satisfies the following conditions:<ul> <li>nonce is 0</li> <li>Balance of evm currency is 0</li> <li>account code hash is empty</li> </ul> </li> </ul>"},{"location":"evm/#eip2930-functionality","title":"EIP2930 functionality","text":"<p>Supports transaction types that contain an access list, addresses and storage key lists that the transaction plans to access. Access list state is kept in memory and discarded after transaction commit.</p> <ul> <li><code>PrepareAccessList()</code> handles the preparation steps for performing state transitions on EIP-2929 and EIP-2930.   This method should only be called if Yolov3/Berlin/2929+2930 applies to the current number.<ul> <li>Add sender to access list (EIP-2929)</li> <li>Add destination to access list (EIP-2929)</li> <li>Add precompile to access list (EIP-2929)</li> <li>Add optional tx access list content (EIP-2930)</li> </ul> </li> <li><code>AddressInAccessList()</code> returns true if the address is registered.</li> <li><code>SlotInAccessList()</code> checks if address and slot are registered.</li> <li><code>AddAddressToAccessList()</code> adds the given address to the access list.   If the address is already in the access list, this function performs a no-op.</li> <li><code>AddSlotToAccessList()</code> adds the given (address, slot) to the access list.   This function performs a no-op if the address and slot are already in the access list.</li> </ul>"},{"location":"evm/#snapshot-state-and-restore-functions","title":"Snapshot state and restore functions","text":"<p>The EVM uses state restoration exceptions to handle errors. Such an exception will undo all changes made to the state in the current call (and all its sub-calls), and the caller can handle the error and not propagate. You can use <code>Snapshot()</code> to identify the current state by revision, and <code>RevertToSnapshot()</code> to revert the state to a given revision to support this feature. - <code>Snapshot()</code> creates a new snapshot and returns the identifier. - <code>RevertToSnapshot(rev)</code> undoes all modifications up to the snapshot identified by <code>rev</code>.</p> <p>Daodst adapted the to support this, it uses a journal list in order to record For all the state modification operations done so far, the snapshot consists of a unique id and index in the log list, to revert to a snapshot it just undoes the log logs after the snapshot index in reverse order.</p>"},{"location":"evm/#ethereum-transaction-log","title":"Ethereum transaction log","text":"<p>With <code>AddLog()</code>, you can append a given Ethereum <code>Log</code> to the list of logs associated with the transaction hash saved in the current state. The function also fills in the tx hash, block hash, tx index and log index fields before setting the log to be stored.</p>"},{"location":"evm/#keeper","title":"Keeper","text":"<p>The EVM module <code>Keeper</code> grants access to the state of the EVM module and implements the <code>statedb.Keeper</code> interface to support <code>StateDB</code> implementations. The Keeper contains a storage key that allows the DB to write to a concrete subtree of the multistore that can only be accessed by the EVM module. Instead of using trie and database for query and persistence (<code>StateDB</code> implementation), Daodst uses Cosmos' KVStore (key-value store) and Cosmos SDK's <code>Keeper</code> to facilitate state transitions.</p> <p>To support interface functionality, it imports 4 modules Keepers:</p> <ul> <li><code>auth</code>: CRUD account</li> <li><code>bank</code>: CRUD for accounting (supply) and balances</li> <li><code>staking</code>: query historical headers</li> <li><code>fee market</code>: handle EIP1559 base fee for <code>DynamicFeeTx</code>   After activating the <code>London</code> hard fork on the <code>ChainConfig</code> parameter</li> </ul> <pre><code>type Keeper struct {\n // Protobuf codec\n cdc codec.BinaryCodec\n // Store key required for the EVM Prefix KVStore. It is required by:\n // - storing account's Storage State\n // - storing account's Code\n // - storing Bloom filters by block height. Needed for the Web3 API.\n // For the full list, check the module specification\n storeKey sdk.StoreKey\n\n // key to access the transient store, which is reset on every block during Commit\n transientKey sdk.StoreKey\n\n // module specific parameter space that can be configured through governance\n paramSpace paramtypes.Subspace\n // access to account state\n accountKeeper types.AccountKeeper\n // update balance and accounting operations with coins\n bankKeeper types.BankKeeper\n // access historical headers for EVM state transition execution\n stakingKeeper types.StakingKeeper\n // fetch EIP1559 base fee and parameters\n feeMarketKeeper types.FeeMarketKeeper\n\n // chain ID number obtained from the context's chain id\n eip155ChainID *big.Int\n\n // Tracer used to collect execution traces from the EVM transaction execution\n tracer string\n // trace EVM state transition execution. This value is obtained from the `--trace` flag.\n // For more info check https://geth.ethereum.org/docs/dapp/tracing\n debug bool\n\n // EVM Hooks for tx post-processing\n hooks types.EvmHooks\n}\n</code></pre>"},{"location":"evm/#genesis-state","title":"Genesis state","text":"<p>The <code>x/evm</code> module <code>GenesisState</code> defines the state required to initialize a chain from a previously exported height. It contains <code>GenesisAccounts</code> and module parameters</p> <pre><code>type GenesisState struct {\n   // accounts is an array containing the ethereum genesis accounts.\n   Accounts []GenesisAccount `protobuf:\"bytes,1,rep,name=accounts,proto3\" json:\"accounts\"`\n   // params defines all the parameters of the module.\n   Params Params `protobuf:\"bytes,2,opt,name=params,proto3\" json:\"params\"`\n}\n</code></pre>"},{"location":"evm/#genesis-account","title":"Genesis account","text":"<p>The <code>GenesisAccount</code> type corresponds to an adaptation of the Ethereum <code>GenesisAccount</code> type. It defines an account that is initialized in the genesis state.</p> <p>Its main difference is that the one on Daodst uses a custom <code>Storage</code> type that uses slices instead of evm <code>State</code>'s map (due to non-determinism), and it does not contain a private key field.</p> <p>It is also important to note that since the <code>auth</code> module on the Cosmos SDK manages account state, the <code>Address</code> field must correspond to an existing <code>EthAccount</code> (i.e. <code>AccountKeeper</code>) stored in the <code>auth</code> module <code>Keeper</code>.</p> <p>The address uses EIP55 hexadecimal[format] on <code>genesis.json</code>.</p> <pre><code>type GenesisAccount struct {\n   // address defines an ethereum hex formatted address of an account\n   Address string `protobuf:\"bytes,1,opt,name=address,proto3\" json:\"address,omitempty\"`\n   // code defines the hex bytes of the account code.\n   Code string `protobuf:\"bytes,2,opt,name=code,proto3\" json:\"code,omitempty\"`\n   // storage defines the set of state key values for the account.\n   Storage Storage `protobuf:\"bytes,3,rep,name=storage,proto3,castrepeated=Storage\" json:\"storage\"`\n}\n</code></pre>"},{"location":"evm/#state-transition","title":"state transition","text":"<p>The <code>x/evm</code> module allows users to submit Ethereum transactions (<code>Tx</code>) and execute the messages they contain to induce a state transition on a given state.</p> <p>Users submit transactions on the client side to broadcast them to the network. When a transaction is included in a block during the consensus process, it is executed server-side. We strongly recommend that you learn the basics of the Tendermint consensus engine to learn more about state transitions.</p>"},{"location":"evm/#client","title":"client","text":"<p>:::hint \ud83d\udc49 This is based on <code>eth_sendTransaction</code> JSON-RPC :::</p> <ol> <li> <p>A user submits a transaction via one of the available JSON-RPC endpoints using an Ethereum-compatible client or wallet (e.g. Metamask, WalletConnect, Ledger, etc.):</p> <ul> <li>eth (public) namespace: <code>eth_sendTransaction</code> and <code>eth_sendRawTransaction</code></li> <li>Personal (private) namespace: <code>personal_sendTransaction</code></li> </ul> </li> <li> <p>Create a MsgEthereumTx instance after filling the RPC transaction with SetTxDefaults to fill the missing tx parameter with default values</p> </li> <li>Use ValidateBasic() to validate the <code>Tx</code> field (stateless)</li> <li><code>Tx</code> is signed using the key associated with the sender address and the latest Ethereum hard fork (<code>London</code>, <code>Berlin</code>, etc.) from <code>ChainConfig</code></li> <li><code>Tx</code> is constructed from the msg field using the Cosmos Config builder</li> <li><code>Tx</code> in synchronous mode broadcasting    Make sure to wait for the <code>CheckTx</code> execution response.    The application verifies the transaction using <code>CheckTx()</code> before adding to the consensus engine's mempool.</li> <li>The JSON-RPC user receives a response with the <code>RLP</code> hash of the transaction field.    This hash is different from the default hash used by SDK transactions, which computes a <code>sha256</code> hash of the transaction bytes.</li> </ol>"},{"location":"evm/#server","title":"Server","text":"<p>Once a block (containing \"Tx\") is committed during consensus, it is applied to the application in a series of ABCI messages on the server side.</p> <p>Each <code>Tx</code> is handled by the application by calling <code>RunTx</code>. After stateless verification of each <code>sdk.Msg</code> in <code>Tx</code>, <code>AnteHandler</code> confirms whether <code>Tx</code> is an Ethereum transaction or an SDK transaction. As an Ethereum transaction, it contains messages, which are then processed by the <code>x/evm</code> module to update the state of the application.</p>"},{"location":"evm/#preprocessor","title":"Preprocessor","text":"<p><code>anteHandler</code> runs for every transaction. It checks whether <code>Tx</code> is an Ethereum transaction and routes it to the internal ante handler. Here, <code>Tx</code> is handled using EthereumTx extension options to handle them differently than normal Cosmos SDK transactions. <code>antehandler</code> runs through a list of options and its <code>AnteHandle</code> function for each <code>Tx</code>:</p> <ul> <li><code>EthSetUpContextDecorator()</code> adapted from cosmos-sdk's SetUpContextDecorator which ignores gas consumption by setting the gas meter to infinite</li> <li><code>EthValidateBasicDecorator(evmKeeper)</code> validates fields of Ethereum type Cosmos <code>Tx</code> messages</li> <li><code>EthSigVerificationDecorator(evmKeeper)</code> verifies that the registered chain ID is the same as on the message, and that the signer address matches that defined on the message.   RecheckTx won't skip it because it sets the <code>From</code> address, which is essential for other ante handlers to work.   A failure of RecheckTx will prevent the tx from being included into the block, especially when CheckTx is successful, in which case the user will not see the error message.<ul> <li><code>EthAccountVerificationDecorator(ak, bankKeeper, evmKeeper)</code>   Will verify that the sender balance is greater than the total transaction cost.   If the account does not exist, i.e. cannot be found in the store, the account will be set into the store.   This AnteHandler decorator will fail if:<ul> <li>Any message is not MsgEthereumTx</li> <li>sender address is empty</li> <li>The account balance is lower than the transaction cost</li> </ul> </li> </ul> </li> <li><code>EthNonceVerificationDecorator(ak)</code> verifies that the transaction nonce is valid and equal to the sender account's current nonce.</li> <li><code>EthGasConsumeDecorator(evmKeeper)</code> verifies that the Ethereum tx message is sufficient to pay for inherent gas (during CheckTx only) and that the sender has enough balance to cover the gas cost.   The intrinsic gas of a transaction is the amount of gas used by the transaction before execution.   Gas is a constant value plus any cost incurred by the extra data bytes provided by the transaction.   This AnteHandler decorator will fail if:<ul> <li>Transaction contains multiple messages</li> <li>Message is not MsgEthereumTx</li> <li>No sender account found</li> <li>the gas limit of the transaction is lower than the intrinsic gas</li> <li>User does not have enough balance to deduct transaction fee (gas_limit * gas_price)</li> <li>Transaction or block gas meter runs out of gas</li> </ul> </li> <li><code>CanTransferDecorator(evmKeeper, feeMarketKeeper)</code> creates an EVM from the message and calls the BlockContext CanTransfer function to see if the address can perform a transaction.</li> <li><code>EthIncrementSenderSequenceDecorator(ak)</code> handles the sequence of incrementing signers (i.e. senders).   If the transaction is a contract creation, the nonce will be incremented during transaction execution, not within this AnteHandler decorator.</li> </ul> <p>The options <code>authante.NewMempoolFeeDecorator()</code>, <code>authante.NewTxTimeoutHeightDecorator()</code> and <code>authante.NewValidateMemoDecorator(ak)</code> are the same as Cosmos <code>Tx</code>. Click here to learn more about <code>anteHandler</code>.</p>"},{"location":"evm/#evm-module","title":"EVM module","text":"<p>Each <code>sdk.Msg</code> in <code>Tx</code> (in this case <code>MsgEthereumTx</code>) after being authenticated by <code>antehandler</code> Passed to the Msg Handler in the <code>x/evm</code> module and run through the following steps:</p> <ol> <li>Convert <code>Msg</code> to Ethereum's <code>Tx</code> type</li> <li>Apply <code>Tx</code> with <code>EVMConfig</code> and attempt to perform a state transition, only persisting (committing) to the underlying KVStore if the transaction has not failed:<ol> <li>Confirm that <code>EVMConfig</code> is created</li> <li>Create an Ethereum signer using the chain configuration values from \"EVMConfig\"</li> <li>Set the Ethereum transaction hash to (temporary) temporary storage so that it can also be used for StateDB functions<ol> <li>Generate a new EVM instance</li> </ol> </li> <li>Verify that the EVM parameters for contract creation (<code>EnableCreate</code>) and contract execution (<code>EnableCall</code>) are enabled<ol> <li>App message. If the <code>To</code> address is <code>nil</code>, create a new contract with the code as the deployed code. Else invokes the contract at the given address with the given input as arguments</li> <li>Calculate the gas used by the evm operation</li> </ol> </li> </ol> </li> <li>If the <code>Tx</code> application is successful<ol> <li>Execute the EVM <code>Tx</code> post-processing hook. If the hook returns an error, restore the entire \"Tx\"<ol> <li>Return gas according to the Ethereum gas bookkeeping rules</li> </ol> </li> <li>Update block bloom filter value with log generated from tx</li> <li>Emit SDK events for transaction fields and tx logs</li> </ol> </li> </ol>"},{"location":"evm/#trade","title":"trade","text":"<p>This section defines the <code>sdk.Msg</code> concrete types that cause the state transitions defined in the previous section.</p>"},{"location":"evm/#msgethereumtx","title":"<code>MsgEthereumTx</code>","text":"<p>EVM state transitions can be achieved by using \"MsgEthereumTx\". This message encapsulates the Ethereum transaction data (<code>TxData</code>) as <code>sdk.Msg</code>. It contains the necessary transaction data fields. Note that <code>MsgEthereumTx</code> implements <code>sdk.Msg</code> and <code>sdk .Tx</code> interface. Typically, SDK messages only implement the former, while the latter is a set of messages bundled together.</p> <p>This section defines the <code>sdk.Msg</code> concrete types that cause the state transitions defined in the previous section.</p>"},{"location":"evm/#msgethereumtx_1","title":"<code>MsgEthereumTx</code>","text":"<p>EVM state transitions can be achieved using <code>MsgEthereumTx</code>. This message encapsulates the Ethereum transaction data (<code>TxData</code>) as <code>sdk.Msg</code>. It contains the necessary transaction data fields. Note that <code>MsgEthereumTx</code> implements <code>sdk.Msg</code> and <code>sdk .Tx</code> interface.</p> <p>Typically, SDK messages only implement the former, while the latter is a set of messages bundled together.</p> <pre><code>type MsgEthereumTx struct {\n // inner transaction data\n Data *types.Any `protobuf:\"bytes,1,opt,name=data,proto3\" json:\"data,omitempty\"`\n // DEPRECATED: encoded storage size of the transaction\n Size_ float64 `protobuf:\"fixed64,2,opt,name=size,proto3\" json:\"-\"`\n // transaction hash in hex format\n Hash string `protobuf:\"bytes,3,opt,name=hash,proto3\" json:\"hash,omitempty\" rlp:\"-\"`\n // ethereum signer address in hex format. This address value is checked\n // against the address derived from the signature (V, R, S) using the\n // secp256k1 elliptic curve\n From string `protobuf:\"bytes,4,opt,name=from,proto3\" json:\"from,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li>The <code>From</code> field is defined and the address is invalid</li> <li><code>TxData</code> stateless validation failed</li> </ul> <p>Transaction execution is expected to fail if:</p> <ul> <li>Any custom <code>AnteHandler</code> ethereum decorator check fails:<ul> <li>Minimum gas requirement for transactions</li> <li>Tx sender account does not exist or does not have sufficient fee balance</li> <li>account sequence does not match transaction <code>Data.AccountNonce</code></li> <li>message signature verification failed</li> </ul> </li> <li>EVM contract creation (i.e. <code>evm.Create</code>) failed, or <code>evm.Call</code> failed</li> </ul>"},{"location":"evm/#conversion","title":"Conversion","text":"<p><code>MsgEthreumTx</code> can be converted to go-ethereum <code>Transaction</code> and <code>Message</code> types In order to create and call evm contracts.</p> <pre><code>// AsTransaction creates an Ethereum Transaction type from the msg fields\nfunc (msg MsgEthereumTx) AsTransaction() *ethtypes.Transaction {\n  txData, err := UnpackTxData(msg.Data)\n  if err != nil {\n   return nil\n  }\n\n  return ethtypes. NewTx(txData. AsEthereumData())\n}\n\n// AsMessage returns the transaction as a core.Message.\nfunc (tx *Transaction) AsMessage(s Signer, baseFee *big.Int) (Message, error) {\n  msg := Message{\n   nonce: tx.Nonce(),\n   gasLimit: tx. Gas(),\n   gasPrice: new(big.Int).Set(tx.GasPrice()),\n   gasFeeCap: new(big.Int).Set(tx.GasFeeCap()),\n   gasTipCap: new(big.Int).Set(tx.GasTipCap()),\n   to: tx.To(),\n   amount: tx. Value(),\n   data: tx.Data(),\n   accessList: tx.AccessList(),\n   isFake: false,\n  }\n  // If baseFee provided, set gasPrice to effectiveGasPrice.\n  if baseFee != nil {\n   msg.gasPrice = math.BigMin(msg.gasPrice.Add(msg.gasTipCap, baseFee), msg.gasFeeCap)\n  }\n  var err error\n  msg.from, err = Sender(s, tx)\n  return msg, err\n}\n</code></pre>"},{"location":"evm/#sign","title":"sign","text":"<p>For signature verification to work, <code>TxData</code> must contain the <code>v|r|s</code> value from <code>Signer</code>. Sign computes the secp256k1 ECDSA signature and signs the transaction. According to the EIP155 standard, it requires a keyring signer and chainID to sign Ethereum transactions. This method mutates the transaction when filling the V, R, S fields of the transaction signature. The function will fail if no sender address is defined for the message or if the sender is not registered on the keyring.</p> <pre><code>// Sign calculates a secp256k1 ECDSA signature and signs the transaction. It\n// takes a keyring signer and the chainID to sign an Ethereum transaction according to\n// EIP155 standard.\n// This method mutates the transaction as it populates the V, R, S\n// fields of the Transaction's Signature.\n// The function will fail if the sender address is not defined for the msg or if\n// the sender is not registered on the keyring\nfunc (msg *MsgEthereumTx) Sign(ethSigner ethtypes.Signer, keyringSigner keyring.Signer) error {\n from := msg.GetFrom()\n if from.Empty() {\n  return fmt.Errorf(\"sender address not defined for message\")\n }\n\n tx := msg.AsTransaction()\n txHash := ethSigner.Hash(tx)\n\n sig, _, err := keyringSigner.SignByAddress(from, txHash.Bytes())\n if err != nil {\n  return err\n }\n\n tx, err = tx.WithSignature(ethSigner, sig)\n if err != nil {\n  return err\n }\n\n msg.FromEthereumTx(tx)\n return nil\n}\n</code></pre>"},{"location":"evm/#txdata","title":"TxData","text":"<p><code>MsgEthereumTx</code> supports 3 valid Ethereum transaction data types from go-ethereum: <code>LegacyTx</code>, <code>AccessListTx</code>, and <code>DynamicFeeTx</code>. These types are defined as protobuf messages and packed into the <code>proto.Any</code> interface type in the <code>MsgEthereumTx</code> field.</p> <ul> <li><code>LegacyTx</code>: EIP-155 transaction type</li> <li><code>DynamicFeeTx</code>: EIP-1559 transaction type.</li> <li><code>AccessListTx</code>: EIP-2930 transaction type.</li> </ul>"},{"location":"evm/#legacytx","title":"<code>LegacyTx</code>","text":"<p>Transaction data for regular Ethereum transactions.</p> <pre><code>type LegacyTx struct {\n // nonce corresponds to the account nonce (transaction sequence).\n Nonce uint64 `protobuf:\"varint,1,opt,name=nonce,proto3\" json:\"nonce,omitempty\"`\n // gas price defines the value for each gas unit\n GasPrice *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,2,opt,name=gas_price,json=gasPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_price,omitempty\"`\n // gas defines the gas limit defined for the transaction.\n GasLimit uint64 `protobuf:\"varint,3,opt,name=gas,proto3\" json:\"gas,omitempty\"`\n // hex formatted address of the recipient\n To string `protobuf:\"bytes,4,opt,name=to,proto3\" json:\"to,omitempty\"`\n // value defines the unsigned integer value of the transaction amount.\n Amount *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,5,opt,name=value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"value,omitempty\"`\n // input defines the data payload bytes of the transaction.\n Data []byte `protobuf:\"bytes,6,opt,name=data,proto3\" json:\"data,omitempty\"`\n // v defines the signature value\n V []byte `protobuf:\"bytes,7,opt,name=v,proto3\" json:\"v,omitempty\"`\n // r defines the signature value\n R []byte `protobuf:\"bytes,8,opt,name=r,proto3\" json:\"r,omitempty\"`\n // s define the signature value\n S []byte `protobuf:\"bytes,9,opt,name=s,proto3\" json:\"s,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li><code>GasPrice</code> is invalid (<code>nil</code>, negative or out of range of int256)</li> <li><code>Fee</code> (gasprice * gaslimit) is invalid</li> <li><code>Amount</code> is invalid (negative or out of range of int256)</li> <li>Invalid <code>To</code> address (invalid Ethereum hex address)</li> </ul>"},{"location":"evm/#dynamicfeetx","title":"<code>DynamicFeeTx</code>","text":"<p>Transaction data for EIP-1559 dynamic fee transactions.</p> <pre><code>type DynamicFeeTx struct {\n // destination EVM chain ID\n ChainID *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,1,opt,name=chain_id,json=chainId,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"chainID\"`\n // nonce corresponds to the account nonce (transaction sequence).\n Nonce uint64 `protobuf:\"varint,2,opt,name=nonce,proto3\" json:\"nonce,omitempty\"`\n // gas tip cap defines the max value for the gas tip\n GasTipCap *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,3,opt,name=gas_tip_cap,json=gasTipCap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_tip_cap,omitempty\"`\n // gas fee cap defines the max value for the gas fee\n GasFeeCap *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,4,opt,name=gas_fee_cap,json=gasFeeCap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_fee_cap,omitempty\"`\n // gas defines the gas limit defined for the transaction.\n GasLimit uint64 `protobuf:\"varint,5,opt,name=gas,proto3\" json:\"gas,omitempty\"`\n // hex formatted address of the recipient\n To string `protobuf:\"bytes,6,opt,name=to,proto3\" json:\"to,omitempty\"`\n // value defines the the transaction amount.\n Amount *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,7,opt,name=value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"value,omitempty\"`\n // input defines the data payload bytes of the transaction.\n Data     []byte     `protobuf:\"bytes,8,opt,name=data,proto3\" json:\"data,omitempty\"`\n Accesses AccessList `protobuf:\"bytes,9,rep,name=accesses,proto3,castrepeated=AccessList\" json:\"accessList\"`\n // v defines the signature value\n V []byte `protobuf:\"bytes,10,opt,name=v,proto3\" json:\"v,omitempty\"`\n // r defines the signature value\n R []byte `protobuf:\"bytes,11,opt,name=r,proto3\" json:\"r,omitempty\"`\n // s define the signature value\n S []byte `protobuf:\"bytes,12,opt,name=s,proto3\" json:\"s,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li><code>GasTipCap</code> is invalid (<code>nil</code>, negative value or overflow int256)</li> <li><code>GasFeeCap</code> is invalid (<code>nil</code>, negative value or overflow int256)</li> <li><code>GasFeeCap</code> is less than <code>GasTipCap</code></li> <li><code>Fee</code> (gas price * gas limit) is invalid (overflow int256)</li> <li>Invalid <code>Amount</code> (negative or overflow int256)</li> <li>Invalid <code>To</code> address (invalid Ethereum hex address)</li> <li><code>ChainID</code> is <code>nil</code></li> </ul>"},{"location":"evm/#accesslisttx","title":"<code>AccessListTx</code>","text":"<p>EIP-2930 Access transaction data for list transactions.</p> <pre><code>type AccessListTx struct {\n // destination EVM chain ID\n ChainID *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,1,opt,name=chain_id,json=chainId,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"chainID\"`\n // nonce corresponds to the account nonce (transaction sequence).\n Nonce uint64 `protobuf:\"varint,2,opt,name=nonce,proto3\" json:\"nonce,omitempty\"`\n // gas price defines the value for each gas unit\n GasPrice *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,3,opt,name=gas_price,json=gasPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"gas_price,omitempty\"`\n // gas defines the gas limit defined for the transaction.\n GasLimit uint64 `protobuf:\"varint,4,opt,name=gas,proto3\" json:\"gas,omitempty\"`\n // hex formatted address of the recipient\n To string `protobuf:\"bytes,5,opt,name=to,proto3\" json:\"to,omitempty\"`\n // value defines the unsigned integer value of the transaction amount.\n Amount *github_com_cosmos_cosmos_sdk_types.Int `protobuf:\"bytes,6,opt,name=value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int\" json:\"value,omitempty\"`\n // input defines the data payload bytes of the transaction.\n Data     []byte     `protobuf:\"bytes,7,opt,name=data,proto3\" json:\"data,omitempty\"`\n Accesses AccessList `protobuf:\"bytes,8,rep,name=accesses,proto3,castrepeated=AccessList\" json:\"accessList\"`\n // v defines the signature value\n V []byte `protobuf:\"bytes,9,opt,name=v,proto3\" json:\"v,omitempty\"`\n // r defines the signature value\n R []byte `protobuf:\"bytes,10,opt,name=r,proto3\" json:\"r,omitempty\"`\n // s define the signature value\n S []byte `protobuf:\"bytes,11,opt,name=s,proto3\" json:\"s,omitempty\"`\n}\n</code></pre> <p>This message field validation is expected to fail if:</p> <ul> <li><code>GasPrice</code> is invalid (<code>nil</code>, negative, or overflow int256)</li> <li><code>Fee</code> (gas price * gas limit) is invalid (overflow int256)</li> <li>Invalid <code>Amount</code> (negative or overflow int256)</li> <li>Invalid <code>To</code> address (invalid Ethereum hex address)</li> <li><code>ChainID</code> is <code>nil</code></li> </ul>"},{"location":"evm/#abci","title":"ABCI","text":"<p>The Application Blockchain Interface (ABCI) allows applications to interact with the Tendermint consensus engine. The application maintains multiple ABCI connections to Tendermint. Most relevant to <code>x/evm</code> is Consensus Connection at Commit. This connection is responsible for block execution and calls functions <code>InitChain</code> (contains <code>InitGenesis</code>), <code>BeginBlock</code>, <code>DeliverTx</code>, <code>EndBlock</code>, <code>Commit</code>. <code>InitChain</code> is only called the first time a new blockchain is started, and <code>DeliverTx</code> is called for every transaction in a block.</p>"},{"location":"evm/#initialize-genesis","title":"Initialize Genesis","text":"<p><code>InitGenesis</code> initializes the EVM module genesis state by setting the <code>GenesisState</code> field to storage. In particular, it sets parameters and genesis accounts (state and code).</p>"},{"location":"evm/#export-genesis","title":"Export Genesis","text":"<p>The <code>ExportGenesis</code> ABCI function exports the genesis state of an EVM module. In particular, it retrieves all accounts and their bytecodes, balances and storage, transaction logs, As well as EVM parameters and chain configuration.</p>"},{"location":"evm/#begin-block","title":"Begin Block","text":"<p>The EVM module <code>BeginBlock</code> logic is executed before the state transitions that process transactions. The main goals of this function are:</p> <ul> <li>Set the context of the current block for block headers, storage, gas meters, etc.   Once one of the StateDB functions is called during an EVM state transition, these functions are available to the Keeper.</li> <li>Set the EIP155 <code>ChainID</code> number (obtained from the full chain ID) in case it was not previously set during <code>InitChain</code></li> </ul>"},{"location":"evm/#end-block","title":"End block","text":"<p>The <code>EndBlock</code> logic of the EVM module occurs after all state transitions of the transaction have been executed. The main goals of this function are:</p> <ul> <li>emit block bloom event<ul> <li>This is due to web3 compatibility, since the ethereum header includes this type as a field.   The JSON-RPC service uses this event query to construct Ethereum headers from Tendermint headers.</li> <li>The block bloom filter value is fetched from transient storage and then emitted</li> </ul> </li> </ul>"},{"location":"evm/#hooks","title":"hooks","text":"<p>The <code>x/evm</code> module implements an <code>EvmHooks</code> interface, which can extend and customize <code>Tx</code> processing logic externally.</p> <p>This supports EVM contracts calling native cosmos modules</p> <ol> <li>Define log signatures and emit specific logs from smart contracts,</li> <li>Identify these logs in the native tx handling code, and</li> <li>Convert them to native module calls.</li> </ol> <p>For this, the interface contains a PostTxProcessing hook to register custom Tx hooks in EvmKeeper. These <code>Tx</code> hooks are processed after the EVM state transition is complete and will not fail. Note that there are no default hooks implemented in the EVM module.</p> <pre><code>type EvmHooks interface {\n  // Must be called after tx is processed successfully, if return an error, the whole transaction is reversed.\n  PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error\n}\n</code></pre>"},{"location":"evm/#posttxprocessing","title":"<code>PostTxProcessing</code>","text":"<p><code>PostTxProcessing</code> is only called after the EVM transaction has completed successfully, and delegates the call to the underlying hook. If no hooks are registered, this function returns a <code>nil</code> error. .</p> <pre><code>func (k *Keeper) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n  if k.hooks == nil {\n   return nil\n  }\n  return k.hooks.PostTxProcessing(k.Ctx(), msg, receipt)\n}\n</code></pre> <p>It executes in the same cache context as the EVM transaction, if it returns an error, the whole EVM transaction will be reverted, if hook implementors don't want to revert tx, they can always return <code>nil</code>.</p> <p>Errors returned by hooks are translated to VM errors <code>Unable to process native log</code>, with detailed error messages stored in the return value. Messages are sent asynchronously to native modules, and callers cannot catch and recover from errors.</p> <p>** Use case: calling native ERC20 modules on Daodst **</p> <p>The following is an example taken from the Daodst erc20 module showing how <code>EVMHooks</code> support contracts that call native modules to convert ERC-20 tokens to Cosmos native tokens. Follow the steps above.</p> <p>You can define and emit a \"Transfer\" log signature in your smart contract like this:</p> <pre><code>event Transfer(address indexed from, address indexed to, uint256 value);\n\nfunction _transfer(address sender, address recipient, uint256 amount) internal virtual {\n  require(sender != address(0), \"ERC20: transfer from the zero address\");\n  require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n  _beforeTokenTransfer(sender, recipient, amount);\n\n  _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n  _balances[recipient] = _balances[recipient].add(amount);\n  emit Transfer(sender, recipient, amount);\n}\n</code></pre> <p>The application will register a <code>BankSendHook</code> with <code>EvmKeeper</code>. It recognizes the Ethereum tx <code>Log</code> and translates it into a call to the <code>SendCoinsFromAccountToAccount</code> method of the bank module:</p> <pre><code>\nconst ERC20EventTransfer = \"Transfer\"\n\n// PostTxProcessing implements EvmHooks.PostTxProcessing\nfunc (k Keeper) PostTxProcessing(\n ctx sdk.Context,\n msg core.Message,\n receipt *ethtypes.Receipt,\n) error {\n params := h.k.GetParams(ctx)\n if !params.EnableErc20 || !params.EnableEVMHook {\n  // no error is returned to allow for other post-processing txs\n  // to pass\n  return nil\n }\n\n erc20 := contracts.ERC20BurnableContract.ABI\n\n for i, log := range receipt.Logs {\n  if len(log.Topics) &lt; 3 {\n   continue\n  }\n\n  eventID := log.Topics[0] // event ID\n\n  event, err := erc20.EventByID(eventID)\n  if err != nil {\n   // invalid event for ERC20\n   continue\n  }\n\n  if event.Name != types.ERC20EventTransfer {\n   h.k.Logger(ctx).Info(\"emitted event\", \"name\", event.Name, \"signature\", event.Sig)\n   continue\n  }\n\n  transferEvent, err := erc20.Unpack(event.Name, log.Data)\n  if err != nil {\n   h.k.Logger(ctx).Error(\"failed to unpack transfer event\", \"error\", err.Error())\n   continue\n  }\n\n  if len(transferEvent) == 0 {\n   continue\n  }\n\n  tokens, ok := transferEvent[0].(*big.Int)\n  // safety check and ignore if amount not positive\n  if !ok || tokens == nil || tokens.Sign() != 1 {\n   continue\n  }\n\n  // check that the contract is a registered token pair\n  contractAddr := log.Address\n\n  id := h.k.GetERC20Map(ctx, contractAddr)\n\n  if len(id) == 0 {\n   // no token is registered for the caller contract\n   continue\n  }\n\n  pair, found := h.k.GetTokenPair(ctx, id)\n  if !found {\n   continue\n  }\n\n  // check that conversion for the pair is enabled\n  if !pair.Enabled {\n   // continue to allow transfers for the ERC20 in case the token pair is disabled\n   h.k.Logger(ctx).Debug(\n    \"ERC20 token -&gt; Cosmos coin conversion is disabled for pair\",\n    \"coin\", pair.Denom, \"contract\", pair.Erc20Address,\n   )\n   continue\n  }\n\n  // ignore as the burning always transfers to the zero address\n  to := common.BytesToAddress(log.Topics[2].Bytes())\n  if !bytes.Equal(to.Bytes(), types.ModuleAddress.Bytes()) {\n   continue\n  }\n\n  // check that the event is Burn from the ERC20Burnable interface\n  // NOTE: assume that if they are burning the token that has been registered as a pair, they want to mint a Cosmos coin\n\n  // create the corresponding sdk.Coin that is paired with ERC20\n  coins := sdk.Coins{{Denom: pair.Denom, Amount: sdk.NewIntFromBigInt(tokens)}}\n\n  // Mint the coin only if ERC20 is external\n  switch pair.ContractOwner {\n  case types.OWNER_MODULE:\n   _, err = h.k.CallEVM(ctx, erc20, types.ModuleAddress, contractAddr, true, \"burn\", tokens)\n  case types.OWNER_EXTERNAL:\n   err = h.k.bankKeeper.MintCoins(ctx, types.ModuleName, coins)\n  default:\n   err = types.ErrUndefinedOwner\n  }\n\n  if err != nil {\n   h.k.Logger(ctx).Debug(\n    \"failed to process EVM hook for ER20 -&gt; coin conversion\",\n    \"coin\", pair.Denom, \"contract\", pair.Erc20Address, \"error\", err.Error(),\n   )\n   continue\n  }\n\n  // Only need last 20 bytes from log.topics\n  from := common.BytesToAddress(log.Topics[1].Bytes())\n  recipient := sdk.AccAddress(from.Bytes())\n\n  // transfer the tokens from ModuleAccount to sender address\n  if err := h.k.bankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, recipient, coins); err != nil {\n   h.k.Logger(ctx).Debug(\n    \"failed to process EVM hook for ER20 -&gt; coin conversion\",\n    \"tx-hash\", receipt.TxHash.Hex(), \"log-idx\", i,\n    \"coin\", pair.Denom, \"contract\", pair.Erc20Address, \"error\", err.Error(),\n   )\n   continue\n  }\n }\n\n return nil\n</code></pre> <p>Finally, register the hook in app.go:</p> <pre><code>app.EvmKeeper = app.EvmKeeper.SetHooks(app.Erc20Keeper)\n</code></pre>"},{"location":"evm/#event","title":"event","text":"<p>The <code>x/evm</code> module emits Cosmos SDK events after state execution. The EVM module emits events related to transaction fields, as well as transaction logs (Ethereum events)\u3002</p>"},{"location":"evm/#msgethereumtx_2","title":"MsgEthereumTx","text":"Type Property Key Property Value ethereum_tx <code>\"amount\"</code> <code>{amount}</code> ethereum_tx <code>\"recipient\"</code> <code>{hex_address}</code> ethereum_tx <code>\"contract\"</code> <code>{hex_address}</code> ethereum_tx <code>\"txHash\"</code> <code>{tendermint_hex_hash}</code> ethereum_tx <code>\"ethereumTxHash\"</code> <code>{hex_hash}</code> ethereum_tx <code>\"txIndex\"</code> <code>{tx_index}</code> ethereum_tx <code>\"txGasUsed\"</code> <code>{gas_used}</code> tx_log <code>\"txLog\"</code> <code>{tx_log}</code> message <code>\"sender\"</code> <code>{eth_address}</code> message <code>\"action\"</code> <code>\"ethereum\"</code> message <code>\"module\"</code> <code>\"evm\"</code> <p>Additionally, the EVM module emits an event for the filter query block bloom during <code>EndBlock</code>.</p>"},{"location":"evm/#abci_1","title":"ABCI","text":"Type Property Key Property Value block_bloom <code>\"bloom\"</code> <code>string(bloomBytes)</code>"},{"location":"evm/#parameters","title":"parameters","text":"<p>The evm module contains the following parameters:</p>"},{"location":"evm/#module-parameters","title":"Module parameters","text":"Key Data Type Default <code>EVMDenom</code> string <code>\"dst\"</code> <code>EnableCreate</code> bool <code>true</code> <code>EnableCall</code> bool <code>true</code> <code>ExtraEIPs</code> []int TBD <code>ChainConfig</code> ChainConfig See ChainConfig <p>:::hint Note: SDK applications want to import the EVM module as a dependency Will need to set own <code>evm_denom</code> (i.e. not <code>\"dst\"</code>). :::</p>"},{"location":"evm/#enablecreate","title":"EnableCreate","text":"<p>The EnableCreate parameter toggles state transitions using the <code>vm.Create</code> function. When this parameter is disabled, it blocks all contract creation functions.</p>"},{"location":"evm/#enablecall","title":"EnableCall","text":"<p>The EnableCall parameter toggles state transitions using the <code>vm.Call</code> function. When this parameter is disabled, it prevents transfers between accounts and execution of smart contract calls.</p>"},{"location":"evm/#extra-eips","title":"Extra EIPs","text":"<p>The additional EIPs parameter defines a set of Ethereum Improvement Proposals that can be activated on the Ethereum VM <code>Config</code> applying a custom jump table (EIPs ).</p> <p>:::hint Note: Some of these EIPs are already enabled via chain configuration, depending on the number of hard forks. :::</p> <p>The supported activatable EIPS are:</p> <ul> <li>EIP 1344</li> <li>EIP 1884</li> <li>EIP 2200</li> <li>EIP 2315</li> <li>EIP 2929</li> <li>EIP 3198</li> <li>EIP 3529</li> </ul>"},{"location":"evm/#chain-config","title":"Chain Config","text":"<p><code>ChainConfig</code> is a protobuf wrapper type that contains the same fields as the go-ethereum <code>ChainConfig</code> parameter, but uses <code>*sdk.Int</code> type instead of <code>*big.Int</code>.</p> <p>By default, all block configuration fields except <code>ConstantinopleBlock</code> are enabled at Genesis (height 0).</p>"},{"location":"evm/#default-chainconfig","title":"Default ChainConfig","text":"name default HomesteadBlock 0 DAOForkBlock 0 DAOForkSupport <code>true</code> EIP150Block 0 EIP150Hash <code>0x0000000000000000000000000000000000000000000000000000000000000000</code> EIP155Block 0 EIP158Block 0 ByzantiumBlock 0 ConstantinopleBlock 0 PetersburgBlock 0 IstanbulBlock 0 MuirGlacierBlock 0 BerlinBlock 0 LondonBlock 0 ArrowGlacierBlock 0 GrayGlacierBlock 0 MergeNetsplitBlock 0 ShanghaiBlock 0 CancunBlock. 0"},{"location":"evm/#client_1","title":"client","text":"<p>Users can query and interact with the <code>evm</code> module using CLI, JSON-RPC, gRPC, or REST.</p>"},{"location":"evm/#cli","title":"CLI","text":"<p>Below find a list of <code>stcd</code> commands added using the <code>x/evm</code> module. You can get a complete list with <code>stcd -h</code> command.</p>"},{"location":"evm/#inquire","title":"Inquire","text":"<p>The <code>query</code> command allows the user to query the state of <code>evm</code>.</p> <p><code>code</code></p> <p>Allows users to query the smart contract code for a given address.</p> <pre><code>stcd query evm code ADDRESS [flags]\n</code></pre> <pre><code># Example\n$ stcd query evm code 0x7bf7b17da59880d9bcca24915679668db75f9397\n\n# Output\ncode: \"0xef616c92f3cfc9e92dc270d6acff9cea213cecc7020a76ee4395af09bdceb4837a1ebdb5735e11e7d3adb6104e0c3ac55180b4ddf5e54d022cc5e8837f6a4f971b\"\n</code></pre> <p><code>storage</code></p> <p>Allows users to query the store for accounts with a given key and height\u3002</p> <pre><code>stcd query evm storage ADDRESS KEY [flags]\n</code></pre> <pre><code># Example\n$ stcd query evm storage 0x0f54f47bf9b8e317b214ccd6a7c3e38b893cd7f0 0 --height 0\n\n# Output\nvalue: \"0x0000000000000000000000000000000000000000000000000000000000000000\"\n</code></pre>"},{"location":"evm/#trade_1","title":"trade","text":"<p>The <code>tx</code> command allows the user to interact with the <code>evm</code> module.</p> <p><code>raw</code></p> <p>Allows users to build cosmos transactions from raw Ethereum transactions.</p> <pre><code>stcd tx evm raw TX_HEX [flags]\n</code></pre> <pre><code># Example\n$ stcd tx evm raw 0xf9ff74c86aefeb5f6019d77280bbb44fb695b4d45cfe97e6eed7acd62905f4a85034d5c68ed25a2e7a8eeb9baf1b84\n\n# Output\nvalue: \"0x0000000000000000000000000000000000000000000000000000000000000000\"\n</code></pre>"},{"location":"evm/#grpc","title":"gRPC","text":""},{"location":"evm/#inquire_1","title":"Inquire","text":"Verb Method Description <code>gRPC</code> <code>ethermint.evm.v1.Query/Account</code> Get Ethereum account <code>gRPC</code> <code>ethermint.evm.v1.Query/CosmosAccount</code> Get the Cosmos address of an Ethereum account <code>gRPC</code> <code>ethermint.evm.v1.Query/ValidatorAccount</code> Get Ethereum account from validator consensus address <code>gRPC</code> <code>ethermint.evm.v1.Query/Balance</code> Get the EVM denomination balance of a single EthAccount. <code>gRPC</code> <code>ethermint.evm.v1.Query/Storage</code> Get the balance of all coins in a single account <code>gRPC</code> <code>ethermint.evm.v1.Query/Code</code> Get the balance of all coins in a single account <code>gRPC</code> <code>ethermint.evm.v1.Query/Params</code> Get the parameters of the x/evm module <code>gRPC</code> <code>ethermint.evm.v1.Query/EthCall</code> implements the eth_call rpc api <code>gRPC</code> <code>ethermint.evm.v1.Query/EstimateGas</code> implements the eth_estimateGas rpc api <code>gRPC</code> <code>ethermint.evm.v1.Query/TraceTx</code> implement debug_traceTransaction rpc api <code>gRPC</code> <code>ethermint.evm.v1.Query/TraceBlock</code> implements debug_traceBlockByNumber and debug_traceBlockByHash rpc api <code>GET</code> <code>/ethermint/evm/v1/account/{address}</code> Get Ethereum account <code>GET</code> <code>/ethermint/evm/v1/cosmos_account/{address}</code> Get the Cosmos address of the Ethereum account <code>GET</code> <code>/ethermint/evm/v1/validator_account/{cons_address}</code> Get Ethereum account from validator consensus address <code>GET</code> <code>/ethermint/evm/v1/balances/{address}</code> Get the EVM denomination balance of a single EthAccount. <code>GET</code> <code>/ethermint/evm/v1/storage/{address}/{key}</code> Get the balance of all coins in a single account <code>GET</code> <code>/ethermint/evm/v1/codes/{address}</code> Get the balance of all coins in a single account <code>GET</code> <code>/ethermint/evm/v1/params</code> Get the parameters of the x/evm module <code>GET</code> <code>/ethermint/evm/v1/eth_call</code> implements eth_call rpc api <code>GET</code> <code>/ethermint/evm/v1/estimate_gas</code> implements the eth_estimateGas rpc api <code>GET</code> <code>/ethermint/evm/v1/trace_tx</code> implements debug_traceTransaction rpc api <code>GET</code> <code>/ethermint/evm/v1/trace_block</code> implements debug_traceBlockByNumber and debug_traceBlockByHash rpc api"},{"location":"evm/#trade_2","title":"trade","text":"Verb Method Description <code>gRPC</code> <code>ethermint.evm.v1.Msg/EthereumTx</code> Submit an Ethereum transaction <code>POST</code> <code>/ethermint/evm/v1/ethereum_tx</code> Submit an Ethereum transaction"},{"location":"faq/","title":"General FAQ","text":"<p>View answers to frequently asked questions on DST.</p>"},{"location":"faq/#app","title":"APP","text":"Why does APP query data fail validation? <p> The balance query and TX result query of the APP have an anti cheating verification mechanism. If the verification results are incorrect, you may encounter data query verification failure. </p> <p> When the app starts, it initializes the verification client and extracts the verification nodes from the available gateway nodes. When querying balance and TX status, the query results will be verified with the verification node. If the verification fails, an error will be prompted </p>"},{"location":"faq/#network-related","title":"Network related","text":"What port numbers do servers need to open? <p> TCP Open Port\uff1a1317 , 8545 , 23478 , 26656 , 26657 , 28008 , 28043 , 50327 , 50328 </p> <p> UDP Open Port\uff1a3478, 50000~55000 </p> Why does the gateway address fail verification? How to solve it? <p> 1.First, explain why gateway address verification failed </p> <p> Due to the need for gateway addresses to provide external services, it is required that the gateway address must be open to the public. </p> <p> Therefore, when setting the gateway address, the connectivity of the address will be tested through the internet. When the request fails to be sent or the request result is incorrect, an error will be thrown indicating that the gateway address verification has failed. </p> <p> 2.How to solve the problem of gateway address verification failure </p> <p> The failure of gateway address verification is essentially due to network access failure, which needs to be addressed from the network layer. Solving requires a certain level of hands-on ability. If there are difficulties, it is recommended to find a partner to help. <ul> <li>Firstly, check if the router settings are correct and if the port image is correctly set (refer to the introduction on the current page for a list of port numbers that require an image)</li> <li>If it has not been resolved yet, you can check if the server's firewall is enabled. If it is enabled, please check if the list of ports that need to be opened is already open.</li> <li>If it has not been resolved yet, you can contact the current network supplier and explain the list of ports that need to be opened for their assistance in resolving the issue</li>"},{"location":"gateway/","title":"Overview","text":""},{"location":"gateway/#setup-and-configuration","title":"Setup and configuration","text":""},{"location":"gateway/#run-validator","title":"Run validator","text":""},{"location":"gateway/#configuration","title":"configuration","text":""},{"location":"gateway/#hdd-usage-optimization","title":"HDD usage optimization","text":""},{"location":"gateway/#state-synchronization","title":"State Synchronization","text":""},{"location":"gateway/#memory-pool","title":"memory pool","text":""},{"location":"gateway/#validator-faq","title":"Validator FAQ","text":""},{"location":"gateway/#authenticator-security","title":"Authenticator Security","text":""},{"location":"gateway/#sentinel-node-ddos-protected","title":"Sentinel Node (DDOS Protected)","text":""},{"location":"gateway/#key-backup","title":"Key backup","text":""},{"location":"gateway/#upgrade","title":"upgrade","text":""},{"location":"gateway/#upgrade-checklist","title":"Upgrade Checklist","text":""},{"location":"gateway/#hard-fork-upgrade","title":"Hard Fork Upgrade","text":""},{"location":"gateway/#manual-upgrade","title":"Manual upgrade","text":""},{"location":"gateway/#testnet","title":"Testnet","text":""},{"location":"gateway/#mainnet","title":"Mainnet","text":""},{"location":"gov/","title":"Gov","text":""},{"location":"gov/#gov","title":"<code>gov</code>","text":""},{"location":"gov/#abstract","title":"Abstract","text":"<p>This paper specifies the Governance module</p> <p>The module enables Cosmos-SDK based blockchain to support an on-chain governance system. In this system, holders of the native staking token of the chain can vote on proposals on a 1 token 1 vote basis. Next is a list of features the module currently supports:</p> <ul> <li>Proposal submission: Users can submit proposals with a deposit. Once the minimum deposit is reached, proposal enters voting period</li> <li>Vote: Participants can vote on proposals that reached MinDeposit</li> <li>Inheritance and penalties: Delegators inherit their validator's vote if they don't vote themselves.</li> <li>Claiming deposit: Users that deposited on proposals can recover their deposits if the proposal was accepted OR if the proposal never entered voting period.</li> </ul> <p>This module will be used in the Cosmos Hub, the first Hub in the Cosmos network. Features that may be added in the future are described in Future Improvements.</p>"},{"location":"gov/#contents","title":"Contents","text":""},{"location":"gov/#concepts","title":"Concepts","text":"<p>Disclaimer: This is work in progress. Mechanisms are susceptible to change.</p> <p>The governance process is divided in a few steps that are outlined below:</p> <ul> <li>Proposal submission: Proposal is submitted to the blockchain with a   deposit.</li> <li>Vote: Once deposit reaches a certain value (<code>MinDeposit</code>), proposal is   confirmed and vote opens. Bonded Atom holders can then send <code>TxGovVote</code>   transactions to vote on the proposal.</li> <li>If the proposal involves a software upgrade:</li> <li>Signal: Validators start signaling that they are ready to switch to the      new version.</li> <li>Switch: Once more than 75% of validators have signaled that they are      ready to switch, their software automatically flips to the new version.</li> </ul>"},{"location":"gov/#proposal-submission","title":"Proposal submission","text":""},{"location":"gov/#right-to-submit-a-proposal","title":"Right to submit a proposal","text":"<p>Any Dst holder, whether bonded or unbonded, can submit proposals by sending a <code>TxGovProposal</code> transaction. Once a proposal is submitted, it is identified by its unique <code>proposalID</code>.</p>"},{"location":"gov/#proposal-types","title":"Proposal types","text":"<p>In the initial version of the governance module, there are five types of proposals:</p> <ul> <li><code>TextProposal</code> All the proposals that do not involve a modification of   the source code go under this type. For example, an opinion poll would use a   proposal of type <code>TextProposal</code>.</li> <li><code>SoftwareUpgradeProposal</code>. If accepted, validators are expected to update   their software in accordance with the proposal. They must do so by following   a 2-steps process described in the Software Upgrade   section below. Software upgrade roadmap may be discussed and agreed on via   <code>TextProposals</code>, but actual software upgrades must be performed via   <code>SoftwareUpgradeProposals</code>.</li> <li><code>CommunityPoolSpendProposal</code> details a proposal for use of community funds,   together with how many coins are proposed to be spent, and to which recipient account.</li> <li><code>ParameterChangeProposal</code> defines a proposal to change one or   more parameters. If accepted, the requested parameter change is updated   automatically by the proposal handler upon conclusion of the voting period.</li> <li><code>CancelSoftwareUpgradeProposal</code> is a gov Content type for cancelling a software upgrade.</li> </ul> <p>Other modules may expand upon the governance module by implementing their own proposal types and handlers. These types are registered and processed through the governance module (eg. <code>ParamChangeProposal</code>), which then execute the respective module's proposal handler when a proposal passes. This custom handler may perform arbitrary state changes.</p>"},{"location":"gov/#deposit","title":"Deposit","text":"<p>To prevent spam, proposals must be submitted with a deposit in the coins defined in the <code>MinDeposit</code> param. The voting period will not start until the proposal's deposit equals <code>MinDeposit</code>.</p> <p>When a proposal is submitted, it has to be accompanied by a deposit that must be strictly positive, but can be inferior to <code>MinDeposit</code>. The submitter doesn't need to pay for the entire deposit on their own. If a proposal's deposit is inferior to <code>MinDeposit</code>, other token holders can increase the proposal's deposit by sending a <code>Deposit</code> transaction. The deposit is kept in an escrow in the governance <code>ModuleAccount</code> until the proposal is finalized (passed or rejected).</p> <p>Once the proposal's deposit reaches <code>MinDeposit</code>, it enters voting period. If proposal's deposit does not reach <code>MinDeposit</code> before <code>MaxDepositPeriod</code>, proposal closes and nobody can deposit on it anymore.</p>"},{"location":"gov/#deposit-refund-and-burn","title":"Deposit refund and burn","text":"<p>When a the a proposal finalized, the coins from the deposit are either refunded or burned, according to the final tally of the proposal:</p> <ul> <li>If the proposal is approved or if it's rejected but not vetoed, deposits will automatically be refunded to their respective depositor (transferred from the governance <code>ModuleAccount</code>).</li> <li>When the proposal is vetoed with a supermajority, deposits be burned from the governance <code>ModuleAccount</code>.</li> </ul>"},{"location":"gov/#vote","title":"Vote","text":""},{"location":"gov/#participants","title":"Participants","text":"<p>Participants are users that have the right to vote on proposals. On the Cosmos Hub, participants are bonded Dst holders. Unbonded Atom holders and other users do not get the right to participate in governance. However, they can submit and deposit on proposals.</p> <p>Note that some participants can be forbidden to vote on a proposal under a certain validator if:</p> <ul> <li>participant bonded or unbonded Dst to said validator after proposal   entered voting period.</li> <li>participant became validator after proposal entered voting period.</li> </ul> <p>This does not prevent participant to vote with Dst bonded to other validators. For example, if a participant bonded some Atoms to validator A before a proposal entered voting period and other Atoms to validator B after proposal entered voting period, only the vote under validator B will be forbidden.</p>"},{"location":"gov/#voting-period","title":"Voting period","text":"<p>Once a proposal reaches <code>MinDeposit</code>, it immediately enters <code>Voting period</code>. We define <code>Voting period</code> as the interval between the moment the vote opens and the moment the vote closes. <code>Voting period</code> should always be shorter than <code>Unbonding period</code> to prevent double voting. The initial value of <code>Voting period</code> is 2 weeks.</p>"},{"location":"gov/#option-set","title":"Option set","text":"<p>The option set of a proposal refers to the set of choices a participant can choose from when casting its vote.</p> <p>The initial option set includes the following options:</p> <ul> <li><code>Yes</code></li> <li><code>No</code></li> <li><code>NoWithVeto</code></li> <li><code>Abstain</code></li> </ul> <p><code>NoWithVeto</code> counts as <code>No</code> but also adds a <code>Veto</code> vote. <code>Abstain</code> option allows voters to signal that they do not intend to vote in favor or against the proposal but accept the result of the vote.</p> <p>Note: from the UI, for urgent proposals we should maybe add a \u2018Not Urgent\u2019 option that casts a <code>NoWithVeto</code> vote.</p>"},{"location":"gov/#quorum","title":"Quorum","text":"<p>Quorum is defined as the minimum percentage of voting power that needs to be casted on a proposal for the result to be valid.</p>"},{"location":"gov/#threshold","title":"Threshold","text":"<p>Threshold is defined as the minimum proportion of <code>Yes</code> votes (excluding <code>Abstain</code> votes) for the proposal to be accepted.</p> <p>Initially, the threshold is set at 50% with a possibility to veto if more than 1/3rd of votes (excluding <code>Abstain</code> votes) are <code>NoWithVeto</code> votes. This means that proposals are accepted if the proportion of <code>Yes</code> votes (excluding <code>Abstain</code> votes) at the end of the voting period is superior to 50% and if the proportion of <code>NoWithVeto</code> votes is inferior to 1/3 (excluding <code>Abstain</code> votes).</p>"},{"location":"gov/#inheritance","title":"Inheritance","text":"<p>If a delegator does not vote, it will inherit its validator vote.</p> <ul> <li>If the delegator votes before its validator, it will not inherit from the   validator's vote.</li> <li>If the delegator votes after its validator, it will override its validator   vote with its own. If the proposal is urgent, it is possible   that the vote will close before delegators have a chance to react and   override their validator's vote. This is not a problem, as proposals require more than 2/3rd of the total voting power to pass before the end of the voting period. If more than 2/3rd of validators collude, they can censor the votes of delegators anyway.</li> </ul>"},{"location":"gov/#validators-punishment-for-non-voting","title":"Validator\u2019s punishment for non-voting","text":"<p>At present, validators are not punished for failing to vote.</p>"},{"location":"gov/#governance-address","title":"Governance address","text":"<p>Later, we may add permissioned keys that could only sign txs from certain modules. For the MVP, the <code>Governance address</code> will be the main validator address generated at account creation. This address corresponds to a different PrivKey than the Tendermint PrivKey which is responsible for signing consensus messages. Validators thus do not have to sign governance transactions with the sensitive Tendermint PrivKey.</p>"},{"location":"gov/#software-upgrade","title":"Software Upgrade","text":"<p>If proposals are of type <code>SoftwareUpgradeProposal</code>, then nodes need to upgrade their software to the new version that was voted. This process is divided in two steps.</p>"},{"location":"gov/#signal","title":"Signal","text":"<p>After a <code>SoftwareUpgradeProposal</code> is accepted, validators are expected to download and install the new version of the software while continuing to run the previous version. Once a validator has downloaded and installed the upgrade, it will start signaling to the network that it is ready to switch by including the proposal's <code>proposalID</code> in its precommits.(Note: Confirmation that we want it in the precommit?)</p> <p>Note: There is only one signal slot per precommit. If several <code>SoftwareUpgradeProposals</code> are accepted in a short timeframe, a pipeline will form and they will be implemented one after the other in the order that they were accepted.</p>"},{"location":"gov/#switch","title":"Switch","text":"<p>Once a block contains more than 2/3rd precommits where a common <code>SoftwareUpgradeProposal</code> is signaled, all the nodes (including validator nodes, non-validating full nodes and light-nodes) are expected to switch to the new version of the software.</p> <p>Note: Not clear how the flip is handled programmatically</p>"},{"location":"gov/#state","title":"State","text":""},{"location":"gov/#parameters-and-base-types","title":"Parameters and base types","text":"<p><code>Parameters</code> define the rules according to which votes are run. There can only be one active parameter set at any given time. If governance wants to change a parameter set, either to modify a value or add/remove a parameter field, a new parameter set has to be created and the previous one rendered inactive.</p>"},{"location":"gov/#depositparams","title":"DepositParams","text":"<p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/gov/v1beta1/gov.proto#L127-L145</p>"},{"location":"gov/#votingparams","title":"VotingParams","text":"<p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/gov/v1beta1/gov.proto#L147-L156</p>"},{"location":"gov/#tallyparams","title":"TallyParams","text":"<p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/gov/v1beta1/gov.proto#L158-L183</p> <p>Parameters are stored in a global <code>GlobalParams</code> KVStore.</p> <p>Additionally, we introduce some basic types:</p> <pre><code>type Vote byte\n\nconst (\n    VoteYes         = 0x1\n    VoteNo          = 0x2\n    VoteNoWithVeto  = 0x3\n    VoteAbstain     = 0x4\n)\n\ntype ProposalType  string\n\nconst (\n    ProposalTypePlainText       = \"Text\"\n    ProposalTypeSoftwareUpgrade = \"SoftwareUpgrade\"\n)\n\ntype ProposalStatus byte\n\n\nconst (\n    StatusNil           ProposalStatus = 0x00\n    StatusDepositPeriod ProposalStatus = 0x01  // Proposal is submitted. Participants can deposit on it but not vote\n    StatusVotingPeriod  ProposalStatus = 0x02  // MinDeposit is reached, participants can vote\n    StatusPassed        ProposalStatus = 0x03  // Proposal passed and successfully executed\n    StatusRejected      ProposalStatus = 0x04  // Proposal has been rejected\n    StatusFailed        ProposalStatus = 0x05  // Proposal passed but failed execution\n)\n</code></pre>"},{"location":"gov/#deposit_1","title":"Deposit","text":"<p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/gov/v1beta1/gov.proto#L43-L53</p>"},{"location":"gov/#validatorgovinfo","title":"ValidatorGovInfo","text":"<p>This type is used in a temp map when tallying</p> <pre><code>  type ValidatorGovInfo struct {\n    Minus     sdk.Dec\n    Vote      Vote\n  }\n</code></pre>"},{"location":"gov/#proposals","title":"Proposals","text":"<p><code>Proposal</code> objects are used to account votes and generally track the proposal's state. They contain <code>Content</code> which denotes what this proposal is about, and other fields, which are the mutable state of the governance process.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/gov/v1beta1/gov.proto#L55-L77</p> <pre><code>type Content interface {\n    GetTitle() string\n    GetDescription() string\n    ProposalRoute() string\n    ProposalType() string\n    ValidateBasic() sdk.Error\n    String() string\n}\n</code></pre> <p>The <code>Content</code> on a proposal is an interface which contains the information about the <code>Proposal</code> such as the tile, description, and any notable changes. Also, this <code>Content</code> type can by implemented by any module. The <code>Content</code>'s <code>ProposalRoute</code> returns a string which must be used to route the <code>Content</code>'s <code>Handler</code> in the governance keeper. This allows the governance keeper to execute proposal logic implemented by any module. If a proposal passes, the handler is executed. Only if the handler is successful does the state get persisted and the proposal finally passes. Otherwise, the proposal is rejected.</p> <pre><code>type Handler func(ctx sdk.Context, content Content) sdk.Error\n</code></pre> <p>The <code>Handler</code> is responsible for actually executing the proposal and processing any state changes specified by the proposal. It is executed only if a proposal passes during <code>EndBlock</code>.</p> <p>We also mention a method to update the tally for a given proposal:</p> <pre><code>  func (proposal Proposal) updateTally(vote byte, amount sdk.Dec)\n</code></pre>"},{"location":"gov/#stores","title":"Stores","text":"<p>Stores are KVStores in the multi-store. The key to find the store is the first parameter in the list`</p> <p>We will use one KVStore <code>Governance</code> to store two mappings:</p> <ul> <li>A mapping from <code>proposalID|'proposal'</code> to <code>Proposal</code>.</li> <li>A mapping from <code>proposalID|'addresses'|address</code> to <code>Vote</code>. This mapping allows   us to query all addresses that voted on the proposal along with their vote by   doing a range query on <code>proposalID:addresses</code>.</li> </ul> <p>For pseudocode purposes, here are the two function we will use to read or write in stores:</p> <ul> <li><code>load(StoreKey, Key)</code>: Retrieve item stored at key <code>Key</code> in store found at key <code>StoreKey</code> in the multistore</li> <li><code>store(StoreKey, Key, value)</code>: Write value <code>Value</code> at key <code>Key</code> in store found at key <code>StoreKey</code> in the multistore</li> </ul>"},{"location":"gov/#proposal-processing-queue","title":"Proposal Processing Queue","text":"<p>Store:</p> <ul> <li><code>ProposalProcessingQueue</code>: A queue <code>queue[proposalID]</code> containing all the   <code>ProposalIDs</code> of proposals that reached <code>MinDeposit</code>. During each <code>EndBlock</code>,   all the proposals that have reached the end of their voting period are processed.   To process a finished proposal, the application tallies the votes, computes the   votes of each validator and checks if every validator in the validator set has   voted. If the proposal is accepted, deposits are refunded. Finally, the proposal   content <code>Handler</code> is executed.</li> </ul> <p>And the pseudocode for the <code>ProposalProcessingQueue</code>:</p> <pre><code>  in EndBlock do\n\n    for finishedProposalID in GetAllFinishedProposalIDs(block.Time)\n      proposal = load(Governance, &lt;proposalID|'proposal'&gt;) // proposal is a const key\n\n      validators = Keeper.getAllValidators()\n      tmpValMap := map(sdk.AccAddress)ValidatorGovInfo\n\n      // Initiate mapping at 0. This is the amount of shares of the validator's vote that will be overridden by their delegator's votes\n      for each validator in validators\n        tmpValMap(validator.OperatorAddr).Minus = 0\n\n      // Tally\n      voterIterator = rangeQuery(Governance, &lt;proposalID|'addresses'&gt;) //return all the addresses that voted on the proposal\n      for each (voterAddress, vote) in voterIterator\n        delegations = stakingKeeper.getDelegations(voterAddress) // get all delegations for current voter\n\n        for each delegation in delegations\n          // make sure delegation.Shares does NOT include shares being unbonded\n          tmpValMap(delegation.ValidatorAddr).Minus += delegation.Shares\n          proposal.updateTally(vote, delegation.Shares)\n\n        _, isVal = stakingKeeper.getValidator(voterAddress)\n        if (isVal)\n          tmpValMap(voterAddress).Vote = vote\n\n      tallyingParam = load(GlobalParams, 'TallyingParam')\n\n      // Update tally if validator voted they voted\n      for each validator in validators\n        if tmpValMap(validator).HasVoted\n          proposal.updateTally(tmpValMap(validator).Vote, (validator.TotalShares - tmpValMap(validator).Minus))\n\n\n\n      // Check if proposal is accepted or rejected\n      totalNonAbstain := proposal.YesVotes + proposal.NoVotes + proposal.NoWithVetoVotes\n      if (proposal.Votes.YesVotes/totalNonAbstain &gt; tallyingParam.Threshold AND proposal.Votes.NoWithVetoVotes/totalNonAbstain  &lt; tallyingParam.Veto)\n        //  proposal was accepted at the end of the voting period\n        //  refund deposits (non-voters already punished)\n        for each (amount, depositor) in proposal.Deposits\n          depositor.AtomBalance += amount\n\n        stateWriter, err := proposal.Handler()\n        if err != nil\n            // proposal passed but failed during state execution\n            proposal.CurrentStatus = ProposalStatusFailed\n         else\n            // proposal pass and state is persisted\n            proposal.CurrentStatus = ProposalStatusAccepted\n            stateWriter.save()\n      else\n        // proposal was rejected\n        proposal.CurrentStatus = ProposalStatusRejected\n\n      store(Governance, &lt;proposalID|'proposal'&gt;, proposal)\n</code></pre>"},{"location":"gov/#messages","title":"Messages","text":""},{"location":"gov/#proposal-submission_1","title":"Proposal Submission","text":"<p>Proposals can be submitted by any account via a <code>MsgSubmitProposal</code> transaction.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/gov/v1beta1/tx.proto#L24-L39</p> <p>The <code>Content</code> of a <code>MsgSubmitProposal</code> message must have an appropriate router set in the governance module.</p> <p>State modifications:</p> <ul> <li>Generate new <code>proposalID</code></li> <li>Create new <code>Proposal</code></li> <li>Initialise <code>Proposals</code> attributes</li> <li>Decrease balance of sender by <code>InitialDeposit</code></li> <li>If <code>MinDeposit</code> is reached:</li> <li>Push <code>proposalID</code> in <code>ProposalProcessingQueue</code></li> <li>Transfer <code>InitialDeposit</code> from the <code>Proposer</code> to the governance <code>ModuleAccount</code></li> </ul> <p>A <code>MsgSubmitProposal</code> transaction can be handled according to the following pseudocode.</p> <pre><code>// PSEUDOCODE //\n// Check if MsgSubmitProposal is valid. If it is, create proposal //\n\nupon receiving txGovSubmitProposal from sender do\n\n  if !correctlyFormatted(txGovSubmitProposal)\n    // check if proposal is correctly formatted. Includes fee payment.\n    throw\n\n  initialDeposit = txGovSubmitProposal.InitialDeposit\n  if (initialDeposit.Atoms &lt;= 0) OR (sender.AtomBalance &lt; initialDeposit.Atoms)\n    // InitialDeposit is negative or null OR sender has insufficient funds\n    throw\n\n  if (txGovSubmitProposal.Type != ProposalTypePlainText) OR (txGovSubmitProposal.Type != ProposalTypeSoftwareUpgrade)\n\n  sender.AtomBalance -= initialDeposit.Atoms\n\n  depositParam = load(GlobalParams, 'DepositParam')\n\n  proposalID = generate new proposalID\n  proposal = NewProposal()\n\n  proposal.Title = txGovSubmitProposal.Title\n  proposal.Description = txGovSubmitProposal.Description\n  proposal.Type = txGovSubmitProposal.Type\n  proposal.TotalDeposit = initialDeposit\n  proposal.SubmitTime = &lt;CurrentTime&gt;\n  proposal.DepositEndTime = &lt;CurrentTime&gt;.Add(depositParam.MaxDepositPeriod)\n  proposal.Deposits.append({initialDeposit, sender})\n  proposal.Submitter = sender\n  proposal.YesVotes = 0\n  proposal.NoVotes = 0\n  proposal.NoWithVetoVotes = 0\n  proposal.AbstainVotes = 0\n  proposal.CurrentStatus = ProposalStatusOpen\n\n  store(Proposals, &lt;proposalID|'proposal'&gt;, proposal) // Store proposal in Proposals mapping\n  return proposalID\n</code></pre>"},{"location":"gov/#vote_1","title":"Vote","text":"<p>Once <code>ActiveParam.MinDeposit</code> is reached, voting period starts. From there, bonded Atom holders are able to send <code>MsgVote</code> transactions to cast their vote on the proposal.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/gov/v1beta1/tx.proto#L46-L56</p> <p>State modifications:</p> <ul> <li>Record <code>Vote</code> of sender</li> </ul> <p>Note: Gas cost for this message has to take into account the future tallying of the vote in EndBlocker</p> <p>Next is a pseudocode outline of the way <code>MsgVote</code> transactions are handled:</p> <pre><code>  // PSEUDOCODE //\n  // Check if MsgVote is valid. If it is, count vote//\n\n  upon receiving txGovVote from sender do\n    // check if proposal is correctly formatted. Includes fee payment.\n\n    if !correctlyFormatted(txGovDeposit)\n      throw\n\n    proposal = load(Proposals, &lt;txGovDeposit.ProposalID|'proposal'&gt;)\n\n    if (proposal == nil)\n      // There is no proposal for this proposalID\n      throw\n\n\n    if  (proposal.CurrentStatus == ProposalStatusActive)\n\n\n        // Sender can vote if\n        // Proposal is active\n        // Sender has some bonds\n\n        store(Governance, &lt;txGovVote.ProposalID|'addresses'|sender&gt;, txGovVote.Vote)   // Voters can vote multiple times. Re-voting overrides previous vote. This is ok because tallying is done once at the end.\n</code></pre>"},{"location":"gov/#events","title":"Events","text":"<p>The governance module emits the following events:</p>"},{"location":"gov/#endblocker","title":"EndBlocker","text":"Type Attribute Key Attribute Value inactive_proposal proposal_id {proposalID} inactive_proposal proposal_result {proposalResult} active_proposal proposal_id {proposalID} active_proposal proposal_result {proposalResult}"},{"location":"gov/#handlers","title":"Handlers","text":""},{"location":"gov/#msgsubmitproposal","title":"MsgSubmitProposal","text":"Type Attribute Key Attribute Value submit_proposal proposal_id {proposalID} submit_proposal [0] voting_period_start {proposalID} proposal_deposit amount {depositAmount} proposal_deposit proposal_id {proposalID} message module governance message action submit_proposal message sender {senderAddress} <ul> <li>[0] Event only emitted if the voting period starts during the submission.</li> </ul>"},{"location":"gov/#msgvote","title":"MsgVote","text":"Type Attribute Key Attribute Value proposal_vote option {voteOption} proposal_vote proposal_id {proposalID} message module governance message action vote message sender {senderAddress}"},{"location":"gov/#msgdeposit","title":"MsgDeposit","text":"Type Attribute Key Attribute Value proposal_deposit amount {depositAmount} proposal_deposit proposal_id {proposalID} proposal_deposit [0] voting_period_start {proposalID} message module governance message action deposit message sender {senderAddress} <ul> <li>[0] Event only emitted if the voting period starts during the submission.</li> </ul>"},{"location":"gov/#parameters","title":"Parameters","text":"<p>The governance module contains the following parameters:</p> Key Type Example depositparams object {\"min_deposit\":[{\"denom\":\"uatom\",\"amount\":\"10000000\"}],\"max_deposit_period\":\"172800000000000\"} votingparams object {\"voting_period\":\"172800000000000\"} tallyparams object {\"quorum\":\"0.334000000000000000\",\"threshold\":\"0.500000000000000000\",\"veto\":\"0.334000000000000000\"}"},{"location":"gov/#subkeys","title":"SubKeys","text":"Key Type Example min_deposit array (coins) [{\"denom\":\"uatom\",\"amount\":\"10000000\"}] max_deposit_period string (time ns) \"172800000000000\" voting_period string (time ns) \"172800000000000\" quorum string (dec) \"0.334000000000000000\" threshold string (dec) \"0.500000000000000000\" veto string (dec) \"0.334000000000000000\" <p>NOTE: The governance module contains parameters that are objects unlike other modules. If only a subset of parameters are desired to be changed, only they need to be included and not the entire parameter object structure.</p>"},{"location":"gov/#client","title":"Client","text":""},{"location":"gov/#cli","title":"CLI","text":"<p>A user can query and interact with the <code>gov</code> module using the CLI.</p>"},{"location":"gov/#query","title":"Query","text":"<p>The <code>query</code> commands allow users to query <code>gov</code> state.</p> <pre><code>simd query gov --help\n</code></pre>"},{"location":"gov/#deposit_2","title":"deposit","text":"<p>The <code>deposit</code> command allows users to query a deposit for a given proposal from a given depositor.</p> <pre><code>simd query gov deposit [proposal-id] [depositer-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov deposit 1 cosmos1..\n</code></pre> <p>Example Output:</p> <pre><code>amount:\n- amount: \"100\"\n  denom: stake\ndepositor: cosmos1..\nproposal_id: \"1\"\n</code></pre>"},{"location":"gov/#deposits","title":"deposits","text":"<p>The <code>deposits</code> command allows users to query all deposits for a given proposal.</p> <pre><code>simd query gov deposits [proposal-id] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov deposits 1\n</code></pre> <p>Example Output:</p> <pre><code>deposits:\n- amount:\n  - amount: \"100\"\n    denom: stake\n  depositor: cosmos1..\n  proposal_id: \"1\"\npagination:\n  next_key: null\n  total: \"0\"\n</code></pre>"},{"location":"gov/#param","title":"param","text":"<p>The <code>param</code> command allows users to query a given parameter for the <code>gov</code> module.</p> <pre><code>simd query gov param [param-type] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov param voting\n</code></pre> <p>Example Output:</p> <pre><code>voting_period: \"172800000000000\"\n</code></pre>"},{"location":"gov/#params","title":"params","text":"<p>The <code>params</code> command allows users to query all parameters for the <code>gov</code> module.</p> <pre><code>simd query gov params [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov params\n</code></pre> <p>Example Output:</p> <pre><code>deposit_params:\n  max_deposit_period: \"172800000000000\"\n  min_deposit:\n  - amount: \"10000000\"\n    denom: stake\ntally_params:\n  quorum: \"0.334000000000000000\"\n  threshold: \"0.500000000000000000\"\n  veto_threshold: \"0.334000000000000000\"\nvoting_params:\n  voting_period: \"172800000000000\"\n</code></pre>"},{"location":"gov/#proposal","title":"proposal","text":"<p>The <code>proposal</code> command allows users to query a given proposal.</p> <pre><code>simd query gov proposal [proposal-id] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov proposal 1\n</code></pre> <p>Example Output:</p> <pre><code>content:\n  '@type': /cosmos.gov.v1beta1.TextProposal\n  description: testing, testing, 1, 2, 3\n  title: Test Proposal\ndeposit_end_time: \"2021-09-17T23:36:18.254995423Z\"\nfinal_tally_result:\n  abstain: \"0\"\n  \"no\": \"0\"\n  no_with_veto: \"0\"\n  \"yes\": \"0\"\nproposal_id: \"1\"\nstatus: PROPOSAL_STATUS_DEPOSIT_PERIOD\nsubmit_time: \"2021-09-15T23:36:18.254995423Z\"\ntotal_deposit:\n- amount: \"100\"\n  denom: stake\nvoting_end_time: \"0001-01-01T00:00:00Z\"\nvoting_start_time: \"0001-01-01T00:00:00Z\"\n</code></pre>"},{"location":"gov/#proposals_1","title":"proposals","text":"<p>The <code>proposals</code> command allows users to query all proposals with optional filters.</p> <pre><code>simd query gov proposals [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov proposals\n</code></pre> <p>Example Output:</p> <pre><code>pagination:\n  next_key: null\n  total: \"1\"\nproposals:\n- content:\n    '@type': /cosmos.gov.v1beta1.TextProposal\n    description: testing, testing, 1, 2, 3\n    title: Test Proposal\n  deposit_end_time: \"2021-09-17T23:36:18.254995423Z\"\n  final_tally_result:\n    abstain: \"0\"\n    \"no\": \"0\"\n    no_with_veto: \"0\"\n    \"yes\": \"0\"\n  proposal_id: \"1\"\n  status: PROPOSAL_STATUS_DEPOSIT_PERIOD\n  submit_time: \"2021-09-15T23:36:18.254995423Z\"\n  total_deposit:\n  - amount: \"100\"\n    denom: stake\n  voting_end_time: \"0001-01-01T00:00:00Z\"\n  voting_start_time: \"0001-01-01T00:00:00Z\"\n</code></pre>"},{"location":"gov/#proposer","title":"proposer","text":"<p>The <code>proposer</code> command allows users to query the proposer for a given proposal.</p> <pre><code>simd query gov proposer [proposal-id] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov proposer 1\n</code></pre> <p>Example Output:</p> <pre><code>proposal_id: \"1\"\nproposer: cosmos1r0tllwu5c9dtgwg3wr28lpvf76hg85f5zmh9l2\n</code></pre>"},{"location":"gov/#tally","title":"tally","text":"<p>The <code>tally</code> command allows users to query the tally of a given proposal vote.</p> <pre><code>simd query gov tally [proposal-id] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov tally 1\n</code></pre> <p>Example Output:</p> <pre><code>abstain: \"0\"\n\"no\": \"0\"\nno_with_veto: \"0\"\n\"yes\": \"1\"\n</code></pre>"},{"location":"gov/#vote_2","title":"vote","text":"<p>The <code>vote</code> command allows users to query a vote for a given proposal.</p> <pre><code>simd query gov vote [proposal-id] [voter-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov vote 1 cosmos1..\n</code></pre> <p>Example Output:</p> <pre><code>option: VOTE_OPTION_YES\noptions:\n- option: VOTE_OPTION_YES\n  weight: \"1.000000000000000000\"\nproposal_id: \"1\"\nvoter: cosmos1..\n</code></pre>"},{"location":"gov/#votes","title":"votes","text":"<p>The <code>votes</code> command allows users to query all votes for a given proposal.</p> <pre><code>simd query gov votes [proposal-id] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query gov votes 1\n</code></pre> <p>Example Output:</p> <pre><code>pagination:\n  next_key: null\n  total: \"0\"\nvotes:\n- option: VOTE_OPTION_YES\n  options:\n  - option: VOTE_OPTION_YES\n    weight: \"1.000000000000000000\"\n  proposal_id: \"1\"\n  voter: cosmos1r0tllwu5c9dtgwg3wr28lpvf76hg85f5zmh9l2\n</code></pre>"},{"location":"gov/#transactions","title":"Transactions","text":"<p>The <code>tx</code> commands allow users to interact with the <code>gov</code> module.</p> <pre><code>simd tx gov --help\n</code></pre>"},{"location":"gov/#deposit_3","title":"deposit","text":"<p>The <code>deposit</code> command allows users to deposit tokens for a given proposal.</p> <pre><code>simd tx gov deposit [proposal-id] [deposit] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx gov deposit 1 10000000stake --from cosmos1..\n</code></pre>"},{"location":"gov/#submit-proposal","title":"submit-proposal","text":"<p>The <code>submit-proposal</code> command allows users to submit a governance proposal and to optionally include an initial deposit.</p> <pre><code>simd tx gov submit-proposal [command] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx gov submit-proposal --title=\"Test Proposal\" --description=\"testing, testing, 1, 2, 3\" --type=\"Text\" --deposit=\"10000000stake\" --from cosmos1..\n</code></pre> <p>Example (<code>cancel-software-upgrade</code>):</p> <pre><code>simd tx gov submit-proposal cancel-software-upgrade --title=\"Test Proposal\" --description=\"testing, testing, 1, 2, 3\" --deposit=\"10000000stake\" --from cosmos1..\n</code></pre> <p>Example (<code>community-pool-spend</code>):</p> <pre><code>simd tx gov submit-proposal community-pool-spend proposal.json --from cosmos1..\n</code></pre> <pre><code>{\n  \"title\": \"Test Proposal\",\n  \"description\": \"testing, testing, 1, 2, 3\",\n  \"recipient\": \"cosmos1..\",\n  \"amount\": \"10000000stake\",\n  \"deposit\": \"10000000stake\"\n}\n</code></pre> <p>Example (<code>param-change</code>):</p> <pre><code>simd tx gov submit-proposal param-change proposal.json --from cosmos1..\n</code></pre> <pre><code>{\n  \"title\": \"Test Proposal\",\n  \"description\": \"testing, testing, 1, 2, 3\",\n  \"changes\": [\n    {\n      \"subspace\": \"staking\",\n      \"key\": \"MaxValidators\",\n      \"value\": 100\n    }\n  ],\n  \"deposit\": \"10000000stake\"\n}\n</code></pre> <p>Example (<code>software-upgrade</code>):</p> <pre><code>simd tx gov submit-proposal software-upgrade v2 --title=\"Test Proposal\" --description=\"testing, testing, 1, 2, 3\" --upgrade-height 1000000 --from cosmos1..\n</code></pre>"},{"location":"gov/#vote_3","title":"vote","text":"<p>The <code>vote</code> command allows users to submit a vote for a given governance proposal.</p> <pre><code>simd tx gov vote [command] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx gov vote 1 yes --from cosmos1..\n</code></pre>"},{"location":"gov/#weighted-vote","title":"weighted-vote","text":"<p>The <code>weighted-vote</code> command allows users to submit a weighted vote for a given governance proposal.</p> <pre><code>simd tx gov weighted-vote [proposal-id] [weighted-options]\n</code></pre> <p>Example:</p> <pre><code>simd tx gov weighted-vote 1 yes=0.5,no=0.5 --from cosmos1\n</code></pre>"},{"location":"gov/#grpc","title":"gRPC","text":"<p>A user can query the <code>gov</code> module using gRPC endpoints.</p>"},{"location":"gov/#proposal_1","title":"Proposal","text":"<p>The <code>Proposal</code> endpoint allows users to query a given proposal.</p> <pre><code>cosmos.gov.v1beta1.Query/Proposal\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    -d '{\"proposal_id\":\"1\"}' \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/Proposal\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"proposal\": {\n    \"proposalId\": \"1\",\n    \"content\": {\"@type\":\"/cosmos.gov.v1beta1.TextProposal\",\"description\":\"testing, testing, 1, 2, 3\",\"title\":\"Test Proposal\"},\n    \"status\": \"PROPOSAL_STATUS_VOTING_PERIOD\",\n    \"finalTallyResult\": {\n      \"yes\": \"0\",\n      \"abstain\": \"0\",\n      \"no\": \"0\",\n      \"noWithVeto\": \"0\"\n    },\n    \"submitTime\": \"2021-09-16T19:40:08.712440474Z\",\n    \"depositEndTime\": \"2021-09-18T19:40:08.712440474Z\",\n    \"totalDeposit\": [\n      {\n        \"denom\": \"stake\",\n        \"amount\": \"10000000\"\n      }\n    ],\n    \"votingStartTime\": \"2021-09-16T19:40:08.712440474Z\",\n    \"votingEndTime\": \"2021-09-18T19:40:08.712440474Z\"\n  }\n}\n</code></pre>"},{"location":"gov/#proposals_2","title":"Proposals","text":"<p>The <code>Proposals</code> endpoint allows users to query all proposals with optional filters.</p> <pre><code>cosmos.gov.v1beta1.Query/Proposals\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/Proposals\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"proposals\": [\n    {\n      \"proposalId\": \"1\",\n      \"content\": {\"@type\":\"/cosmos.gov.v1beta1.TextProposal\",\"description\":\"testing, testing, 1, 2, 3\",\"title\":\"Test Proposal\"},\n      \"status\": \"PROPOSAL_STATUS_VOTING_PERIOD\",\n      \"finalTallyResult\": {\n        \"yes\": \"0\",\n        \"abstain\": \"0\",\n        \"no\": \"0\",\n        \"noWithVeto\": \"0\"\n      },\n      \"submitTime\": \"2021-09-16T19:40:08.712440474Z\",\n      \"depositEndTime\": \"2021-09-18T19:40:08.712440474Z\",\n      \"totalDeposit\": [\n        {\n          \"denom\": \"stake\",\n          \"amount\": \"10000000\"\n        }\n      ],\n      \"votingStartTime\": \"2021-09-16T19:40:08.712440474Z\",\n      \"votingEndTime\": \"2021-09-18T19:40:08.712440474Z\"\n    },\n    {\n      \"proposalId\": \"2\",\n      \"content\": {\"@type\":\"/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal\",\"description\":\"Test Proposal\",\"title\":\"testing, testing, 1, 2, 3\"},\n      \"status\": \"PROPOSAL_STATUS_DEPOSIT_PERIOD\",\n      \"finalTallyResult\": {\n        \"yes\": \"0\",\n        \"abstain\": \"0\",\n        \"no\": \"0\",\n        \"noWithVeto\": \"0\"\n      },\n      \"submitTime\": \"2021-09-17T18:26:57.866854713Z\",\n      \"depositEndTime\": \"2021-09-19T18:26:57.866854713Z\",\n      \"votingStartTime\": \"0001-01-01T00:00:00Z\",\n      \"votingEndTime\": \"0001-01-01T00:00:00Z\"\n    }\n  ],\n  \"pagination\": {\n    \"total\": \"2\"\n  }\n}\n</code></pre>"},{"location":"gov/#vote_4","title":"Vote","text":"<p>The <code>Vote</code> endpoint allows users to query a vote for a given proposal.</p> <pre><code>cosmos.gov.v1beta1.Query/Vote\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    -d '{\"proposal_id\":\"1\",\"voter\":\"cosmos1..\"}' \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/Vote\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"vote\": {\n    \"proposalId\": \"1\",\n    \"voter\": \"cosmos1..\",\n    \"option\": \"VOTE_OPTION_YES\",\n    \"options\": [\n      {\n        \"option\": \"VOTE_OPTION_YES\",\n        \"weight\": \"1000000000000000000\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"gov/#votes_1","title":"Votes","text":"<p>The <code>Votes</code> endpoint allows users to query all votes for a given proposal.</p> <pre><code>cosmos.gov.v1beta1.Query/Votes\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    -d '{\"proposal_id\":\"1\"}' \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/Votes\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"votes\": [\n    {\n      \"proposalId\": \"1\",\n      \"voter\": \"cosmos1..\",\n      \"option\": \"VOTE_OPTION_YES\",\n      \"options\": [\n        {\n          \"option\": \"VOTE_OPTION_YES\",\n          \"weight\": \"1000000000000000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": {\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"gov/#params_1","title":"Params","text":"<p>The <code>Params</code> endpoint allows users to query all parameters for the <code>gov</code> module.</p> <pre><code>cosmos.gov.v1beta1.Query/Params\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    -d '{\"params_type\":\"voting\"}' \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/Params\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"votingParams\": {\n    \"votingPeriod\": \"172800s\"\n  },\n  \"depositParams\": {\n    \"maxDepositPeriod\": \"0s\"\n  },\n  \"tallyParams\": {\n    \"quorum\": \"MA==\",\n    \"threshold\": \"MA==\",\n    \"vetoThreshold\": \"MA==\"\n  }\n}\n</code></pre>"},{"location":"gov/#deposit_4","title":"Deposit","text":"<p>The <code>Deposit</code> endpoint allows users to query a deposit for a given proposal from a given depositor.</p> <pre><code>cosmos.gov.v1beta1.Query/Deposit\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    '{\"proposal_id\":\"1\",\"depositor\":\"cosmos1..\"}' \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/Deposit\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"deposit\": {\n    \"proposalId\": \"1\",\n    \"depositor\": \"cosmos1..\",\n    \"amount\": [\n      {\n        \"denom\": \"stake\",\n        \"amount\": \"10000000\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"gov/#deposits_1","title":"deposits","text":"<p>The <code>Deposits</code> endpoint allows users to query all deposits for a given proposal.</p> <pre><code>cosmos.gov.v1beta1.Query/Deposits\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    -d '{\"proposal_id\":\"1\"}' \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/Deposits\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"deposits\": [\n    {\n      \"proposalId\": \"1\",\n      \"depositor\": \"cosmos1..\",\n      \"amount\": [\n        {\n          \"denom\": \"stake\",\n          \"amount\": \"10000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": {\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"gov/#tallyresult","title":"TallyResult","text":"<p>The <code>TallyResult</code> endpoint allows users to query the tally of a given proposal.</p> <pre><code>cosmos.gov.v1beta1.Query/TallyResult\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n    -d '{\"proposal_id\":\"1\"}' \\\n    localhost:9090 \\\n    cosmos.gov.v1beta1.Query/TallyResult\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"tally\": {\n    \"yes\": \"1000000\",\n    \"abstain\": \"0\",\n    \"no\": \"0\",\n    \"noWithVeto\": \"0\"\n  }\n}\n</code></pre>"},{"location":"gov/#rest","title":"REST","text":"<p>A user can query the <code>gov</code> module using REST endpoints.</p>"},{"location":"gov/#proposal_2","title":"proposal","text":"<p>The <code>proposals</code> endpoint allows users to query a given proposal.</p> <pre><code>/cosmos/gov/v1beta1/proposals/{proposal_id}\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/proposals/1\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"proposal\": {\n    \"proposal_id\": \"1\",\n    \"content\": {\n      \"@type\": \"/cosmos.gov.v1beta1.TextProposal\",\n      \"title\": \"Test Proposal\",\n      \"description\": \"testing, testing, 1, 2, 3\"\n    },\n    \"status\": \"PROPOSAL_STATUS_VOTING_PERIOD\",\n    \"final_tally_result\": {\n      \"yes\": \"0\",\n      \"abstain\": \"0\",\n      \"no\": \"0\",\n      \"no_with_veto\": \"0\"\n    },\n    \"submit_time\": \"2021-09-16T19:40:08.712440474Z\",\n    \"deposit_end_time\": \"2021-09-18T19:40:08.712440474Z\",\n    \"total_deposit\": [\n      {\n        \"denom\": \"stake\",\n        \"amount\": \"10000000\"\n      }\n    ],\n    \"voting_start_time\": \"2021-09-16T19:40:08.712440474Z\",\n    \"voting_end_time\": \"2021-09-18T19:40:08.712440474Z\"\n  }\n}\n</code></pre>"},{"location":"gov/#proposals_3","title":"proposals","text":"<p>The <code>proposals</code> endpoint also allows users to query all proposals with optional filters.</p> <pre><code>/cosmos/gov/v1beta1/proposals\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/proposals\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"proposals\": [\n    {\n      \"proposal_id\": \"1\",\n      \"content\": {\n        \"@type\": \"/cosmos.gov.v1beta1.TextProposal\",\n        \"title\": \"Test Proposal\",\n        \"description\": \"testing, testing, 1, 2, 3\"\n      },\n      \"status\": \"PROPOSAL_STATUS_VOTING_PERIOD\",\n      \"final_tally_result\": {\n        \"yes\": \"0\",\n        \"abstain\": \"0\",\n        \"no\": \"0\",\n        \"no_with_veto\": \"0\"\n      },\n      \"submit_time\": \"2021-09-16T19:40:08.712440474Z\",\n      \"deposit_end_time\": \"2021-09-18T19:40:08.712440474Z\",\n      \"total_deposit\": [\n        {\n          \"denom\": \"stake\",\n          \"amount\": \"10000000\"\n        }\n      ],\n      \"voting_start_time\": \"2021-09-16T19:40:08.712440474Z\",\n      \"voting_end_time\": \"2021-09-18T19:40:08.712440474Z\"\n    },\n    {\n      \"proposal_id\": \"2\",\n      \"content\": {\n        \"@type\": \"/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal\",\n        \"title\": \"Test Proposal\",\n        \"description\": \"testing, testing, 1, 2, 3\"\n      },\n      \"status\": \"PROPOSAL_STATUS_DEPOSIT_PERIOD\",\n      \"final_tally_result\": {\n        \"yes\": \"0\",\n        \"abstain\": \"0\",\n        \"no\": \"0\",\n        \"no_with_veto\": \"0\"\n      },\n      \"submit_time\": \"2021-09-17T18:26:57.866854713Z\",\n      \"deposit_end_time\": \"2021-09-19T18:26:57.866854713Z\",\n      \"total_deposit\": [\n      ],\n      \"voting_start_time\": \"0001-01-01T00:00:00Z\",\n      \"voting_end_time\": \"0001-01-01T00:00:00Z\"\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"2\"\n  }\n}\n</code></pre>"},{"location":"gov/#voter-vote","title":"voter vote","text":"<p>The <code>votes</code> endpoint allows users to query a vote for a given proposal.</p> <pre><code>/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/proposals/1/votes/cosmos1..\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"vote\": {\n    \"proposal_id\": \"1\",\n    \"voter\": \"cosmos1..\",\n    \"option\": \"VOTE_OPTION_YES\",\n    \"options\": [\n      {\n        \"option\": \"VOTE_OPTION_YES\",\n        \"weight\": \"1.000000000000000000\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"gov/#votes_2","title":"votes","text":"<p>The <code>votes</code> endpoint allows users to query all votes for a given proposal.</p> <pre><code>/cosmos/gov/v1beta1/proposals/{proposal_id}/votes\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/proposals/1/votes\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"votes\": [\n    {\n      \"proposal_id\": \"1\",\n      \"voter\": \"cosmos1..\",\n      \"option\": \"VOTE_OPTION_YES\",\n      \"options\": [\n        {\n          \"option\": \"VOTE_OPTION_YES\",\n          \"weight\": \"1.000000000000000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"gov/#params_2","title":"params","text":"<p>The <code>params</code> endpoint allows users to query all parameters for the <code>gov</code> module.</p> <pre><code>/cosmos/gov/v1beta1/params/{params_type}\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/params/voting\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"voting_params\": {\n    \"voting_period\": \"172800s\"\n  },\n  \"deposit_params\": {\n    \"min_deposit\": [\n    ],\n    \"max_deposit_period\": \"0s\"\n  },\n  \"tally_params\": {\n    \"quorum\": \"0.000000000000000000\",\n    \"threshold\": \"0.000000000000000000\",\n    \"veto_threshold\": \"0.000000000000000000\"\n  }\n}\n</code></pre>"},{"location":"gov/#deposits_2","title":"deposits","text":"<p>The <code>deposits</code> endpoint allows users to query a deposit for a given proposal from a given depositor.</p> <pre><code>/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/proposals/1/deposits/cosmos1..\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"deposit\": {\n    \"proposal_id\": \"1\",\n    \"depositor\": \"cosmos1..\",\n    \"amount\": [\n      {\n        \"denom\": \"stake\",\n        \"amount\": \"10000000\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"gov/#proposal-deposits","title":"proposal deposits","text":"<p>The <code>deposits</code> endpoint allows users to query all deposits for a given proposal.</p> <pre><code>/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/proposals/1/deposits\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"deposits\": [\n    {\n      \"proposal_id\": \"1\",\n      \"depositor\": \"cosmos1..\",\n      \"amount\": [\n        {\n          \"denom\": \"stake\",\n          \"amount\": \"10000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"gov/#tally_1","title":"tally","text":"<p>The <code>tally</code> endpoint allows users to query the tally of a given proposal.</p> <pre><code>/cosmos/gov/v1beta1/proposals/{proposal_id}/tally\n</code></pre> <p>Example:</p> <pre><code>curl localhost:1317/cosmos/gov/v1beta1/proposals/1/tally\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"tally\": {\n    \"yes\": \"1000000\",\n    \"abstain\": \"0\",\n    \"no\": \"0\",\n    \"no_with_veto\": \"0\"\n  }\n}\n</code></pre>"},{"location":"mgateway/","title":"Gateway","text":""},{"location":"mgateway/#abstract","title":"Abstract","text":"<p>This module is responsible for the management of data on the gateway chain</p>"},{"location":"mgateway/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>Keeper</li> <li>Messages</li> <li>Params</li> </ol> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502 \u2514\u2500\u2500 rest\n\u2502 \u251c\u2500\u2500 error.go # interface error collection\n\u2502 \u251c\u2500\u2500 grpc.go # grpc query method\n\u2502 \u251c\u2500\u2500 handle_comm.go # comm module message pre-processing\n\u2502 \u251c\u2500\u2500 handle_msg.go # comm module message pre-processing\n\u2502 \u251c\u2500\u2500 query.go # interface query function\n\u2502 \u251c\u2500\u2500 rest.go # Registration of message and query routing\n\u2502 \u2514\u2500\u2500 tx.go # tx related methods, including broadcasting, etc.\n\u251c\u2500\u2500keeper\n\u2502 \u251c\u2500\u2500 hooks.go # Hook function, triggered by other module logic\n\u2502 \u251c\u2500\u2500 keeper.go # storage manager, handles the business logic of the module, and has permission to access specific subtrees of the state tree\n\u2502 \u251c\u2500\u2500 msg_server.go # Provide service processing logic for uplink messages\n\u2502 \u251c\u2500\u2500 params.go # Setting and obtaining module parameters\n\u2502 \u251c\u2500\u2500 query.go # Status query function\n\u251c\u2500\u2500 types\n\u2502 \u251c\u2500\u2500 codec.go # code registration type\n\u2502 \u251c\u2500\u2500 errors.go # module-specific errors\n\u2502 \u251c\u2500\u2500 events.go # Events exposed to Tendermint PubSub/Websocket\n\u2502 \u251c\u2500\u2500 genesis.go # Genesis state of the module\n\u2502 \u251c\u2500\u2500 interface.go # interface collection of modules\n\u2502 \u251c\u2500\u2500 keys.go # module stores key and some other constants\n\u2502 \u251c\u2500\u2500 msg.go # Chat module transaction message\n\u2502 \u251c\u2500\u2500 params.go # The custom parameters that the module can modify through the governance module\n\u2502 \u251c\u2500\u2500 interface.go # The method implemented by the imported external module\n\u2502 \u2514\u2500\u2500 types.go # module type collection\n\u251c\u2500\u2500 genesis.go # ABCI's genesis state initialization and export function\n\u251c\u2500\u2500 handler.go # message routing\n\u2514\u2500\u2500 module.go # Module settings of the module manager\n</code></pre>"},{"location":"mgateway/#concepts","title":"Concepts","text":""},{"location":"mgateway/#gateway","title":"Gateway","text":"<p>The gateway module is responsible for the management of the data on the gateway chain, including the ownership and acquisition of the number segment</p>"},{"location":"mgateway/#gateway-information","title":"Gateway Information","text":"<p>Gateway registration needs to fill in the name of the gateway, the communication address of the gateway, the name of the APP package, and the first number segment information. The gateway communication address supports IP and domain names, and needs to be bound to the 50327 communication port. The APP package name needs to start with a lowercase letter, and the length cannot exceed 32 characters. Gateways cannot be registered repeatedly, and each DPOS node can only register one gateway. Gateway information supports modifying the name and gateway communication address. \ud83d\udea8 DANGER: Once the communication address of the gateway is modified, the chat information of the gateway will be reset, please proceed with caution.</p>"},{"location":"mgateway/#number-section","title":"Number section","text":"<p>For the first registration of the gateway, a number segment must be filled in, which will be marked as the first number segment of the gateway and used as the communication domain name. The length of the number segment can be 5, 6, or 7. When the quota of the gateway number segment is sufficient, it supports adding multiple number segments. The number segment is divided into three states: binding, redeeming, and unbound. The number segment that has been bound and redeemed cannot be used by other gateways. The number segment that is being redeemed has a default protection period of one year. When the gateway owner pledges again, he can choose the number segment again and bind it. The unbound number segment can be used again by all gateways.</p>"},{"location":"mgateway/#gateway-pledge-and-redemption","title":"Gateway pledge and redemption","text":"<p>By default, every 10 FM pledged can get a gateway number segment quota. When the gateway owner redeems DPOS, corresponding to the redemption of 10 FMs, one number segment must be redeemed or the amount of the corresponding number segment should be reduced. When redeeming in part, the first number segment is not allowed to be redeemed, only other number segments can be selected. If all pledges are redeemed, all number segments will be redeemed. After all pledges are redeemed, the gateway status becomes unavailable.</p>"},{"location":"mgateway/#keeper","title":"Keeper","text":"<p>The contract module 'Keeper' grants access to the state of the chat module And implement 'statedb. Interface to support 'StateDB' implementation. Keeper contains a storage key that allows the repository Write to the concrete subtree of the multibase that can only be accessed by the Chat module. Instead of using trees and databases for querying and persistence (the 'StateDB' implementation), DaoDst uses Cosmos' \"KVStore\" (key-value store) and Cosmos SDK's \"Keeper\" to facilitate state transitions.</p> <p>In order to support the interface function, it imports 7 module Keepers:</p> <ul> <li><code>auth</code>: addition, deletion, modification and query of accounts</li> <li><code>bank</code>: addition, deletion, modification and query of supply and balance</li> <li><code>staking</code>: management of gateway related data</li> <li><code>pledge</code>: management of chat related data</li> <li><code>evm</code>: management of evm related data</li> <li><code>chat</code>: management of chat related data</li> <li><code>gateway</code>: gateway data management</li> </ul> <pre><code>    type Keeper struct {\n        storeKey   sdk.StoreKey\n        cdc        codec.BinaryCodec\n        paramstore paramtypes.Subspace\n\n        stakingKeeper *stakingKeeper.Keeper\n        accountKeeper types.AccountKeeper\n        BankKeeper    types.BankKeeper\n        pledgeKeeper  types.PledgeKeeper\n        evmKeeper     types.EVMKeeper\n        chatKeeper    types.ChatKeeper\n        gatewayKeeper types.GatewayKeeper\n        erc20Keeper   erc20keeper.Keeper\n    }\n</code></pre>"},{"location":"mgateway/#messages","title":"Messages","text":""},{"location":"mgateway/#msgapptokenissue","title":"MsgAppTokenIssue","text":"<pre><code>Through this message, back up the gateway's authenticator key and other information\n</code></pre> <pre><code>    type MsgGatewayUpload struct {\n        FromAddress    string `protobuf:\"bytes,1,opt,name=fromAddress,proto3\" json:\"fromAddress,omitempty\" yaml:\"from_address\"`\n        GatewayKeyInfo []byte `protobuf:\"bytes,2,opt,name=GatewayKeyInfo,proto3\" json:\"GatewayKeyInfo,omitempty\" yaml:\"gateway_key_info\"`\n    }\n</code></pre>"},{"location":"mgateway/#msggatewayregister","title":"MsgGatewayRegister","text":"<pre><code>Through this message, register as a gateway and get the did number segment\n</code></pre> <pre><code>    type MsgGatewayRegister struct {\n        Address string `protobuf:\"bytes,1,opt,name=address,proto3\" json:\"address,omitempty\"`\n        GatewayName string `protobuf:\"bytes,2,opt,name=gateway_name,json=gatewayName,proto3\" json:\"gateway_name,omitempty\"`\n        GatewayUrl string `protobuf:\"bytes,3,opt,name=gateway_url,json=gatewayUrl,proto3\" json:\"gateway_url,omitempty\"`\n        Delegation string `protobuf:\"bytes,4,opt,name=delegation,proto3\" json:\"delegation,omitempty\"`\n        IndexNumber []string `protobuf:\"bytes,5,rep,name=index_number,json=indexNumber,proto3\" json:\"index_number,omitempty\"`\n    }\n</code></pre>"},{"location":"mgateway/#msggatewayindexnum","title":"MsgGatewayIndexNum","text":"<pre><code>Through this message, the gateway can obtain additional did number segments through pledge\n</code></pre> <pre><code>    type MsgGatewayIndexNum struct {\n        DelegatorAddress string `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        ValidatorAddress string `protobuf:\"bytes,2,opt,name=validator_address,json=validatorAddress,proto3\" json:\"validator_address,omitempty\" yaml:\"validator_address\"`\n        IndexNumber []string `protobuf:\"bytes,3,rep,name=index_number,json=indexNumber,proto3\" json:\"index_number,omitempty\"`\n    }\n</code></pre>"},{"location":"mgateway/#msggatewayundelegate","title":"MsgGatewayUndelegate","text":"<pre><code>With this message, the gateway can redeem the stake\n</code></pre> <pre><code>    type MsgGatewayUndelegate struct {\n        DelegatorAddress string      `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        ValidatorAddress string      `protobuf:\"bytes,2,opt,name=validator_address,json=validatorAddress,proto3\" json:\"validator_address,omitempty\" yaml:\"validator_address\"`\n        Amount           types1.Coin `protobuf:\"bytes,3,opt,name=amount,proto3\" json:\"amount\"`\n        IndexNumber []string `protobuf:\"bytes,4,rep,name=index_number,json=indexNumber,proto3\" json:\"index_number,omitempty\"`\n    }\n</code></pre>"},{"location":"mgateway/#parameters","title":"Parameters","text":"<p>The gateway module contains the following module parameters</p>"},{"location":"mgateway/#params","title":"Params","text":"Key Type Default Value <code>IndexNumHeight</code> int64 <code>100</code> <code>RedeemFeeHeight</code> int64 <code>432000</code> <code>RedeemFee</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>MinDelegate</code> github_com_cosmos_cosmos_sdk_types.Coin <code>10000000000000000000000fm</code> <code>Validity</code> int64 <code>5256000</code>"},{"location":"mint/","title":"Mint","text":""},{"location":"mint/#mint","title":"<code>mint</code>","text":""},{"location":"mint/#concepts","title":"Concepts","text":""},{"location":"mint/#the-minting-mechanism","title":"The Minting Mechanism","text":"<p>The minting mechanism was designed to:</p> <ul> <li>allow for a flexible inflation rate determined by market demand targeting a particular bonded-stake ratio</li> <li>effect a balance between market liquidity and staked supply</li> </ul> <p>In order to best determine the appropriate market rate for inflation rewards, a moving change rate is used.  The moving change rate mechanism ensures that if the % bonded is either over or under the goal %-bonded, the inflation rate will adjust to further incentivize or disincentivize being bonded, respectively. Setting the goal %-bonded at less than 100% encourages the network to maintain some non-staked tokens which should help provide some liquidity.</p> <p>It can be broken down in the following way:</p> <ul> <li>If the inflation rate is below the goal %-bonded the inflation rate will increase until a maximum value is reached</li> <li>If the goal % bonded (67% in Cosmos-Hub) is maintained, then the inflation rate will stay constant</li> <li>If the inflation rate is above the goal %-bonded the inflation rate will decrease until a minimum value is reached</li> </ul>"},{"location":"mint/#state","title":"State","text":""},{"location":"mint/#minter","title":"Minter","text":"<p>The minter is a space for holding current inflation information.</p> <ul> <li>Minter: <code>0x00 -&gt; ProtocolBuffer(minter)</code></li> </ul> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0-rc7/proto/cosmos/mint/v1beta1/mint.proto#L8-L19</p>"},{"location":"mint/#params","title":"Params","text":"<p>Minting params are held in the global params store.</p> <ul> <li>Params: <code>mint/params -&gt; legacy_amino(params)</code></li> </ul> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0-rc7/proto/cosmos/mint/v1beta1/mint.proto#L21-L53</p>"},{"location":"mint/#begin-block","title":"Begin-Block","text":"<p>Minting parameters are recalculated and inflation paid at the beginning of each block.</p>"},{"location":"mint/#nextinflationrate","title":"NextInflationRate","text":"<p>The target annual inflation rate is recalculated each block. The inflation is also subject to a rate change (positive or negative) depending on the distance from the desired ratio (67%). The maximum rate change possible is defined to be 13% per year, however the annual inflation is capped as between 7% and 20%.</p> <pre><code>NextInflationRate(params Params, bondedRatio sdk.Dec) (inflation sdk.Dec) {\n    inflationRateChangePerYear = (1 - bondedRatio/params.GoalBonded) * params.InflationRateChange\n    inflationRateChange = inflationRateChangePerYear/blocksPerYr\n\n    // increase the new annual inflation for this next cycle\n    inflation += inflationRateChange\n    if inflation &gt; params.InflationMax {\n        inflation = params.InflationMax\n    }\n    if inflation &lt; params.InflationMin {\n        inflation = params.InflationMin\n    }\n\n    return inflation\n}\n</code></pre>"},{"location":"mint/#nextannualprovisions","title":"NextAnnualProvisions","text":"<p>Calculate the annual provisions based on current total supply and inflation rate. This parameter is calculated once per block.</p> <pre><code>NextAnnualProvisions(params Params, totalSupply sdk.Dec) (provisions sdk.Dec) {\n    return Inflation * totalSupply\n</code></pre>"},{"location":"mint/#blockprovision","title":"BlockProvision","text":"<p>Calculate the provisions generated for each block based on current annual provisions. The provisions are then minted by the <code>mint</code> module's <code>ModuleMinterAccount</code> and then transferred to the <code>auth</code>'s <code>FeeCollector</code> <code>ModuleAccount</code>.</p> <pre><code>BlockProvision(params Params) sdk.Coin {\n    provisionAmt = AnnualProvisions/ params.BlocksPerYear\n    return sdk.NewCoin(params.MintDenom, provisionAmt.Truncate())\n</code></pre>"},{"location":"mint/#parameters","title":"Parameters","text":"<p>The minting module contains the following parameters:</p> Key Type Example MintDenom string \"uatom\" InflationRateChange string (dec) \"0.130000000000000000\" InflationMax string (dec) \"0.200000000000000000\" InflationMin string (dec) \"0.070000000000000000\" GoalBonded string (dec) \"0.670000000000000000\" BlocksPerYear string (uint64) \"6311520\""},{"location":"mint/#events","title":"Events","text":"<p>The minting module emits the following events:</p>"},{"location":"mint/#beginblocker","title":"BeginBlocker","text":"Type Attribute Key Attribute Value mint bonded_ratio {bondedRatio} mint inflation {inflation} mint annual_provisions {annualProvisions} mint amount {amount}"},{"location":"mint/#client","title":"Client","text":""},{"location":"mint/#cli","title":"CLI","text":"<p>A user can query and interact with the <code>mint</code> module using the CLI.</p>"},{"location":"mint/#query","title":"Query","text":"<p>The <code>query</code> commands allow users to query <code>mint</code> state.</p> <pre><code>simd query mint --help\n</code></pre>"},{"location":"mint/#annual-provisions","title":"annual-provisions","text":"<p>The <code>annual-provisions</code> command allow users to query the current minting annual provisions value</p> <pre><code>simd query mint annual-provisions [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query mint annual-provisions\n</code></pre> <p>Example Output:</p> <pre><code>22268504368893.612100895088410693\n</code></pre>"},{"location":"mint/#inflation","title":"inflation","text":"<p>The <code>inflation</code> command allow users to query the current minting inflation value</p> <pre><code>simd query mint inflation [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query mint inflation\n</code></pre> <p>Example Output:</p> <pre><code>0.199200302563256955\n</code></pre>"},{"location":"mint/#params_1","title":"params","text":"<p>The <code>params</code> command allow users to query the current minting parameters</p> <pre><code>simd query mint params [flags]\n</code></pre> <p>Example:</p> <pre><code>blocks_per_year: \"4360000\"\ngoal_bonded: \"0.670000000000000000\"\ninflation_max: \"0.200000000000000000\"\ninflation_min: \"0.070000000000000000\"\ninflation_rate_change: \"0.130000000000000000\"\nmint_denom: stake\n</code></pre>"},{"location":"mint/#grpc","title":"gRPC","text":"<p>A user can query the <code>mint</code> module using gRPC endpoints.</p>"},{"location":"mint/#annualprovisions","title":"AnnualProvisions","text":"<p>The <code>AnnualProvisions</code> endpoint allow users to query the current minting annual provisions value</p> <pre><code>/cosmos.mint.v1beta1.Query/AnnualProvisions\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext localhost:9090 cosmos.mint.v1beta1.Query/AnnualProvisions\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"annualProvisions\": \"1432452520532626265712995618\"\n}\n</code></pre>"},{"location":"mint/#inflation_1","title":"Inflation","text":"<p>The <code>Inflation</code> endpoint allow users to query the current minting inflation value</p> <pre><code>/cosmos.mint.v1beta1.Query/Inflation\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext localhost:9090 cosmos.mint.v1beta1.Query/Inflation\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"inflation\": \"130197115720711261\"\n}\n</code></pre>"},{"location":"mint/#params_2","title":"Params","text":"<p>The <code>Params</code> endpoint allow users to query the current minting parameters</p> <pre><code>/cosmos.mint.v1beta1.Query/Params\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext localhost:9090 cosmos.mint.v1beta1.Query/Params\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"params\": {\n    \"mintDenom\": \"stake\",\n    \"inflationRateChange\": \"130000000000000000\",\n    \"inflationMax\": \"200000000000000000\",\n    \"inflationMin\": \"70000000000000000\",\n    \"goalBonded\": \"670000000000000000\",\n    \"blocksPerYear\": \"6311520\"\n  }\n}\n</code></pre>"},{"location":"mint/#rest","title":"REST","text":"<p>A user can query the <code>mint</code> module using REST endpoints.</p>"},{"location":"mint/#annual-provisions_1","title":"annual-provisions","text":"<pre><code>/cosmos/mint/v1beta1/annual_provisions\n</code></pre> <p>Example:</p> <pre><code>curl \"localhost:1317/cosmos/mint/v1beta1/annual_provisions\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"annualProvisions\": \"1432452520532626265712995618\"\n}\n</code></pre>"},{"location":"mint/#inflation_2","title":"inflation","text":"<pre><code>/cosmos/mint/v1beta1/inflation\n</code></pre> <p>Example:</p> <pre><code>curl \"localhost:1317/cosmos/mint/v1beta1/inflation\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"inflation\": \"130197115720711261\"\n}\n</code></pre>"},{"location":"mint/#params_3","title":"params","text":"<pre><code>/cosmos/mint/v1beta1/params\n</code></pre> <p>Example:</p> <pre><code>curl \"localhost:1317/cosmos/mint/v1beta1/params\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"params\": {\n    \"mintDenom\": \"stake\",\n    \"inflationRateChange\": \"130000000000000000\",\n    \"inflationMax\": \"200000000000000000\",\n    \"inflationMin\": \"70000000000000000\",\n    \"goalBonded\": \"670000000000000000\",\n    \"blocksPerYear\": \"6311520\"\n  }\n}\n</code></pre>"},{"location":"modules_accounts/","title":"module account","text":"<p>Some modules have their own module accounts. Think of it as a wallet that can only be controlled by this module. Below is a table of modules, their respective wallet addresses and permissions:</p>"},{"location":"modules_accounts/#list-of-module-accounts","title":"List of module accounts","text":"Name Address Permissions <code>claims</code> dst15cvq3ljql6utxseh0zau9m8ve2j8erz89m5wkz <code>none</code> <code>erc20</code> dst1glht96kr2rseywuvhhay894qw7ekuc4qg9z5nw <code>minter</code> <code>burner</code> <code>fee_collector</code> dst17xpfvakm2amg962yls6f84z3kell8c5ljcjw34 <code>none</code> <code>incentives</code> dst1krxwf5e308jmclyhfd9u92kp369l083wn67k4q <code>minter</code> <code>burner</code> <code>inflation</code> dst1d4e35hk3gk4k6t5gh02dcm923z8ck86qygxf38 <code>minter</code> <code>transfer</code> dst1yl6hdjhmkf37639730gffanpzndzdpmhv788dt <code>minter</code> <code>burner</code> <code>bonded_tokens_pool</code> dst1fl48vsnmsdzcv85q5d2q4z5ajdha8yu3h6cprl <code>burner</code> <code>staking</code> <code>not_bonded_tokens_pool</code> dst1tygms3xhhs3yv487phx3dw4a95jn7t7lr6ys4t <code>burner</code> <code>staking</code> <code>gov</code> dst10d07y265gmmuvt4z0w9aw880jnsr700jcrztvm <code>burner</code> <code>distribution</code> dst1jv65s3grqf6v6jl3dp4t6c9t9rk99cd8974jnh] <code>none</code> <code>evm</code> dst1vqu8rska6swzdmnhf90zuv0xmelej4lq0n56wq <code>minter</code> <code>burner</code> <code>ibc</code> dst1a53udazy8ayufvy0s434pfwjcedzqv345dnt3x <code>minter</code> <code>burner</code> <code>chat</code> dst1x8sx7lvfl6ue5rnvptl7rxr53samt0h4zxqkwg <code>minter</code> <code>burner</code> <code>chat_burn</code> dst1g7z9fjg8zyrj68a6rtqkfgldvjjjc3n7sucath <code>burner</code> <code>gateway</code> dst1f6j7u6875p2cvyrgjr0d2uecyzah0kgexwhr3g <code>none</code> <code>pledge</code> dst1nhta6gsf9x9l2pd2m5qg6lya0h3m0pjy4vtd35 <code>minter</code> <code>burner</code> <code>contract</code> dst1ejpjr43ht3y56pplm5pxpusmcrk9rkkvevc88d <code>none</code> <code>stakeContractDeploy</code> dst16vxjegtg3k5fvqcc55yd6cele9hx0nhv3lxzf0 <code>none</code> <code>tokenFactoryContractDeploy</code> dst10dkh3rvhgcj2vj4h36msncnkr5ps668x9uuva0 <code>none</code>"},{"location":"modules_accounts/#account-permissions","title":"Account Permissions","text":"<ul> <li><code>burner</code> authority means that the account has the authority to burn or burn tokens.</li> <li>The <code>minter</code> permission indicates that this account has permission to mint or create new tokens.</li> <li>The <code>staking</code> permission means that the account has the right to stake tokens on behalf of its owner.</li> </ul>"},{"location":"modules_accounts/#ibc-module-account","title":"IBC module account","text":"<p>Additionally, there are module accounts associated with IBC transfers. For each IBC connection, there is an account of type <code>ModuleAccount</code>, which is used to host the transferred coins when Daodst is the source chain. Their address is derived using the first 20 bytes of the SHA256 checksum of the account name, following ADR 028:</p> <pre><code>// accountName is composed by the current version the IBC tranfer module supports (in this case, ics20-1), the portID (transfer) and the channelID\naccountName := Version + \"\\0\" + portID + \"/\" + channelID\naddr := sha256.Sum256(accountName)[:20]\n\n// example for channel-0\naddr := sha256.Sum256(\"ics20-1\\0transfer/channel-0\")[:20]\n</code></pre> <p>This can be done using the <code>GetEscrowAccount</code> function on IBC-go.</p> <p>\ud83d\udce3 Tip : These hosting accounts are not listed when executing the query:</p> <pre><code>stcd q auth module-accounts\n</code></pre> <p>This happens because the <code>GetModuleAccount</code> function used in the query only Consider accounts on <code>permAddrs</code> map of <code>AccountKeeper</code>.</p> <p>This address mapping is set at compile time and cannot be changed at runtime.</p>"},{"location":"pc/","title":"Instructions for use on the PC side","text":""},{"location":"pc/#install","title":"install","text":"<pre><code>Open the installation package, jump out of the following interface, click OK (some antivirus software will falsely report)\n</code></pre> <pre><code>Select the installation directory (recommended to be larger than 1TB)\n</code></pre> <pre><code>Wait patiently for the installation to complete\n</code></pre>"},{"location":"pc/#process","title":"process","text":"<pre><code>Create or import wallet address --&gt; create dpos --&gt; create gateway --&gt; pledge FM --&gt; receive rewards\n</code></pre>"},{"location":"pc/#new-wallet","title":"new wallet","text":""},{"location":"pc/#import-wallet","title":"import wallet","text":""},{"location":"pc/#create-validator","title":"create validator","text":""},{"location":"pc/#create-gateway","title":"create gateway","text":""},{"location":"pc/#pledge-fm","title":"Pledge FM","text":""},{"location":"pc/#receive-award","title":"Receive award","text":""},{"location":"pc/#front-page","title":"front page","text":"<pre><code>The home page contains some global views and functions\n These include:\n\n\nView block synchronization (top right of the interface)\n</code></pre> <pre><code>View task status (upper right corner of interface)\n</code></pre> <pre><code>Management software settings (bottom left corner of the interface)\n</code></pre>"},{"location":"pc/#actions","title":"Actions","text":"<pre><code>The Actions in the upper right corner can manage DID and modify gateway information\n</code></pre>"},{"location":"pc/#did-segment-management","title":"DID segment management","text":"<pre><code>More DID numbers can be obtained by staking FM\n</code></pre> <pre><code>Select the line on the left side of the homepage, including two tabs for assets and gateways\n</code></pre>"},{"location":"pc/#property","title":"Property","text":"<pre><code>Asset interface management includes balance, transfer, transaction records, and account management\n\nThe three buttons on the left correspond to the three main coins of DST, FM and HASH respectively\n</code></pre> <pre><code>On the right side, you can view the balance quantity, transaction records, and send and receive the main currency\n</code></pre> <pre><code>Here export the mnemonic and change the password\n</code></pre>"},{"location":"pc/#gateway","title":"gateway","text":"<pre><code>Gateway function management dpos pledge, gateway server, gateway app, gateway key, etc.\n</code></pre>"},{"location":"pc/#dpos-pledge-management","title":"DPOS pledge management","text":"<pre><code>After becoming a validator, you can check the DPOS status of this node on the _DPOS pledge management_ page\n\nAvailable for pledge and redemption\n</code></pre> <pre><code>The redemption of DPOS is not immediately received, check the redemption status here\n</code></pre> <pre><code>Can view and claim staking rewards and commissions\n</code></pre> <pre><code>Modify the settings of the gateway here\n</code></pre>"},{"location":"pc/#gateway-server-resources","title":"Gateway server resources","text":""},{"location":"pc/#gateway-app","title":"gateway app","text":""},{"location":"pc/#gateway-key","title":"gateway key","text":"<pre><code>For details on how to use the gateway key, see\n</code></pre>"},{"location":"pc/#how-to-use-the-gateway-key","title":"How to use the gateway key","text":""},{"location":"pc/#setting-method","title":"Setting method","text":"<pre><code>Settings include: version detection, language detection, history clearing settings, node settings, data directory settings, routing layer detection\n</code></pre>"},{"location":"pledge/","title":"Pledge","text":""},{"location":"pledge/#abstract","title":"Abstract","text":"<p>This module is responsible for the pledge, destruction, and reward parts related to DaoDst</p>"},{"location":"pledge/#contents","title":"Contents","text":"<ol> <li>Concepts</li> <li>Messages</li> <li>Parameters</li> </ol> <pre><code>chat/\n\u251c\u2500\u2500 client\n\u2502   \u2514\u2500\u2500 rest\n\u2502        \u251c\u2500\u2500 error.go          # Interface error set\n\u2502        \u251c\u2500\u2500 grpc.go           # GRPC inquiry method\n\u2502        \u251c\u2500\u2500 handle_pledge.go # Pledge module message preprocessing\n\u2502        \u251c\u2500\u2500 query.go          # Interface query function\n\u2502        \u251c\u2500\u2500 rest.go           # Registration of Message and Query Routes\n\u2502        \u2514\u2500\u2500 tx.go             # Tx related methods, including broadcasting, etc\n\u251c\u2500\u2500 keeper\n\u2502   \u251c\u2500\u2500 genesis.go        # Module State and Export\n\u2502   \u251c\u2500\u2500 keeper.go         # Store keeper that handles the business logic of the module and has access to a specific subtree of the state tree.\n\u2502   \u251c\u2500\u2500 msg_server.go     # Provide message service processing logic\n\u2502   \u251c\u2500\u2500 params.go         # Parameter getter and setter\n\u2502   \u251c\u2500\u2500 query.go          # State query functions\n\u2502   \u251c\u2500\u2500 medal.go          # Logic algorithms related to hash coin pledge calculation\n\u2502   \u2514\u2500\u2500 mingkeeper.go     # Logic Algorithm for Foundry Additional Issuance\n\u251c\u2500\u2500 types\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codec.go          # Type registration for encoding\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 errors.go         # Module-specific errors\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 events.go         # Events exposed to the Tendermint PubSub/Websocket\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 genesis.go        # Genesis state for the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 interface.go      # Interface of the module\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 keys.go           # Store keys and utility functions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 msg.go            # Pledge module transaction messages\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 params.go         # Module parameters that can be customized with governance parameter change proposals\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 types.go          # Type collection of modules\n\u251c\u2500\u2500 genesis.go            # ABCI InitGenesis and ExportGenesis functionality\n\u251c\u2500\u2500 handler.go            # Message routing\n\u2514\u2500\u2500 module.go             # Module setup for the module manager\n</code></pre>"},{"location":"pledge/#concepts","title":"Concepts","text":""},{"location":"pledge/#pledge","title":"Pledge","text":"<pre><code>The pledge module is responsible for the pledge and destruction of DaoDST\n</code></pre>"},{"location":"pledge/#dst-hash","title":"DST &amp; HASH","text":"<pre><code>Users can obtain hash tokens by destroying the dst pipeline, while pledging the hash to continuously obtain and select dst rewards at any time,\nAfter reaching a certain level, the hash can be redeemed and traded\n</code></pre>"},{"location":"pledge/#hash","title":"HASH","text":"<pre><code>When registering for a chat, it is necessary to destroy a certain amount of dsts and exchange them for hashes according to the calculation. The obtained hashes will be automatically pledged, and according to the rules, each block will receive a reward (dst)\nThe redemption and trading of hash requires reaching a certain level of free mason\n</code></pre>"},{"location":"pledge/#freemason-level","title":"Freemason level","text":"<pre><code>There are some benefits to increasing the level of Freemason, such as unlocking the redemption and trading of hashes, increasing the proportion of hashes obtained by destroying dsts, unlocking more chat rooms, and increasing online storage space for chats.\nThe free mason level is linked to the hash pledge amount, and the relationship between the hash pledge amount and level can be changed through voting\n</code></pre>"},{"location":"pledge/#hash-transfer","title":"HASH transfer","text":"<pre><code>Hash transfers will charge more gas, approximately 10000 times that of regular transfers\n</code></pre>"},{"location":"pledge/#destroy-dst","title":"Destroy DST","text":"<pre><code>When destroying DSTs, additional rewards (dsts) will be issued to the registered and current gateways based on the amount of destruction, as well as additional rewards to the miners\n\nThe calculation for exchanging DST for HASH is as follows\n\nDestruction amount/(DST reward issuance amount on the same day/cumulative network HASH acquisition amount)=number of HASH obtained\n</code></pre>"},{"location":"pledge/#pledge-hash","title":"Pledge HASH","text":"<pre><code>Pledging HASH can continuously earn DST rewards\n\nDST will issue additional shares every time a block is issued, and users will receive dst rewards based on the hash pledge proportion\n\nThe calculation of the number of additional issues for each block of dst is as follows\n\nBlock inflation=\uff08\uff080.35-Quantity destroyed in the last 100 days\uff09/ 0.35 *\uff08Maximum inflation rate3.65 -Minimum inflation rate1.21\uff09+Minimum inflation rate1.21\uff09/Number of blocks produced per year5259600\n</code></pre>"},{"location":"pledge/#keeper","title":"Keeper","text":"<p>The Chat module <code>Keeper</code> grants access to the Chat module state and implements <code>statedb.Keeper</code> interface to support the <code>StateDB</code> implementation. The Keeper contains a store key that allows the DB to write to a concrete subtree of the multistore that is only accessible by the Chat module. Instead of using a trie and database for querying and persistence (the <code>StateDB</code> implementation), Daodst uses the Cosmos <code>KVStore</code> (key-value store) and Cosmos SDK <code>Keeper</code> to facilitate state transitions.</p> <p>To support the interface functionality, it imports 4 module Keepers:</p> <ul> <li><code>auth</code>: CURD for accounts</li> <li><code>bank</code>: CURD for supply and balance</li> <li><code>comm</code>: Management of gateway related data</li> <li><code>chat</code>: Management of chat data</li> </ul> <pre><code>type Keeper struct {\n    storeKey   sdk.StoreKey\n    cdc        codec.BinaryCodec\n    paramstore paramtypes.Subspace\n\n    hooks            types.PledgeHooks\n    AccountKeeper    types.AccountKeeper\n    BankKeeper       types.BankKeeper\n    CommKeeper       types.CommKeeper\n    ChatKeeper       types.ChatKeeper\n    FeeCollectorName string\n}\n\n</code></pre>"},{"location":"pledge/#messages","title":"Messages","text":""},{"location":"pledge/#msgpledge","title":"MsgPledge","text":"<pre><code>Initiate the destruction of dst through this message\n</code></pre> <pre><code>    type MsgPledge struct {\n        FromAddress      string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        DelegatorAddress string     `protobuf:\"bytes,2,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        ValidatorAddress string     `protobuf:\"bytes,3,opt,name=validator_address,json=validatorAddress,proto3\" json:\"validator_address,omitempty\" yaml:\"validator_address\"`\n        Amount           types.Coin `protobuf:\"bytes,4,opt,name=amount,proto3\" json:\"amount\"`\n    }\n</code></pre>"},{"location":"pledge/#msgwithdrawdelegatorreward","title":"MsgWithdrawDelegatorReward","text":"<pre><code>Through this message, select the dst reward for pledge hash\n</code></pre> <pre><code>    type MsgWithdrawDelegatorReward struct {\n        DelegatorAddress string `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n    }\n</code></pre>"},{"location":"pledge/#msgunpledge","title":"MsgUnpledge","text":"<pre><code>Through this message, redeem the pledged hash\n</code></pre> <pre><code>    type MsgUnpledge struct {\n        DelegatorAddress string     `protobuf:\"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3\" json:\"delegator_address,omitempty\" yaml:\"delegator_address\"`\n        Amount           types.Coin `protobuf:\"bytes,2,opt,name=amount,proto3\" json:\"amount\"`\n    }\n</code></pre>"},{"location":"pledge/#msgburngetmedal","title":"MsgBurnGetMedal","text":"<pre><code>Destroy dst to obtain Hash\n</code></pre> <pre><code>    type MsgBurnGetMedal struct {\n        FromAddress string     `protobuf:\"bytes,1,opt,name=from_address,json=fromAddress,proto3\" json:\"from_address,omitempty\" yaml:\"from_address\"`\n        ToAddress   string     `protobuf:\"bytes,2,opt,name=to_address,json=toAddress,proto3\" json:\"to_address,omitempty\" yaml:\"to_address\"`\n        Gateway     string     `protobuf:\"bytes,3,opt,name=gateway,proto3\" json:\"gateway,omitempty\" yaml:\"gateway\"`\n        BurnCoin    types.Coin `protobuf:\"bytes,4,opt,name=burn_coin,json=burnCoin,proto3\" json:\"burn_coin\" yaml:\"burn_coin\"`\n    }\n</code></pre>"},{"location":"pledge/#parameters","title":"Parameters","text":"<p>The pledge module contains the following module parameters</p>"},{"location":"pledge/#params","title":"Params","text":"Key Type Default Value <code>KeyInflationDays</code> int64 <code>100</code> <code>InflationMax</code> github_com_cosmos_cosmos_sdk_types.Dec <code>3.65</code> <code>InflationMin</code> github_com_cosmos_cosmos_sdk_types.Dec <code>1.21</code> <code>GoalBonded</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.35</code> <code>BlocksPerYear</code> uint64 <code>5259600</code> <code>UnbondingHeight</code> int64 <code>302400</code> <code>MinBurnCoin</code> github_com_cosmos_cosmos_sdk_types.Coin <code>100000000000000000000dst</code> <code>BurnCurrentGatePercent</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>BurnRegisterGatePercent</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>BurnDposPercent</code> github_com_cosmos_cosmos_sdk_types.Dec <code>0.1</code> <code>BurnReturnDays</code> int64 <code>120</code> <code>BurnLevels</code> []BurnLevel"},{"location":"pledge/#burnlevels","title":"BurnLevels","text":"<p>BurnLevels defines the relevant benefits that can be enjoyed by a free mason level, including three types of benefits</p> <ol> <li>The ratio of destroying dst to hash</li> <li>Chat storage space</li> <li>The number of chat room unlocked</li> </ol> Level MedalAmount AddPercent RoomAmount <code>1</code> <code>100</code> <code>1</code> <code>0</code> <code>2</code> <code>200</code> <code>2</code> <code>0</code> <code>3</code> <code>400</code> <code>3</code> <code>0</code> <code>4</code> <code>800</code> <code>4</code> <code>0</code> <code>5</code> <code>1600</code> <code>5</code> <code>1</code> <code>6</code> <code>3200</code> <code>6</code> <code>2</code> <code>7</code> <code>6400</code> <code>7</code> <code>3</code> <code>8</code> <code>12800</code> <code>8</code> <code>4</code> <code>9</code> <code>25600</code> <code>9</code> <code>5</code> <code>10</code> <code>51200</code> <code>12</code> <code>6</code> <code>11</code> <code>102400</code> <code>15</code> <code>7</code> <code>12</code> <code>204800</code> <code>18</code> <code>8</code> <code>13</code> <code>409600</code> <code>21</code> <code>9</code> <code>14</code> <code>819200</code> <code>24</code> <code>10</code> <code>15</code> <code>1638400</code> <code>27</code> <code>11</code> <code>16</code> <code>3276800</code> <code>30</code> <code>12</code> <code>17</code> <code>6553600</code> <code>33</code> <code>13</code> <code>18</code> <code>13107200</code> <code>36</code> <code>14</code> <code>19</code> <code>26214400</code> <code>39</code> <code>15</code> <code>20</code> <code>52428800</code> <code>43</code> <code>16</code> <code>21</code> <code>104857600</code> <code>47</code> <code>17</code> <code>22</code> <code>209715200</code> <code>51</code> <code>18</code> <code>23</code> <code>419430400</code> <code>55</code> <code>19</code> <code>24</code> <code>838860800</code> <code>59</code> <code>20</code> <code>25</code> <code>1677721600</code> <code>63</code> <code>21</code> <code>26</code> <code>3355443200</code> <code>67</code> <code>22</code> <code>27</code> <code>6710886400</code> <code>71</code> <code>23</code> <code>28</code> <code>13421772800</code> <code>75</code> <code>24</code> <code>29</code> <code>26843545600</code> <code>79</code> <code>25</code> <code>30</code> <code>53687091200</code> <code>84</code> <code>26</code> <code>31</code> <code>107374182400</code> <code>89</code> <code>27</code> <code>32</code> <code>214748364800</code> <code>94</code> <code>28</code> <code>33</code> <code>429496729600</code> <code>100</code> <code>29</code>"},{"location":"protocol/","title":"Protocol","text":""},{"location":"protocol/#account","title":"account","text":"<p>Crypto wallets (or accounts) can be created and represented in unique ways on different blockchains. For developers interacting with account types on Daodst, during wallet integration on their dApp frontend, it is important to understand that accounts on Daodst are implemented to be compatible with Ethereum type addresses.</p>"},{"location":"protocol/#create-an-account","title":"Create an account","text":"<p>To create an account, you create a private key, a keystore file (a password-protected private key), or a seed phrase (a string of words that gives access to multiple private keys).</p> <p>Besides having different security features, the biggest difference between them is that the private key or keystore file only creates an account. Creating a seed phrase can give you control over many accounts, all of which can be accessed using the same phrase.</p> <p>The Cosmos blockchain, like Daodst, supports account creation using mnemonic phrases, also known as Hierarchical Deterministic Key Generation (HD Keys). This allows users to create accounts on multiple blockchains without having to manage multiple keys.</p> <p>HD keys generate addresses by taking a mnemonic phrase and combining it with a piece of information called a derivation path. Blockchains can differ in the derivation paths they support. Therefore, to access all accounts via a mnemonic phrase on a blockchain, it is important to use a specific derivation path for that blockchain.</p>"},{"location":"protocol/#agent-account","title":"Agent Account","text":"<p>The terms \"account\" and \"address\" are often used interchangeably to describe crypto wallets. In the Cosmos SDK, an account specifies a pair of public key (PubKey) and private key (PrivKey). Derivation paths define private keys, public keys, and addresses.</p> <p>A PubKey can be derived to generate various addresses in different formats, which are used to identify users (among other parties) within the application. A common address form for Cosmos chains is the bech32 format (e.g. dst1 ...). Addresses are also associated with messages to identify the sender of the message.</p> <p>A PrivKey is used to generate a digital signature attesting that the address associated with the PrivKey approves a given message. Attestation is performed by applying a cryptographic scheme called the Elliptic Curve Digital Signature Algorithm (ECDSA) to the PrivKey to generate a public key that is compared to the address in the message.</p>"},{"location":"protocol/#daodst-account","title":"Daodst Account","text":"<p>Daodst defines its own custom account type to implement HD wallets compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve as the key (eth_secp265k1) and satisfies the full BIP44 path of EIP84. Do not confuse this cryptographic curve with Bitcoin's ECDSA secp256k1 curve.</p> <p>The root HD path for Daodst based accounts is <code>m/44'/60'/0'/0</code>. Daodst uses Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains which use Coin type 118 (list of coin types</p> <p>The custom Daodst EthAccount satisfies the AccountI interface from the Cosmos SDK authentication module and contains additional fields required for Ethereum type addresses:</p> <pre><code>// EthAccountI represents the interface of an EVM compatible account\ntype EthAccountI interface {\n    authtypes.AccountI\n    // EthAddress returns the ethereum Address representation of the AccAddress\n    EthAddress() common.Address\n    // CodeHash is the keccak256 hash of the contract code (if any)\n    GetCodeHash() common.Hash\n    // SetCodeHash sets the code hash to the account fields\n    SetCodeHash(code common.Hash) error\n    // Type returns the type of Ethereum Account (EOA or Contract)\n    Type() int8\n}\n</code></pre>"},{"location":"protocol/#address-and-public-key","title":"address and public key","text":"<p>BIP-0173 defines a new format for Segregated Witness output addresses that includes a human-readable portion identifying Bech32 usage. Daodst uses the following HRPs (human-readable prefixes) as base HRPs:</p> Network Mainnet Testnet daodst daodst daodst <p>There are 3 main types of HRP for addresses/public keys available by default on Daodst:</p> <ul> <li>The account's address and key, which identify the user (such as the sender of a message). They are derived using the eth_secp256k1 curve.</li> <li>The validator operator's address and key, used to identify the validator's operator. They are derived using the eth_secp256k1 curve.</li> <li>The address and key of the consensus node, used to identify the verification nodes participating in the consensus. They are derived using the ed25519 curve</li> </ul> Name bech32 address prefix bech32 public key prefix curve address byte length public key byte length account dst dstpub eth_secp256k1 20 33(compressed) validator operation dstvaloper dstvaloperpub eth_secp256k1 20 33(compressed) consensus node dstvalcons dstvalconspub ed25519 dst 32"},{"location":"protocol/#customer-address-format","title":"Customer address format","text":"<p>Eth account number can be represented in Bech32 (dst1...) and hexadecimal (0x...) formats for Ethereum's Web3 tools compatibility.</p> <p>The Bech32 format is the default format for Cosmos-SDK queries and transactions via CLI and REST clients. On the other hand, the hexadecimal format is Ethereum common.Address represents Cosmos sdk.AccAddress.</p> <ul> <li>Address (Bech32): <code>dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw</code></li> <li>Address (EIP55 hexadecimal): <code>0x91defC7fE5603DFA8CC9B655cF5772459BF10c6f</code></li> <li>Compress public key: <code>{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}</code></li> </ul>"},{"location":"protocol/#address-translation","title":"address translation","text":"<p>stcd debug addr  can be used to convert addresses between hexadecimal and bech32 formats. For example: Bech32 <pre><code> $ stcd debug addr dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n  Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n  Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n  Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n  Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre> <p>Hex</p> <pre><code> $ stcd debug addr 14574A6DFF2DDF9E07828B4345D3040919AF5652\n  Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n  Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n  Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n  Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre>"},{"location":"protocol/#key-export","title":"Key export","text":"<p>We can use stcd's keys show command with flags --bech  (acc|val|cons) to get addresses and keys, as described above, <p>Ordinary account</p> <pre><code>  $ stcd keys show dev0 --bech acc\n- name: dev0\n   type: local\n   address: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>validator</p> <pre><code>  $ stcd keys show dev0 --bech val\n- name: dev0\n   type: local\n   address: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>consensus</p> <pre><code>  $ stcd keys show dev0 --bech cons\n- name: dev0\n   type: local\n   address: dstvalcons1rllqa5d97n6zyjhy6cnscc7zu30zjn3f7wyj2n\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"A/fVLgIqiLykFQxum96JkSOoTemrXD0tFaFQ1B0cpB2c\"}'\n   mnemonic: \"\"\n</code></pre>"},{"location":"protocol/#account-query","title":"Account Query","text":"<p>You can use CLI, gRPC or</p> <p>command line interface</p> <pre><code># NOTE: the --output (-o) flag will define the output format in JSON or YAML (text)\nstcd q auth account $(stcd keys show dev0 -a) -o text\n\n'@type': /ethermint.types.v1.EthAccount\nbase_account:\naccount_number: \"0\"\naddress: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\npub_key:\n  '@type': /ethermint.crypto.v1.ethsecp256k1.PubKey\n  key: AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\nsequence: \"1\"\ncode_hash: 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n</code></pre> <p>Cosmos gRPC and REST</p> <pre><code># GET /cosmos/auth/v1beta1/accounts/{address}\ncurl -X GET \"http://localhost:10337/cosmos/auth/v1beta1/accounts/dst14au322k9munkmx5wrchz9q30juf5wjgz2cfqku\" -H \"accept: application/json\"\n</code></pre> <p>JSON-RPC To retrieve Ethereum hex addresses using Web3, use the JSON-RPC eth_accounts or personal_listAccounts endpoints</p> <pre><code># query against a local node\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"personal_listAccounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n</code></pre>"},{"location":"protocol/#chain-id","title":"Chain ID","text":"<p>A chain ID is a unique identifier that represents a blockchain network. We use it to differentiate between different blockchain networks and ensure transactions and messages are sent to the correct network. The Daodst network follows the format of identifier_EIP155-version.</p>"},{"location":"protocol/#mainnet","title":"Mainnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst2 <code>daodst_7001-2</code> dst 7002 2 yes Daodst1 <code>daodst_7001-1</code> dst 7001 1 no"},{"location":"protocol/#testnet","title":"testnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst Public Testnet <code>daodst_7000-2</code> dst 7000 2 yes Daodst Public Testnet <code>daodst_7000-1</code> dst 7000 1 no"},{"location":"protocol/#chain-identity","title":"Chain identity","text":"<p>Every chain must have a unique identifier or <code>chain-id</code>. Tendermint requires each application to define its own <code>chain-id</code> in the genesis.json fields. However, in order to comply with both EIP155 and the Cosmos chain upgrade standard, Daodst-compatible chains must implement a special structure for their chain identifiers.</p> <p>*** Structure ***</p> <p>The Daodst chain ID consists of 3 main components</p> <ul> <li>Identifier: An unstructured string defining the name of the application.</li> <li>EIP155 Number: Immutable EIP155 <code>CHAIN_ID</code>   Defines the number of replay attack protections.</li> <li>version number: is the version number of the chain currently running (always a positive number). This number MUST be incremented every time the chain is upgraded or forked to avoid network or consensus errors.</li> </ul> <p>***  Format ***</p> <p>The format of the Daodst-compatible chain-id specified in genesis is as follows:</p> <pre><code>{identifier}_{EIP155}-{version}\n</code></pre> <p>The following table provides an example, where the second row corresponds to an upgrade of the first row:</p> ChainID Identifier EIP155 Number Version Number <code>daodst_7000-1</code> dst 7000 1 <code>daodst_7000-2</code> dst 7000 2 <code>...</code> ... ... ... <code>daodst_7000-N</code> dst 7000 N"},{"location":"protocol/#encoding","title":"encoding","text":"<p>Encoding refers to the process of converting data from one format to another to make it more secure and efficient.</p> <p>In the context of blockchain, encoding is used to ensure that data is stored and transmitted in a secure and easily accessible manner.</p> <p>Recursive Length Prefix (RLP) is a serialization format widely used in Ethereum execution clients.</p> <p>Its purpose is to encode arbitrarily nested arrays of binary data, and is the primary encoding used to serialize objects in Ethereum.</p> <p>RLP only encodes structures, leaving the encoding of specific atomic data types (such as strings, integers, and floats) to higher-level protocols.</p> <p>In Ethereum, integers must be represented in big-endian binary form without leading zeros, such that an integer value of zero is equivalent to an empty byte array.</p> <p>The RLP encoding function accepts an item, which is defined as a single byte with a value in the range [0x00, 0x7f] or a string 0-55 bytes long.</p> <p>If the string is longer than 55 bytes, the RLP encoding contains a byte with the value 0xb7 (dec.183) plus the length The length of the string in bytes in binary, followed by the length of the string, followed by the string.</p> <p>RLP is used for hash verification, where a transaction is signed by signing the RLP hash of the transaction data, and a block is identified by the RLP hash of its header.</p> <p>RLP is also used to encode data over networks, and in some cases should support efficient encoding of Merkle tree data structures.</p> <p>The Ethereum execution layer uses RLP as the primary encoding for serializing objects, but the newer Simple Serialize (SSZ) replaces RLP as the encoding for the new consensus layer in Ethereum 2.0.</p> <p>The Cosmos Stargate release introduced protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients, such as transaction messages, genesis, query services, etc., will be implemented as protocol buffer messages.</p> <p>The Cosmos SDK also supports traditional Amino encoding.</p> <p>Protocol Buffers (protobuf) is a language-independent binary serialization format that is smaller and faster than JSON.</p> <p>It is used to serialize structured data, such as messages, and is designed to be efficient and scalable.</p> <p>The encoding format is defined in a language-independent language called Protocol Buffers Language (proto3), and encoded messages can be used to generate code for various programming languages.</p> <p>The main advantage of protobuf is its efficiency, which results in smaller message sizes and faster serialization and deserialization times.</p> <p>The RLP decoding process is as follows: decode the data type, actual data length and offset according to the first byte of the input data (that is, the prefix); decode the data accordingly according to the data type and offset.</p>"},{"location":"protocol/#prerequisites-reading","title":"Prerequisites Reading","text":"<ul> <li>Cosmos SDK Encoding</li> <li>Ethereum RLP</li> </ul>"},{"location":"protocol/#encoding-format","title":"Encoding format","text":"<p>*** Protocol Buffers ***</p> <p>The Cosmos Stargate release introduces protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients (transaction messages, genesis, query services, etc.) will be implemented as protocol buffer messages.</p> <p>*** Amino ***</p> <p>The Cosmos SDK also supports the legacy Amino encoding format for backward compatibility with previous versions, especially for client-side encoding and signing with Ledger devices.</p> <p>Daodst does not support Amino in the EVM module, but all other Cosmos SDK modules that enable it support it.</p> <p>*** RLP ***</p> <p>Recursive Length Prefix (RLP) is an encoding/decoding algorithm that serializes messages and allows fast reconstruction of encoded data.</p> <p>Daodst uses RLP to encode/decode Ethereum messages for JSON-RPC processing so that messages conform to the correct Ethereum format. This allows messages to be encoded and decoded in the exact same format as Ethereum's.</p> <p><code>x/evm</code> transaction (<code>MsgEthereumTx</code>) encoding is performed by converting the message to go-ethereum's <code>Transaction</code> and then using RLP to marshal the transaction data:</p> <pre><code>// TxEncoder overwrites sdk.TxEncoder to support MsgEthereumTx\nfunc (g txConfig) TxEncoder() sdk.TxEncoder {\nreturn func(tx sdk.Tx) ([]byte, error) {\n  msg, ok := tx.(*evmtypes.MsgEthereumTx)\n  if ok {\n    return msg.AsTransaction().MarshalBinary()\n  }\n  return g.TxConfig.TxEncoder()(tx)\n}\n}\n\n// TxDecoder overwrites sdk.TxDecoder to support MsgEthereumTx\nfunc (g txConfig) TxDecoder() sdk.TxDecoder {\nreturn func(txBytes []byte) (sdk.Tx, error) {\n  tx := &amp;ethtypes.Transaction{}\n\n  err := tx.UnmarshalBinary(txBytes)\n  if err == nil {\n    msg := &amp;evmtypes.MsgEthereumTx{}\n    msg.FromEthereumTx(tx)\n    return msg, nil\n  }\n\n  return g.TxConfig.TxDecoder()(txBytes)\n}\n}\n</code></pre>"},{"location":"protocol/#gas-and-handling-fee","title":"Gas and handling fee","text":"<p>Users need to pay fees to submit transactions on the Daodst network. Since fees are handled differently in Ethereum and Cosmos, it is important to understand how the Daodst blockchain implements Ethereum-type fee calculations that are compatible with the Cosmos SDK.</p> <p>Thus, this overview explains the basics of gas calculations, how fees are provided for transactions, and how Ethereum-style fee calculations use the fee market (EIP1559) to prioritize transactions.</p> <p>Also note that fees paid to interact with smart contracts on Daodst can earn revenue for smart contract deployers. For information on this, go to develop.</p> <p>*** Prerequisite Reading ***</p> <ul> <li>Cosmos SDK Gas</li> <li>Ethereum Gas</li> </ul> <p>*** Basics ***</p> <p>*** Why is there a transaction fee? ***</p> <p>If anyone could submit transactions to the network for free, the network could be overwhelmed by a small number of participants sending fraudulent transactions to clog the network and make it non-functional.</p> <p>The solution to this problem is a concept called \"gas\", which is the resource consumed throughout the execution of a transaction.</p> <p>In practice, each step of code execution consumes a small amount of gas, effectively charging validator resource usage and preventing malicious actors from disrupting the network at will.</p> <p>*** What is Gas? ***</p> <p>In general, gas is a unit of measure for the computational intensity of a particular transaction \u2014 in other words, how much work is required to evaluate and execute it.</p> <p>Complex multi-step transactions, such as a Cosmos transaction that delegates to a dozen validators, require more gas than simple single-step transactions (such as a Cosmos transaction that sends tokens to another address).</p> <p>When referring to a transaction, \"gas\" refers to the total amount of gas required for the transaction.</p> <p>For example, a transaction may require 300,000 units of gas to execute.</p> <p>Think of gas as electricity (kWh) in a house or factory, or as fuel for a car.</p> <p>The idea is that it costs some money to get somewhere.</p> <p>More Gas introduction:</p> <ul> <li>Cosmos Gas Fees</li> <li>Cosmos Tx Lifecycle</li> <li>Ethereum Gas</li> </ul> <p>*** How Gas is Calculated ***</p> <p>In general, there is no way to know exactly how much gas a transaction will cost without simply running it.</p> <p>Using the Cosmos SDK, this can be done with Simulating a Tx.</p> <p>Otherwise, there are ways to estimate the gas a transaction will require based on details of the transaction fields and data.</p> <p>For example, in the case of the EVM, each bytecode operation has a corresponding amount of gas.</p> <p>More about Gas calculation:</p> <ul> <li>Estimate Gas</li> <li>Executing EVM Bytecode</li> <li>Simulate a Cosmos SDK Tx</li> </ul> <p>*** What is the relationship between Gas and transaction fee? ***</p> <p>Gas refers to the computational work required to perform it, while the fee refers to the amount of tokens you actually spend to execute the transaction.</p> <p>They are derived using the following formulas:</p> <pre><code>Total Fees = Gas * Gas Price (the price per unit of gas)\n</code></pre> <p>If <code>gas</code> is in kWh, then \"gas price\" will be the rate determined by your energy supplier in USD/kWh, and <code>fees</code> will be your bill.</p> <p>Like electricity, gas prices can fluctuate on a given day, depending on network traffic.</p> <p>More about Gas and Fees:</p> <ul> <li>Cosmos Gas and Fees</li> <li>Ethereum Gas and Fees</li> </ul> <p>*** How does Cosmos handle transaction fees? ***</p> <p>Gas fees in Cosmos are relatively simple. As a user, you specify two fields:</p> <ol> <li>Corresponding to <code>GasLimit</code> of the execution gas limit, defined as <code>GasWanted</code></li> <li>One of <code>Fees</code> or <code>GasPrice</code>, which will be used to specify or calculate the transaction fee</li> </ol> <p>The node will fully consume the provided fee and then start executing the transaction. If the <code>GasLimit</code> is found to be insufficient during execution, the transaction will fail and any changes will be rolled back, the provided fee will not be refunded.</p> <p>Validators of Cosmos SDK-based chains can specify a \"minimum gas price\" that they will enforce when selecting transactions to include in a block.</p> <p>As a result, transactions with insufficient fees will experience delays or fail outright.</p> <p>At the beginning of each block, the previous block's fees are distributed to validators and delegators, after which they can be withdrawn and spent.</p> <p>*** How are fees handled on Ethereum? ***</p> <p>Ethereum fees include multiple implementations introduced over time.</p> <p>Initially, the user will specify the <code>GasPrice</code> and <code>GasLimit</code> in the transaction - much like a Cosmos SDK transaction.</p> <p>Block proposers will receive the full gas fee from each transaction in the block, and they will choose which transactions to include accordingly.</p> <p>With the proposal EIP-1559 and the London hard fork, the gas calculation has changed.</p> <p>The above <code>GasPrice</code> is now split into two separate parts: <code>BaseFee</code> and <code>PriorityFee</code>.</p> <p><code>BaseFee</code> is automatically calculated based on the block size and will be destroyed once the block is mined.</p> <p><code>PriorityFee</code> is given to the proposer and represents a tip, or incentive for the proposer to include the transaction in a block.</p> <pre><code>Gas Price = Base Fee + Priority Fee\n</code></pre> <p>In a transaction, in addition to specifying a <code>gas_limit</code> as before, the user can specify a <code>max_fee_per_gas</code> corresponding to the total <code>GasPrice</code> and a <code>max_priority_fee_per_gas</code> corresponding to the maximum <code>PriorityFee</code>.</p> <p>All excess gas not required for execution is returned to the user.</p> <p>More about Ethereum fees:</p> <ul> <li>Gas Calculation Docs</li> <li>Proposal EIP-1559</li> </ul> <p>*** Implementation ***</p> <p>*** How to deal with Gas and transaction fees on Daodst? ***</p> <p>Fundamentally, Daodst is a Cosmos SDK chain that enables EVM compatibility as part of the Cosmos SDK module. Due to this architecture, all EVM transactions are ultimately encoded as Cosmos SDK transactions and update the state managed by the Cosmos SDK. Since all transactions are represented as Cosmos SDK transactions, transaction fees can be at different execution layers.</p> <p>In fact, processing fees include standard Cosmos SDK logic, some Ethereum logic, and customDaodst logic. In most cases, fees are collected by the <code>fee_collector</code> module and then paid to validators and delegators. Some key differences are as follows:</p> <ol> <li>Fee market module</li> </ol> <p>To support EIP-1559 gas and fee calculations on Daodst' EVM layer, Daodst tracks the gas supplied for each block and uses it to calculate base fees for future EVM transactions, enabling EIP-specified EVM dynamic fees and transaction prioritization Level -1559.</p> <p>For EVM transactions, each node bypasses its local <code>min-gas-prices</code> configuration and instead applies EIP-1559 fee logic - the gas price must simply be greater than the global <code>min-gas-price</code> and the block's <code>BaseFee</code>, the remainder is considered the priority tip.</p> <p>This allows validators to calculate Ethereum fees without applying the Cosmos SDK fee logic.</p> <p>Unlike Ethereum, the \"BaseFee\" on Daodst is not destroyed, but distributed to validators and delegators</p> <p>Additionally, <code>BaseFee</code> is bounded by the global <code>min-gas-price</code> (currently, the global <code>min-gas-price</code> parameter is set to zero, although it can be updated via governance).</p> <ol> <li>EVM Gas return</li> </ol> <p>Daodst refunds a small portion (at least 50% by default) of unspent gas for EVM transactions to approximate the current behavior on Ethereum.</p> <ol> <li>Revenue module</li> </ol> <p>Daodst develops the revenue module as a way to reward developers for creating useful dApps - any contract that registers with the Daodst revenue module rewards the contract developer with a small portion of transaction fees (currently 95% ). Validators and delegators earn the remainder.</p> <p>*** Detailed Schedule ***</p> <ol> <li> <p>The node executes the previous block and runs the <code>EndBlock</code> hook * As part of this hook, the FeeMarket (EIP-1559) module tracks the total <code>TransientGasWanted</code> from transactions on that block.    This will be used for the <code>BaseFee</code> of the next block.</p> </li> <li> <p>Nodes receive transactions for subsequent blocks and gossip about these transactions to their peers *These can be sorted and prioritized by included fee price (EVM transactions using EIP-1559 fee priority mechanism - [code snippet], will be included in the next block</p> </li> <li> <p>The node runs <code>BeginBlock</code> * FeeMarket module to calculate <code>BaseFee</code> for subsequent blocks Apply to this block using the total <code>GasWanted</code> from the previous block.</p> </li> <li> <p>Distribution module distributes The previous block's fee rewards to validators and delegators</p> </li> <li> <p>For each valid transaction to be included in this block, the node does the following:</p> </li> </ol> <p>** They run an <code>AnteHandler</code> corresponding to the transaction type **.</p> <p>This process:</p> <ol> <li>Perform basic transaction validation</li> <li>Verify that the provided fee is greater than the global and local minimum validator values and greater than the computed <code>BaseFee</code><ol> <li>(For Ethereum transactions) Preempting EVM transaction consumption gas</li> </ol> </li> <li>Deduct the user's transaction fee and transfer it to the <code>fee_collector</code> module</li> <li>Increase the <code>TransientGasWanted</code> in the current block to calculate the <code>BaseFee</code> of the next block</li> </ol> <p>Then, for standard Cosmos transactions, nodes</p> <ul> <li>Execute transactions and update status</li> <li>Transaction consumes gas</li> </ul> <p>For Ethereum transactions, nodes:</p> <ul> <li>Execute transactions and update status</li> <li>Calculates the gas used and compares it to the supplied gas, then refunds the remainder of the specified portion</li> <li> <p>If the transaction interacts with a registered smart contract, a small portion of the fee used as revenue is sent to the contract developer as part of the revenue module</p> </li> <li> <p>The node runs <code>EndBlock</code> for this block and stores the <code>GasWanted</code> of the block</p> </li> </ul> <p>*** DETAILED APPROACH ***</p> <p>*** Cosmos <code>Gas</code> ***</p> <p>In the Cosmos SDK, gas is mainly tracked in <code>GasMeter</code> and <code>BlockGasMeter</code>:</p> <ul> <li><code>GasMeter</code>: Tracks gas consumed during executions that lead to state transitions. It is reset every time a transaction is executed.</li> <li><code>BlockGasMeter</code>: Tracks gas consumed in a block and enforces gas not exceeding a predefined limit. This limit is defined in the Tendermint consensus parameters and can be changed through governance parameter change proposals.</li> </ul> <p>Since gas is priced in bytes, the same interaction with larger parameter values will cost more gas than smaller parameter values (unlike Ethereum's <code>uint256</code> values, Cosmos SDK values use Big.Int types, which are dynamically resized).</p> <p>More information on gas as part of the Cosmos SDK can be found here.</p> <p>*** Match EVM Gas Consumption ***</p> <p>Daodst is an EVM compatible chain that supports Ethereum Web3 tools. For this reason, gas consumption must be comparable to other EVMs, most importantly Ethereum.</p> <p>The main difference between EVM and Cosmos state transitions is that the EVM uses a gas table for each opcode, Instead, Cosmos uses <code>GasConfig</code> to charge gas for each CRUD operation by setting a fixed per-byte cost for accessing the database.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/3fd376bd5659f076a4dc79b644573299fd1ec1bf/store/types/gas.go#L187-L196</p> <p>To match the gas consumed by the EVM, the gas consumption logic in the SDK is ignored, instead the gas consumed is calculated by subtracting the state transition remaining gas plus the refund from the gas limit defined on the message.</p> <p>To ignore the SDK's gas consumption, we reset the transaction <code>GasMeter</code> count to 0 and manually set it to the <code>gasUsed</code> value calculated by the EVM module at the end of execution.</p> <p>*** <code>AnteHandler</code> ***</p> <p>The Cosmos SDK <code>AnteHandler</code> performs basic checks before transaction execution.</p> <p>These checks are typically signature verification, transaction field verification, transaction fees, etc.</p> <p>Regarding gas consumption and fees, <code>AnteHandler</code> checks that the user has enough balance to cover the tx cost (amount plus the fee), and checks that the gas limit defined in the message is greater than or equal to the computed intrinsic gas message.</p> <p>*** Gas refund ***</p> <p>In EVM, gas can be specified before execution. The full amount of gas specified is consumed at the start of execution (during the <code>AnteHandler</code> step), if any gas remains after execution, the remaining gas will be refunded to the user.</p> <p>Additionally, the EVM can also define gas to be returned to the user, but these will be limited to a fraction of the gas used, depending on the fork/version used.</p> <p>*** Zero Fee Transactions ***</p> <p>In Cosmos, <code>AnteHandler</code> does not enforce minimum gas prices, because <code>min-gas-prices</code> are checked against local nodes/validators.</p> <p>In other words, the minimum fee accepted is determined by the validators of the network, and each validator can specify a different minimum value for their fee.</p> <p>This may allow end users to submit 0-fee transactions if at least one validator is willing to include a <code>0</code> gas price transaction in their proposed block.</p> <p>For the same reason, in Daodst it is possible to send transactions with a <code>0</code> fee for transaction types other than those defined by the <code>evm</code> module.</p> <p>EVM module transactions cannot have a \"0\" fee because the EVM itself requires gas.</p> <p>This check is done by the EVM transaction stateless validation (i.e. <code>ValidateBasic</code>) function as well as a custom <code>AnteHandler</code> defined by Daodst.</p> <p>*** Gas estimate ***</p> <p>Ethereum provides a JSON-RPC endpoint <code>eth_estimateGas</code> to help users set the correct gas limit in their transactions.</p> <p>Therefore, a specific query API <code>EstimateGas</code> is implemented in Daodst. It will apply the transaction against the current block/state and perform a binary search to find the best gas value to return to the user (the same transaction will be applied over and over until we find the minimum gas required before failing).</p> <p>The reason we need to use binary search is that the gas required by the transaction may be higher than the value returned by the EVM after applying the transaction, so we need to try until we find the optimal value.</p> <p>A cached context will be used throughout execution to avoid persisting changes in state.</p> <p>For Cosmos Tx, developers can use Cosmos SDK's \u3010Transaction Simulation\u3011(https://docs.cosmos.network/main/run-node/txs#simulating-a-transaction) to create accurate estimates.</p> <p>*** Cross-chain Gas and Fees ***</p> <p>Suppose a user transfers tokens from Chain A to Daodst via an IBC transfer and wishes to perform an Daodst transaction - however, they don't have any Daodst tokens to pay for. The Cosmos SDK introduces <code>Tips</code> to solve this problem; users can pay fees with different tokens - in this case, tokens from chain A.</p> <p>To pay a transaction fee with a tip, the user signs a transaction without a tip, and then sends the transaction to a fee relayer. The fee relayer will then pay the fee in the local currency (dst in this case) and receive a payment tip, acting as an intermediary exchange.</p> <p>More information on Cosmos:</p> <ul> <li>Cosmos Tips Documentation</li> </ul> <p>*** Use Daodst CLI to process gas and transaction fees ***</p> <p>Users should consider the available options when broadcasting transactions using the Daodst CLI client. There are three flags to consider when sending a transaction to the network:</p> <ul> <li><code>--fees</code>: Fees to pay with the transaction; eg: 10dst. Defaults to required fee.</li> <li><code>--gas</code>: Gas limit to set per transaction; default is 200000.</li> <li><code>--gas-prices</code>: gas prices to determine transaction fees (e.g. 10dst).</li> </ul> <p>However, not all of these need to be defined in every transaction. The correct combination is:</p> <ul> <li><code>--fees=auto</code>: Automatically estimate fees and gas (same behavior as --gas=auto ).   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas=auto</code>: Same behavior as <code>--fees=auto</code>.   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas={int}</code>: use the specified amount of gas and the transaction fee</li> <li><code>--fees={int}{denom}</code>: use the specified fee for tx. Use the gas default (200000) for tx.</li> <li><code>--fees={int}{denom} --gas={int}</code>: Use the specified gas and fee. Computes the gas-price using the provided parameters</li> <li><code>--gas-prices={int}{denom}</code>: Use provided gas prices and default gas amount (200000)</li> <li><code>--gas-prices={int}{denom} --gas={int}</code>: Use the gas specified for tx and calculate the price with the corresponding parameters.</li> </ul> <p>Readers should note that the first two options provide a more user-friendly experience for new users, while the latter are intended for more advanced users who want more control over these parameters.</p> <p>The team introduced the 'auto' flag option, which automatically calculates the gas and fees required to execute a transaction. In this way, new users or developers can execute transactions without defining specific gas and fee values.</p> <p>Using the <code>auto</code> flag may sometimes not estimate the correct gas and fees based on network traffic. To overcome this, you can use a higher value for the <code>--gas-adjustment</code> flag. By default it is set to <code>1.2</code>. When the estimate is insufficient, retry a higher gas adjustment, such as <code>--gas-adjustment 1.3</code>.</p> <p>The <code>--gas-prices</code> and <code>--fees</code> flags cannot be combined. If so, the user will receive an error message stating that fees and gas prices cannot be provided at the same time.</p> <p>Keep in mind that the above combo may fail if the fee or gas amount offered is insufficient. If this is the case, the CLI will return an error message with the specific reason. For example:</p> <pre><code>raw_log: 'out of gas in location: submit proposal; gasWanted: 200000, gasUsed: 263940.\n  Please retry with a gas (--gas flag) amount higher than gasUsed: out of gas'\n</code></pre>"},{"location":"protocol/#key-management","title":"key management","text":"<p>A mnemonic phrase, also known as a seed phrase, is a set of words used to recover or restore a cryptocurrency wallet. It acts as a backup to access your digital assets in case you lose access to the original wallet. The phrase is typically a series of 12-24 words that are generated when you create a wallet, and it should be kept secure and  private.</p> <p>The importance of mnemonic phrases lies in the fact that cryptocurrencies are stored in a decentralized manner, meaning that there is no central authority or institution that holds or controls your funds. This means that if you lose access to your wallet (e.g. forget your password, lose your device), you will not be able to recover your funds without the mnemonic phrase.</p> <p>Therefore, it is crucial to store your mnemonic phrase in a safe and secure place, such as a physical paper or a secure digital file. Additionally, it is recommended to make multiple copies and store them in different locations, so that you can access your funds in case of any emergency.</p> <p>:::note Mnemonic Phrase and Private Key A seed phrase, also known as a recovery phrase or backup phrase, is a sequence of words used to generate a private key. It is typically a set of 12 or 24 words, and it's used to recover or restore access to a cryptocurrency wallet in case the original private key is lost or damaged. A seed phrase can be used to generate multiple private keys, which can be used to access multiple cryptocurrency addresses and balances.</p> <p>On the other hand, a private key is a long string of characters that is used to sign transactions and provide access to your cryptocurrency funds. The private key is generated from the seed phrase and is unique to each cryptocurrency address. It is used to create digital signatures for transactions, which ensure that the transaction is legitimate and has been authorized by the rightful owner of the funds.</p> <p>In conclusion, the security of your private keys and mnemonic phrase is of utmost importance. If your private keys  are compromised, it can put all associated accounts at risk. However, the loss of your mnemonic phrase can have  even more severe consequences as it is used to generate multiple private keys. Therefore, it is crucial to take   proper measures to safeguard both your private keys and mnemonic phrase to avoid any catastrophic loss.</p> <p>:::</p> <p>** Mnemons in Daodst CLI **</p> <p>:::note Before proceeding with the CLI, please insure you have <code>stcd</code> installed. Installation instruction are located. :::</p> <p>When you create a new key, you'll receive a mnemonic phrase that can be used to restore that key. Backup the mnemonic phrase:</p> <pre><code>stcd keys add dev0\n{\n  \"name\": \"dev0\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}',\n  \"mnemonic\": \"\"\n}\n\n**Important** write this mnemonic phrase in a safe place.\nIt is the only way to recover your account if you ever forget your password.\n\n# &lt;24 word mnemonic phrase&gt;\n</code></pre> <p>To restore the key:</p> <pre><code>$ stcd keys add dev0-restored --recover\n&gt; Enter your bip39 mnemonic\nbanner genuine height east ghost oak toward reflect asset marble else explain foster car nest make van divide twice culture announce shuffle net peanut\n{\n  \"name\": \"dev0-restored\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n}\n</code></pre>"},{"location":"protocol/#_1","title":"\u5bc6\u200b\u9470\u5c0e\u51fa","text":"<p>** Tendermint-\u200b\u79c1\u9470\u200b\u683c\u5f0f\u200b **</p> <p>To backup this type of key without the mnemonic phrase, do the following:</p> <pre><code>stcd keys export dev0\nEnter passphrase to decrypt your key:\nEnter passphrase to encrypt the exported key:\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\n\n$ echo \"\\\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\" &gt; dev0.export\n</code></pre> <p>** Ethereum-\u200b\u79c1\u9470\u200b\u683c\u5f0f\u200b **</p> <p>:::tip Note: These types of keys are MetaMask-compatible. :::</p> <p>To backup this type of key without the mnemonic phrase, do the following:</p> <pre><code>stcd keys unsafe-export-eth-key dev0 &gt; dev0.export\n**WARNING** this is an unsafe way to export your unencrypted private key, are you sure? [y/N]: y\nEnter keyring passphrase:\n</code></pre>"},{"location":"protocol/#key-import","title":"Key Import","text":"<p>** Tendermint-Private Key Format **s</p> <pre><code>$ stcd keys import dev0-imported ./dev0.export\nEnter passphrase to decrypt your key:\n</code></pre> <p>** Ethereum-Private Key Format **</p> <pre><code>$ stcd keys unsafe-import-eth-key dev0-imported ./dev0.export\nEnter passphrase to encrypt your key:\n</code></pre>"},{"location":"protocol/#verify","title":"verify","text":"<p>Verify that your key has been restored using the following command:</p> <pre><code>$ stcd keys list\n[\n  {\n    \"name\": \"dev0-imported\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0-restored\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  }\n]\n</code></pre>"},{"location":"protocol/#importexport-status","title":"Import/Export Status","text":"<p>Daodst can dump the entire application state to a JSON file. This, besides upgrades, can be useful for manual analysis of the state at a given height.</p>"},{"location":"protocol/#export-status","title":"export status","text":"<p>Export state with:</p> <pre><code>stcd export &gt; new_genesis.json\n</code></pre> <p>You can also export state from a particular height (at the end of processing the block of that height):</p> <pre><code>stcd export --height [height] &gt; new_genesis.json\n</code></pre> <p>If you plan to start a new network for 0 height (i.e genesis) from the exported state, export with the <code>--for-zero-height</code> flag:</p> <pre><code>stcd export --height [height] --for-zero-height &gt; new_genesis.json\n</code></pre>"},{"location":"protocol/#manually-migrate-state","title":"Manually migrate state","text":"<p>If you want to migrate state manually, e.g. for local testing purpose. Note that for regular chain upgrades, a manual state migration is not required.</p> <p>After exporting your state into a json file, you can replace the old <code>genesis.json</code> with <code>new_genesis.json</code>.</p> <pre><code>cp -f genesis.json new_genesis.json\nmv new_genesis.json genesis.json\n</code></pre> <p>At this point, you might want to run a script to update the exported genesis into a genesis state that is compatible with your new version.</p> <p>You can use the <code>migrate</code> command to migrate from a given version to the next one (eg: <code>v0.X.X</code> to <code>v1.X.X</code>):</p> <pre><code>stcd migrate TARGET_VERSION GENESIS_FILE --chain-id=&lt;new_chain_id&gt; --genesis-time=&lt;yyyy-mm-ddThh:mm:ssZ&gt;\n</code></pre>"},{"location":"protocol/#multi-sig","title":"multi-sig","text":"<p>Learn how to generate, sign and broadcast a transaction using the keyring multisig.</p> <p>A multisig account is an Daodst account with a special key that can require more than one signature to sign transactions. This can be useful for increasing the security of the account or for requiring the consent of multiple parties to make transactions. Multisig accounts can be created by specifying:</p> <ul> <li>threshold number of signatures required</li> <li>the public keys involved in signing</li> </ul> <p>To sign with a multisig account, the transaction must be signed individually by the different keys specified for the account. Then, the signatures will be combined into a multi-signature which can be used to sign the transaction. If fewer than the threshold number of signatures needed are present, the resultant multi-signature is considered invalid.</p>"},{"location":"protocol/#generate-a-multi-signature-key-pair","title":"Generate a multi-signature key pair","text":"<pre><code>stcd keys add --multisig=name1,name2,name3[...] --multisig-threshold=K new_key_name\n</code></pre> <p><code>K</code> is the minimum number of private keys that must have signed the transactions that carry the public key's address as signer.</p> <p>The <code>--multisig</code> flag must contain the name of public keys that will be combined into a public key that will be generated and stored as <code>new_key_name</code> in the local database. All names supplied through <code>--multisig</code> must already exist  in the local database.</p> <p>Unless the flag <code>--nosort</code> is set, the order in which the keys are supplied on the command line does not matter, i.e. the  following commands generate two identical keys:</p> <pre><code>stcd keys add --multisig=p1,p2,p3 --multisig-threshold=2 multisig_address\nstcd keys add --multisig=p2,p3,p1 --multisig-threshold=2 multisig_address\n</code></pre> <p>Multisig addresses can also be generated on-the-fly and printed through the which command:</p> <pre><code>stcd keys show --multisig-threshold=K name1 name2 name3 [...]\n</code></pre>"},{"location":"protocol/#signature-transaction","title":"signature transaction","text":"<p>** Step 1: Create a multi-signature key **</p> <p>Let's assume that you have <code>test1</code> and <code>test2</code> want to make a multisig account with <code>test3</code>.</p> <p>First import the public keys of <code>test3</code> into your keyring.</p> <pre><code>stcd keys add \\\n    test3 \\\n    --pubkey=dstpub1addwnpepqgcxazmq6wgt2j4rdfumsfwla0zfk8e5sws3p3zg5dkm9007hmfysxas0u2\n</code></pre> <p>Generate the multisig key with 2/3 threshold.</p> <pre><code>stcd keys add \\\n    multi \\\n    --multisig=test1,test2,test3 \\\n    --multisig-threshold=2\n</code></pre> <p>You can see its address and details:</p> <pre><code>stcd keys show multi\n\n- name: multi\n  type: multi\n  address: dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\n  pubkey: dstpub1ytql0csgqgfzd666axrjzq3mxw59ys6yqcd3ydjvhgs0uzs6kdk5fp4t73gmkl8t6y02yfq7tvfzd666axrjzq3sd69kp5usk492x6nehqjal67ynv0nfqapzrzy3gmdk27la0kjfqfzd666axrjzq6utqt639ka2j3xkncgk65dup06t297ccljmxhvhu3rmk92u3afjuyz9dg9\n  mnemonic: \"\"\n  threshold: 0\n  pubkeys: []\n</code></pre> <p>Let's add 10 dst to the multisig wallet:</p> <pre><code>stcd tx bank send \\\n    test1 \\\n    dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n    10000000000000000000dst \\\n    --chain-id=daodst_7000-4 \\\n    --gas=auto \\\n    --fees=1000000dst \\\n    --broadcast-mode=block\n</code></pre> <p>** Step 2: Create a multi-signature transaction **</p> <p>We want to send 5 Daodst from our multisig account to <code>dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft</code>.</p> <pre><code>stcd tx bank send \\\n    dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft \\\n    dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq \\\n    5000000000000000000dst \\\n    --gas=200000 \\\n    --fees=1000000dst \\\n    --chain-id=daodst_7000-4 \\\n    --generate-only &gt; unsignedTx.json\n</code></pre> <p>The file <code>unsignedTx.json</code> contains the unsigned transaction encoded in JSON.</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": []\n}\n</code></pre> <p>** Step 3: signed separately **</p> <p>Sign with <code>test1</code> and <code>test2</code> and create individual signatures.</p> <pre><code>stcd tx sign \\\n    unsignedTx.json \\\n    --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n    --from=test1 \\\n    --output-document=test1sig.json \\\n    --chain-id=daodst_7000-4\n</code></pre> <pre><code>stcd tx sign \\\n    unsignedTx.json \\\n    --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n    --from=test2 \\\n    --output-document=test2sig.json \\\n    --chain-id=daodst_7000-4\n</code></pre> <p>** Step 4: Create a multi-signature **</p> <p>Combine signatures to sign transaction.</p> <pre><code>stcd tx multisign \\\n    unsignedTx.json \\\n    multi \\\n    test1sig.json test2sig.json \\\n    --output-document=signedTx.json \\\n    --chain-id=daodst_7000-4\n</code></pre> <p>The TX is now signed:</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [\n      {\n        \"public_key\": {\n          \"@type\": \"/cosmos.crypto.multisig.LegacyAminoPubKey\",\n          \"threshold\": 2,\n          \"public_keys\": [\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"ApCzSG8k7Tr4aM6e4OJRExN7cNtvH21L9azbh+uRrvt4\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"Ah91erz8ChNanqLe9ea948rvAiXMCRlR5Ka7EE/c0xUK\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"A0OjtIUCFJM3AobJ9HJTWKP9RZV2+WPcwVjLgsAidrZ/\"\n            }\n          ]\n        },\n        \"mode_info\": {\n          \"multi\": {\n            \"bitarray\": {\n              \"extra_bits_stored\": 3,\n              \"elems\": \"wA==\"\n            },\n            \"mode_infos\": [\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              },\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              }\n            ]\n          }\n        },\n        \"sequence\": \"1\"\n      }\n    ],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": [\n    \"CkCEeIbeGc+I1ipZuhp/0KhVNnWAv2tTlvgo5x61lzk1KHmLPV38m/YFurrFt5cm5+fqIXrn+FlOjrJuzBhw8ogYCkCawm9mpXsBHk0CFsE5618fVnvScEkfrzW0c2jCcjqV8EPuj3ut74UWzZyQkwtJGxUWtro9EgnGsB7Di1Gzizst\"\n  ]\n}\n</code></pre> <p>** Step 5: broadcast transaction **</p> <pre><code>stcd tx broadcast signedTx.json \\\n    --chain-id=daodst_7000-4 \\\n    --broadcast-mode=block\n</code></pre>"},{"location":"protocol/#pending-status","title":"Pending status","text":"<p>When a transaction is submitted to the Ethereum network, it first enters the pending state, waiting for the node to execute it.</p> <p>If the gas price in a transaction is set very low and the node is busy processing other transactions with higher gas prices, the transaction may remain pending for a longer period of time.</p> <p>During the pending state, transaction initiators are allowed to change transaction fields at any time.</p> <p>They can do this by sending another transaction with the same nonce.</p> <p>** Prerequisite Reading **</p> <ul> <li>Cosmos SDK Mempool</li> </ul> <p>** Daodst vs. Ethereum **</p> <p>In Ethereum, pending blocks are generated when miners are queued for production.</p> <p>These pending blocks consist of pending transactions picked by miners based on the highest gas reward paid.</p> <p>This mechanism exists because block finality is not possible on the Ethereum network.</p> <p>Blocks are committed with probabilistic determinism, meaning that over time (and blocks) transactions and blocks become less likely to be reverted.</p> <p>Daodst is designed completely differently in this regard, as there is no concept of a \"pending state\".</p> <p>Daodst uses Tendermint Core BFT consensus to provide instant finality for transactions.</p> <p>For this reason, Ethermint does not need to suspend the state mechanism, since all (if not most) transactions will be committed to the next block (the average block time on the Cosmos chain is about 8 seconds).</p> <p>However, this causes problems with some Ethereum Web3 compatible queries, which may enter a pending state.</p> <p>Another notable difference from Ethereum is that blocks are generated by validators, or block producers, who include transactions from their local mempool into blocks in a first-in-first-out (FIFO) fashion.</p> <p>Transactions on Daodst cannot be ordered or picked from the Tendermint node mempool.</p> <p>** Pending state queue **</p> <p>Daodst will make queries to account for any unconfirmed transactions that exist in the node's transaction mempool.</p> <p>Pending state queries made will be subjective and will be queried on the mempool of the target node.</p> <p>So for the same query on two different nodes, the pending status will not be the same.</p> <p>** JSON-RPC Calls on Pending Transactions **</p> <ul> <li><code>eth_getBalance</code></li> <li><code>eth_getTransactionCount</code></li> <li><code>eth_getBlockTransactionCountByNumber</code></li> <li><code>eth_getBlockByNumber</code></li> <li><code>eth_getTransactionByHash</code></li> <li><code>eth_getTransactionByBlockNumberAndIndex</code></li> <li><code>eth_sendTransaction</code></li> </ul>"},{"location":"protocol/#token","title":"Token","text":""},{"location":"protocol/#daodst-token","title":"Daodst Token","text":"<p>The denomination used for staking, governance, and gas consumption on the EVM is Daodst. Daodst provides the following utilities: securing proof-of-stake chains, tokens for governance proposals, distributing fees to validators and users, and as fuel for running smart contracts on the EVM.</p> <p>Daodst uses Atto Daodst as the base denomination to maintain parity with Ethereum. Assets are divided into three categories:</p> <p>This matches the denomination of Ethereum:</p> <p><code>1 ETH = 10&lt;sup&gt;18&lt;/sup&gt; wei</code></p>"},{"location":"protocol/#cosmos-tokens","title":"Cosmos Tokens","text":"<p>Accounts can have Cosmos coins in their balances, which are used for operations and transactions with other Cosmos. Examples of these include staking with tokens, IBC transfers, governance deposits, and EVM.</p>"},{"location":"protocol/#evm-token","title":"EVM Token","text":"<p>Daodst is compatible with ERC20 tokens and other non-fungible token standards natively supported by EVM (EIP721, EIP1155).</p> <p>** Daodst asset page **</p> <p>See how we represent ERC-20 tokens and Cosmos IBC coins through our Single Token Representation Features on the Daodst Dashboard.</p> <p>Daodst enables this feature to help improve user experience by obfuscating asset types away from the user and allowing them to focus on the interaction.</p> <p>The protocol simplifies the process by handling conversions and provides users with simplified denominations and the amount of assets they hold.</p> <p>More information on how we handle token registration can be found here.</p>"},{"location":"protocol/#trade","title":"trade","text":"<p>A transaction is an action initiated by an account that changes the state of the blockchain.</p> <p>In order to perform state changes efficiently, each transaction is broadcast to the entire network.</p> <p>Any node can broadcast requests for transactions to be executed on the blockchain state machine;</p> <p>Once this happens, validators will validate, execute the transaction, and propagate the resulting state change to the rest of the network.</p> <p>To process each transaction, computing resources on the network are consumed.</p> <p>Thus, the concept of \"gas\" emerged as a reference to the computation required by a validator to process a transaction.</p> <p>Users have to pay for this computation, and all transactions have an associated fee.</p> <p>The fee is calculated based on the gas and gas price required to execute the transaction.</p> <p>Additionally, transactions need to be signed with the sender's private key.</p> <p>This proves that transactions can only come from the sender and not sent fraudulently.</p> <p>In short, the transaction life cycle after submitting a signed transaction to the network is as follows:</p> <ul> <li>Transaction hashes are cryptographically generated.</li> <li>The transaction is broadcast to the network and added to the pool of all other pending network transactions.</li> <li>A validator has to pick your transaction and include it in a block in order to validate the transaction and consider it \"successful\".</li> </ul> <p>For a more detailed explanation of the transaction lifecycle, see the corresponding section.</p> <p>A transaction hash is a unique identifier that can be used to check transaction information, for example, whether the emitted event was successful.</p> <p>Transactions can fail for various reasons.</p> <p>For example, the gas or fee provided may not be sufficient.</p> <p>Additionally, transaction validation may fail.</p> <p>Each transaction has specific conditions that must be met in order to be considered valid.</p> <p>A broad verification is that the sender is the transaction signer.</p> <p>In this case, if you send the transaction where the sender's address is different from the signer's address, the transaction will fail even if the fee is sufficient.</p> <p>Today, transactions can not only make state transitions on the chain they were committed to, but they can also be transacted on another blockchain.</p> <p>Inter-chain transactions can be implemented through the Inter-Blockchain Communication Protocol (IBC).</p> <p>Find a more detailed explanation in the sections below.</p>"},{"location":"protocol/#transaction-type","title":"Transaction Type","text":"<p>Daodst supports two transaction types:</p> <ol> <li>Cosmos transactions</li> <li>Ethereum transactions</li> </ol> <p>This is possible because Daodst uses the Cosmos-SDK and implements the Ethereum Virtual Machine as a module.</p> <p>In this way, Daodst provides the combined features and functionality of Ethereum and Cosmos chains, among other things.</p> <p>Although most of the information contained in these two transaction types is similar, there are differences between them.</p> <p>An important difference is that Cosmos transactions allow multiple messages to be sent in the same transaction.</p> <p>In contrast, Ethereum transactions do not have this possibility.</p> <p>To bring these two types together, Daodst implements Ethereum transactions as a single <code>sdk.Msg</code> Included in <code>auth.StdTx</code>.</p> <p>This message contains all relevant Ethereum transaction information.</p> <p>This includes signatures, gases, payloads, etc.</p> <p>Find out more about both types in the following sections.</p>"},{"location":"protocol/#cosmos-trade","title":"Cosmos trade","text":"<p>On Cosmos chains, transactions are comprised of metadata held in contexts and <code>sdk.Msg</code>s that trigger state changes within a module through the module's Protobuf Msg service.</p> <p>When users want to interact with an application and make state changes (e.g. sending coins), they create transactions. Cosmos transactions can have multiple <code>sdk.Msg</code>s. Each of these must be signed using the private key associated with the appropriate account(s), before the transaction is broadcasted to the network.</p> <p>A Cosmos transaction includes the following information:</p> <ul> <li><code>Msgs</code>: an array of msgs (<code>sdk.Msg</code>)</li> <li><code>GasLimit</code>: option chosen by the users for how to calculate how much gas they will need to pay</li> <li><code>FeeAmount</code>: max amount user is willing to pay in fees</li> <li><code>TimeoutHeight</code>: block height until which the transaction is valid</li> <li><code>Signatures</code>: array of signatures from all signers of the tx</li> <li><code>Memo</code>: a note or comment to send with the transaction</li> </ul> <p>To submit a Cosmos transaction, users must use one of the provided clients.</p>"},{"location":"protocol/#ethereum-trade","title":"Ethereum trade","text":"<p>Ethereum transactions refer to actions initiated by EOAs (externally-owned accounts, managed by humans), rather than internal smart contract calls. Ethereum transactions transform the state of the EVM and therefore must be broadcasted to the entire network.</p> <p>Ethereum transactions also require a fee, known as <code>gas</code>. (EIP-1559) introduced the idea of a base fee, along with a priority fee which serves as an incentive for miners to include specific transactions in blocks.</p> <p>There are several categories of Ethereum transactions:</p> <ul> <li>regular transactions: transactions from one account to another</li> <li>contract deployment transactions: transactions without a <code>to</code> address, where the contract code is sent in the <code>data</code> field</li> <li>execution of a contract: transactions that interact with a deployed smart contract,   where the <code>to</code> address is the smart contract address</li> </ul> <p>An Ethereum transaction includes the following information:</p> <ul> <li><code>recipient</code>: receiving address</li> <li><code>signature</code>: sender's signature</li> <li><code>nonce</code>: counter of tx number from account</li> <li><code>value</code>: amount of ETH to transfer (in wei)</li> <li><code>data</code>: include arbitrary data. Used when deploying a smart contract or making a smart contract method call</li> <li><code>gasLimit</code>: max amount of gas to be consumed</li> <li><code>maxPriorityFeePerGas</code>: mas gas to be included as tip to validators</li> <li><code>maxFeePerGas</code>: max amount of gas to be paid for tx</li> </ul> <p>For more information on Ethereum transactions and the transaction lifecycle, go here.</p> <p>Daodst supports the following Ethereum transactions.</p> <p>:::tip Note: Unprotected legacy transactions are not supported by default. :::</p> <ul> <li>Dynamic Fee Transactions (EIP-1559)</li> <li>Access List Transactions (EIP-2930)</li> <li>Legacy Transactions (EIP-2718)</li> </ul> <p>Daodst is capable of processing Ethereum transactions by wrapping them on a <code>sdk.Msg</code>. Daodst achieves this by using the <code>MsgEthereumTx</code>. This message encapsulates an Ethereum transaction as an SDK message and contains the necessary transaction data fields.</p> <p>One remark about the <code>MsgEthereumTx</code> is that it implements both the <code>sdk.Msg</code> and <code>sdk.Tx</code> interfaces (generally SDK messages only implement the former, while the latter is a group of messages bundled together). The reason of this, is because the <code>MsgEthereumTx</code> must not be included in a <code>auth.StdTx</code> (SDK's standard transaction type) as it performs gas and fee checks using the Ethereum logic from Geth instead of the Cosmos SDK checks done on the auth module <code>AnteHandler</code>.</p>"},{"location":"protocol/#interchain-transaction","title":"Interchain transaction","text":"<p>Interchain transactions refer to the transfer of digital assets or data between two or more different blockchain networks.</p> <p>Each blockchain network has its own unique protocol and data structure, making it difficult to directly transfer assets or data from one blockchain to another. Interchain transactions allow for the transfer of assets and data between different blockchains by using intermediary mechanisms or protocols.</p> <p>One such mechanism is a cross-chain bridge, which acts as a connector between different blockchains, enabling the transfer of assets or data. Cross-chain bridges typically require some form of trust or consensus mechanism to ensure the security and integrity of the transaction.</p> <p>Another possibility is to use the IBC (Inter-Blockchain Communication) protocol. To make an interchain transaction using IBC a user needs to:</p> <ul> <li>Choose the source and destination blockchain networks that the user wants to transfer assets or data between.</li> <li>Ensure that both blockchain networks have implemented the IBC protocol</li> <li>Ensure there's a connection and channel established between the two blockchain networks using IBC</li> <li>Initiate the transfer of assets or data: this is done by sending a transaction from the source blockchain   to the destination blockchain through the IBC channel</li> </ul> <p>Interchain transactions are becoming increasingly important as the number of different blockchain networks and applications continues to grow. They enable the interoperability of different blockchain networks, allowing for greater flexibility and efficiency in the transfer of digital assets and data.</p>"},{"location":"protocol/#transaction-certificate","title":"transaction certificate","text":"<p>A transaction receipt shows data returned by an Ethereum client to represent the result of a particular transaction, including a hash of the transaction, its block number, the amount of gas used, and, in case of deployment of a smart contract, the address of the contract. Additionally, it includes custom information from the events emitted in the smart contract.</p> <p>A receipt contains the following information:</p> <ul> <li><code>transactionHash</code> : hash of the transaction.</li> <li><code>transactionIndex</code>: integer of the transactions index position in the block.</li> <li><code>blockHash</code>: hash of the block where this transaction was in.</li> <li><code>blockNumber</code>: block number where this transaction was in.</li> <li><code>from</code>: address of the sender.</li> <li><code>to</code>: address of the receiver. null when its a contract creation transaction.</li> <li><code>cumulativeGasUsed</code> : The total amount of gas used when this transaction was executed in the block.</li> <li><code>effectiveGasPrice</code> : The sum of the base fee and tip paid per unit of gas.</li> <li><code>gasUsed</code> : The amount of gas used by this specific transaction alone.</li> <li><code>contractAddress</code> : The contract address created, if the transaction was a contract creation, otherwise null.</li> <li><code>logs</code>: Array of log objects, which this transaction generated.</li> <li><code>logsBloom</code>: Bloom filter for light clients to quickly retrieve related logs.</li> <li><code>type</code>: integer of the transaction type, 0x00 for legacy transactions, 0x01 for access list types,   0x02 for dynamic fees. It also returns either.</li> <li><code>root</code> : transaction stateroot (pre Byzantium)</li> <li><code>status</code>: either 1 (success) or 0 (failure)</li> </ul>"},{"location":"slashing/","title":"Slashing","text":""},{"location":"slashing/#xslashing","title":"<code>x/slashing</code>","text":""},{"location":"slashing/#abstract","title":"Abstract","text":"<p>This section specifies the slashing module</p> <p>The slashing module enables Cosmos SDK-based blockchains to disincentivize any attributable action by a protocol-recognized actor with value at stake by penalizing them (\"slashing\").</p> <p>Penalties may include, but are not limited to:</p> <ul> <li>Burning some amount of their stake</li> <li>Removing their ability to vote on future blocks for a period of time.</li> </ul>"},{"location":"slashing/#concepts","title":"Concepts","text":""},{"location":"slashing/#states","title":"States","text":"<p>At any given time, there are any number of validators registered in the state machine. Each block, the top <code>MaxValidators</code> (defined by <code>x/staking</code>) validators who are not jailed become bonded, meaning that they may propose and vote on blocks. Validators who are bonded are at stake, meaning that part or all of their stake and their delegators' stake is at risk if they commit a protocol fault.</p> <p>For each of these validators we keep a <code>ValidatorSigningInfo</code> record that contains information partaining to validator's liveness and other infraction related attributes.</p>"},{"location":"slashing/#tombstone-caps","title":"Tombstone Caps","text":"<p>In order to mitigate the impact of initially likely categories of non-malicious protocol faults, the Cosmos Hub implements for each validator a tombstone cap, which only allows a validator to be slashed once for a double sign fault. For example, if you misconfigure your HSM and double-sign a bunch of old blocks, you'll only be punished for the first double-sign (and then immediately tombstombed). This will still be quite expensive and desirable to avoid, but tombstone caps somewhat blunt the economic impact of unintentional misconfiguration.</p> <p>Liveness faults do not have caps, as they can't stack upon each other. Liveness bugs are \"detected\" as soon as the infraction occurs, and the validators are immediately put in jail, so it is not possible for them to commit multiple liveness faults without unjailing in between.</p>"},{"location":"slashing/#infraction-timelines","title":"Infraction Timelines","text":"<p>To illustrate how the <code>x/slashing</code> module handles submitted evidence through Tendermint consensus, consider the following examples:</p> <p>Definitions:</p> <p>[ : timeline start ] : timeline end C<sub>n</sub> : infraction <code>n</code> committed D<sub>n</sub> : infraction <code>n</code> discovered V<sub>b</sub> : validator bonded V<sub>u</sub> : validator unbonded</p>"},{"location":"slashing/#single-double-sign-infraction","title":"Single Double Sign Infraction","text":"<p>&lt;-----------------&gt; [----------C<sub>1</sub>----D<sub>1</sub>,V<sub>u</sub>-----]</p> <p>A single infraction is committed then later discovered, at which point the validator is unbonded and slashed at the full amount for the infraction.</p>"},{"location":"slashing/#multiple-double-sign-infractions","title":"Multiple Double Sign Infractions","text":"<p>&lt;---------------------------&gt; [----------C<sub>1</sub>--C<sub>2</sub>---C<sub>3</sub>---D<sub>1</sub>,D<sub>2</sub>,D<sub>3</sub>V<sub>u</sub>-----]</p> <p>Multiple infractions are committed and then later discovered, at which point the validator is jailed and slashed for only one infraction. Because the validator is also tombstoned, they can not rejoin the validator set.</p>"},{"location":"slashing/#state","title":"State","text":""},{"location":"slashing/#signing-info-liveness","title":"Signing Info (Liveness)","text":"<p>Every block includes a set of precommits by the validators for the previous block, known as the <code>LastCommitInfo</code> provided by Tendermint. A <code>LastCommitInfo</code> is valid so long as it contains precommits from +2/3 of total voting power.</p> <p>Proposers are incentivized to include precommits from all validators in the Tendermint <code>LastCommitInfo</code> by receiving additional fees proportional to the difference between the voting power included in the <code>LastCommitInfo</code> and +2/3</p> <pre><code>type LastCommitInfo struct {\n    Round int32\n    Votes []VoteInfo\n}\n</code></pre> <p>Validators are penalized for failing to be included in the <code>LastCommitInfo</code> for some number of blocks by being automatically jailed, potentially slashed, and unbonded.</p> <p>Information about validator's liveness activity is tracked through <code>ValidatorSigningInfo</code>. It is indexed in the store as follows:</p> <ul> <li>ValidatorSigningInfo: <code>0x01 | ConsAddrLen (1 byte) | ConsAddress -&gt; ProtocolBuffer(ValSigningInfo)</code></li> <li>MissedBlocksBitArray: <code>0x02 | ConsAddrLen (1 byte) | ConsAddress | LittleEndianUint64(signArrayIndex) -&gt; VarInt(didMiss)</code> (varint is a number encoding format)</li> </ul> <p>The first mapping allows us to easily lookup the recent signing info for a validator based on the validator's consensus address.</p> <p>The second mapping (<code>MissedBlocksBitArray</code>) acts as a bit-array of size <code>SignedBlocksWindow</code> that tells us if the validator missed the block for a given index in the bit-array. The index in the bit-array is given as little endian uint64. The result is a <code>varint</code> that takes on <code>0</code> or <code>1</code>, where <code>0</code> indicates the validator did not miss (did sign) the corresponding block, and <code>1</code> indicates they missed the block (did not sign).</p> <p>Note that the <code>MissedBlocksBitArray</code> is not explicitly initialized up-front. Keys are added as we progress through the first <code>SignedBlocksWindow</code> blocks for a newly bonded validator. The <code>SignedBlocksWindow</code> parameter defines the size (number of blocks) of the sliding window used to track validator liveness.</p> <p>The information stored for tracking validator liveness is as follows:</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/slashing/v1beta1/slashing.proto#L11-L33</p>"},{"location":"slashing/#messages","title":"Messages","text":"<p>In this section we describe the processing of messages for the <code>slashing</code> module.</p>"},{"location":"slashing/#unjail","title":"Unjail","text":"<p>If a validator was automatically unbonded due to downtime and wishes to come back online &amp; possibly rejoin the bonded set, it must send <code>MsgUnjail</code>:</p> <pre><code>// MsgUnjail is an sdk.Msg used for unjailing a jailed validator, thus returning\n// them into the bonded validator set, so they can begin receiving provisions\n// and rewards again.\nmessage MsgUnjail {\n  string validator_addr = 1;\n}\n</code></pre> <p>Below is a pseudocode of the <code>MsgSrv/Unjail</code> RPC:</p> <pre><code>unjail(tx MsgUnjail)\n    validator = getValidator(tx.ValidatorAddr)\n    if validator == nil\n      fail with \"No validator found\"\n\n    if getSelfDelegation(validator) == 0\n      fail with \"validator must self delegate before unjailing\"\n\n    if !validator.Jailed\n      fail with \"Validator not jailed, cannot unjail\"\n\n    info = GetValidatorSigningInfo(operator)\n    if info.Tombstoned\n      fail with \"Tombstoned validator cannot be unjailed\"\n    if block time &lt; info.JailedUntil\n      fail with \"Validator still jailed, cannot unjail until period has expired\"\n\n    validator.Jailed = false\n    setValidator(validator)\n\n    return\n</code></pre> <p>If the validator has enough stake to be in the top <code>n = MaximumBondedValidators</code>, it will be automatically rebonded, and all delegators still delegated to the validator will be rebonded and begin to again collect provisions and rewards.</p>"},{"location":"slashing/#beginblock","title":"BeginBlock","text":""},{"location":"slashing/#liveness-tracking","title":"Liveness Tracking","text":"<p>At the beginning of each block, we update the <code>ValidatorSigningInfo</code> for each validator and check if they've crossed below the liveness threshold over a sliding window. This sliding window is defined by <code>SignedBlocksWindow</code> and the index in this window is determined by <code>IndexOffset</code> found in the validator's <code>ValidatorSigningInfo</code>. For each block processed, the <code>IndexOffset</code> is incremented regardless if the validator signed or not. Once the index is determined, the <code>MissedBlocksBitArray</code> and <code>MissedBlocksCounter</code> are updated accordingly.</p> <p>Finally, in order to determine if a validator crosses below the liveness threshold, we fetch the maximum number of blocks missed, <code>maxMissed</code>, which is <code>SignedBlocksWindow - (MinSignedPerWindow * SignedBlocksWindow)</code> and the minimum height at which we can determine liveness, <code>minHeight</code>. If the current block is greater than <code>minHeight</code> and the validator's <code>MissedBlocksCounter</code> is greater than <code>maxMissed</code>, they will be slashed by <code>SlashFractionDowntime</code>, will be jailed for <code>DowntimeJailDuration</code>, and have the following values reset: <code>MissedBlocksBitArray</code>, <code>MissedBlocksCounter</code>, and <code>IndexOffset</code>.</p> <p>Note: Liveness slashes do NOT lead to a tombstombing.</p> <pre><code>height := block.Height\n\nfor vote in block.LastCommitInfo.Votes {\n  signInfo := GetValidatorSigningInfo(vote.Validator.Address)\n\n  // This is a relative index, so we counts blocks the validator SHOULD have\n  // signed. We use the 0-value default signing info if not present, except for\n  // start height.\n  index := signInfo.IndexOffset % SignedBlocksWindow()\n  signInfo.IndexOffset++\n\n  // Update MissedBlocksBitArray and MissedBlocksCounter. The MissedBlocksCounter\n  // just tracks the sum of MissedBlocksBitArray. That way we avoid needing to\n  // read/write the whole array each time.\n  missedPrevious := GetValidatorMissedBlockBitArray(vote.Validator.Address, index)\n  missed := !signed\n\n  switch {\n  case !missedPrevious &amp;&amp; missed:\n    // array index has changed from not missed to missed, increment counter\n    SetValidatorMissedBlockBitArray(vote.Validator.Address, index, true)\n    signInfo.MissedBlocksCounter++\n\n  case missedPrevious &amp;&amp; !missed:\n    // array index has changed from missed to not missed, decrement counter\n    SetValidatorMissedBlockBitArray(vote.Validator.Address, index, false)\n    signInfo.MissedBlocksCounter--\n\n  default:\n    // array index at this index has not changed; no need to update counter\n  }\n\n  if missed {\n    // emit events...\n  }\n\n  minHeight := signInfo.StartHeight + SignedBlocksWindow()\n  maxMissed := SignedBlocksWindow() - MinSignedPerWindow()\n\n  // If we are past the minimum height and the validator has missed too many\n  // jail and slash them.\n  if height &gt; minHeight &amp;&amp; signInfo.MissedBlocksCounter &gt; maxMissed {\n    validator := ValidatorByConsAddr(vote.Validator.Address)\n\n    // emit events...\n\n    // We need to retrieve the stake distribution which signed the block, so we\n    // subtract ValidatorUpdateDelay from the block height, and subtract an\n    // additional 1 since this is the LastCommit.\n    //\n    // Note, that this CAN result in a negative \"distributionHeight\" up to\n    // -ValidatorUpdateDelay-1, i.e. at the end of the pre-genesis block (none) = at the beginning of the genesis block.\n    // That's fine since this is just used to filter unbonding delegations &amp; redelegations.\n    distributionHeight := height - sdk.ValidatorUpdateDelay - 1\n\n    Slash(vote.Validator.Address, distributionHeight, vote.Validator.Power, SlashFractionDowntime())\n    Jail(vote.Validator.Address)\n\n    signInfo.JailedUntil = block.Time.Add(DowntimeJailDuration())\n\n    // We need to reset the counter &amp; array so that the validator won't be\n    // immediately slashed for downtime upon rebonding.\n    signInfo.MissedBlocksCounter = 0\n    signInfo.IndexOffset = 0\n    ClearValidatorMissedBlockBitArray(vote.Validator.Address)\n  }\n\n  SetValidatorSigningInfo(vote.Validator.Address, signInfo)\n}\n</code></pre>"},{"location":"slashing/#hooks","title":"Hooks","text":"<p>This section contains a description of the module's <code>hooks</code>. Hooks are operations that are executed automatically when events are raised.</p>"},{"location":"slashing/#staking-hooks","title":"Staking hooks","text":"<p>The slashing module implements the <code>StakingHooks</code> defined in <code>x/staking</code> and are used as record-keeping of validators information. During the app initialization, these hooks should be registered in the staking module struct.</p> <p>The following hooks impact the slashing state:</p> <ul> <li><code>AfterValidatorBonded</code> creates a <code>ValidatorSigningInfo</code> instance as described in the following section.</li> <li><code>AfterValidatorCreated</code> stores a validator's consensus key.</li> <li><code>AfterValidatorRemoved</code> removes a validator's consensus key.</li> </ul>"},{"location":"slashing/#validator-bonded","title":"Validator Bonded","text":"<p>Upon successful first-time bonding of a new validator, we create a new <code>ValidatorSigningInfo</code> structure for the now-bonded validator, which <code>StartHeight</code> of the current block.</p> <pre><code>onValidatorBonded(address sdk.ValAddress)\n\n  signingInfo, found = GetValidatorSigningInfo(address)\n  if !found {\n    signingInfo = ValidatorSigningInfo {\n      StartHeight         : CurrentHeight,\n      IndexOffset         : 0,\n      JailedUntil         : time.Unix(0, 0),\n      Tombstone           : false,\n      MissedBloskCounter  : 0\n    }\n    setValidatorSigningInfo(signingInfo)\n  }\n\n  return\n</code></pre>"},{"location":"slashing/#tags","title":"Tags","text":"<p>The slashing module emits the following events/tags:</p>"},{"location":"slashing/#msgserver","title":"MsgServer","text":""},{"location":"slashing/#msgunjail","title":"MsgUnjail","text":"Type Attribute Key Attribute Value message module slashing message sender {validatorAddress}"},{"location":"slashing/#keeper","title":"Keeper","text":""},{"location":"slashing/#beginblocker-handlevalidatorsignature","title":"BeginBlocker: HandleValidatorSignature","text":"Type Attribute Key Attribute Value slash address {validatorConsensusAddress} slash power {validatorPower} slash reason {slashReason} slash jailed [0] {validatorConsensusAddress} <ul> <li>[0] Only included if the validator is jailed.</li> </ul> Type Attribute Key Attribute Value liveness address {validatorConsensusAddress} liveness missed_blocks {missedBlocksCounter} liveness height {blockHeight}"},{"location":"slashing/#slash","title":"Slash","text":"<ul> <li>same as <code>\"slash\"</code> event from <code>HandleValidatorSignature</code>, but without the <code>jailed</code> attribute.</li> </ul>"},{"location":"slashing/#jail","title":"Jail","text":"Type Attribute Key Attribute Value slash jailed {validatorAddress}"},{"location":"slashing/#staking-tombstone","title":"Staking Tombstone","text":""},{"location":"slashing/#abstract_1","title":"Abstract","text":"<p>In the current implementation of the <code>slashing</code> module, when the consensus engine informs the state machine of a validator's consensus fault, the validator is partially slashed, and put into a \"jail period\", a period of time in which they are not allowed to rejoin the validator set. However, because of the nature of consensus faults and ABCI, there can be a delay between an infraction occurring, and evidence of the infraction reaching the state machine (this is one of the primary reasons for the existence of the unbonding period).</p> <p>Note: The tombstone concept, only applies to faults that have a delay between the infraction occurring and evidence reaching the state machine. For example, evidence of a validator double signing may take a while to reach the state machine due to unpredictable evidence gossip layer delays and the ability of validators to selectively reveal double-signatures (e.g. to infrequently-online light clients). Liveness slashing, on the other hand, is detected immediately as soon as the infraction occurs, and therefore no slashing period is needed. A validator is immediately put into jail period, and they cannot commit another liveness fault until they unjail. In the future, there may be other types of byzantine faults that have delays (for example, submitting evidence of an invalid proposal as a transaction). When implemented, it will have to be decided whether these future types of byzantine faults will result in a tombstoning (and if not, the slash amounts will not be capped by a slashing period).</p> <p>In the current system design, once a validator is put in the jail for a consensus fault, after the <code>JailPeriod</code> they are allowed to send a transaction to <code>unjail</code> themselves, and thus rejoin the validator set.</p> <p>One of the \"design desires\" of the <code>slashing</code> module is that if multiple infractions occur before evidence is executed (and a validator is put in jail), they should only be punished for single worst infraction, but not cumulatively. For example, if the sequence of events is:</p> <ol> <li>Validator A commits Infraction 1 (worth 30% slash)</li> <li>Validator A commits Infraction 2 (worth 40% slash)</li> <li>Validator A commits Infraction 3 (worth 35% slash)</li> <li>Evidence for Infraction 1 reaches state machine (and validator is put in jail)</li> <li>Evidence for Infraction 2 reaches state machine</li> <li>Evidence for Infraction 3 reaches state machine</li> </ol> <p>Only Infraction 2 should have its slash take effect, as it is the highest. This is done, so that in the case of the compromise of a validator's consensus key, they will only be punished once, even if the hacker double-signs many blocks. Because, the unjailing has to be done with the validator's operator key, they have a chance to re-secure their consensus key, and then signal that they are ready using their operator key. We call this period during which we track only the max infraction, the \"slashing period\".</p> <p>Once, a validator rejoins by unjailing themselves, we begin a new slashing period; if they commit a new infraction after unjailing, it gets slashed cumulatively on top of the worst infraction from the previous slashing period.</p> <p>However, while infractions are grouped based off of the slashing periods, because evidence can be submitted up to an <code>unbondingPeriod</code> after the infraction, we still have to allow for evidence to be submitted for previous slashing periods. For example, if the sequence of events is:</p> <ol> <li>Validator A commits Infraction 1 (worth 30% slash)</li> <li>Validator A commits Infraction 2 (worth 40% slash)</li> <li>Evidence for Infraction 1 reaches state machine (and Validator A is put in jail)</li> <li>Validator A unjails</li> </ol> <p>We are now in a new slashing period, however we still have to keep the door open for the previous infraction, as the evidence for Infraction 2 may still come in. As the number of slashing periods increase, it creates more complexity as we have to keep track of the highest infraction amount for every single slashing period.</p> <p>Note: Currently, according to the <code>slashing</code> module spec, a new slashing period is created every time a validator is unbonded then rebonded. This should probably be changed to jailed/unjailed. See issue #3205 for further details. For the remainder of this, I will assume that we only start a new slashing period when a validator gets unjailed.</p> <p>The maximum number of slashing periods is the <code>len(UnbondingPeriod) / len(JailPeriod)</code>. The current defaults in Gaia for the <code>UnbondingPeriod</code> and <code>JailPeriod</code> are 3 weeks and 2 days, respectively. This means there could potentially be up to 11 slashing periods concurrently being tracked per validator. If we set the <code>JailPeriod &gt;= UnbondingPeriod</code>, we only have to track 1 slashing period (i.e not have to track slashing periods).</p> <p>Currently, in the jail period implementation, once a validator unjails, all of their delegators who are delegated to them (haven't unbonded / redelegated away), stay with them. Given that consensus safety faults are so egregious (way more so than liveness faults), it is probably prudent to have delegators not \"auto-rebond\" to the validator.</p>"},{"location":"slashing/#proposal-infinite-jail","title":"Proposal: infinite jail","text":"<p>We propose setting the \"jail time\" for a validator who commits a consensus safety fault, to <code>infinite</code> (i.e. a tombstone state). This essentially kicks the validator out of the validator set and does not allow them to re-enter the validator set. All of their delegators (including the operator themselves) have to either unbond or redelegate away. The validator operator can create a new validator if they would like, with a new operator key and consensus key, but they have to \"re-earn\" their delegations back.</p> <p>Implementing the tombstone system and getting rid of the slashing period tracking will make the <code>slashing</code> module way simpler, especially because we can remove all of the hooks defined in the <code>slashing</code> module consumed by the <code>staking</code> module (the <code>slashing</code> module still consumes hooks defined in <code>staking</code>).</p>"},{"location":"slashing/#single-slashing-amount","title":"Single slashing amount","text":"<p>Another optimization that can be made is that if we assume that all ABCI faults for Tendermint consensus are slashed at the same level, we don't have to keep track of \"max slash\". Once an ABCI fault happens, we don't have to worry about comparing potential future ones to find the max.</p> <p>Currently the only Tendermint ABCI fault is:</p> <ul> <li>Unjustified precommits (double signs)</li> </ul> <p>It is currently planned to include the following fault in the near future:</p> <ul> <li>Signing a precommit when you're in unbonding phase (needed to make light client bisection safe)</li> </ul> <p>Given that these faults are both attributable byzantine faults, we will likely want to slash them equally, and thus we can enact the above change.</p> <p>Note: This change may make sense for current Tendermint consensus, but maybe not for a different consensus algorithm or future versions of Tendermint that may want to punish at different levels (for example, partial slashing).</p>"},{"location":"slashing/#parameters","title":"Parameters","text":"<p>The slashing module contains the following parameters:</p> Key Type Example SignedBlocksWindow string (int64) \"100\" MinSignedPerWindow string (dec) \"0.500000000000000000\" DowntimeJailDuration string (ns) \"600000000000\" SlashFractionDoubleSign string (dec) \"0.050000000000000000\" SlashFractionDowntime string (dec) \"0.010000000000000000\""},{"location":"slashing/#cli","title":"CLI","text":"<p>A user can query and interact with the <code>slashing</code> module using the CLI.</p>"},{"location":"slashing/#query","title":"Query","text":"<p>The <code>query</code> commands allow users to query <code>slashing</code> state.</p> <pre><code>simd query slashing --help\n</code></pre>"},{"location":"slashing/#params","title":"params","text":"<p>The <code>params</code> command allows users to query genesis parameters for the slashing module.</p> <pre><code>simd query slashing params [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query slashing params\n</code></pre> <p>Example Output:</p> <pre><code>downtime_jail_duration: 600s\nmin_signed_per_window: \"0.500000000000000000\"\nsigned_blocks_window: \"100\"\nslash_fraction_double_sign: \"0.050000000000000000\"\nslash_fraction_downtime: \"0.010000000000000000\"\n</code></pre>"},{"location":"slashing/#signing-info","title":"signing-info","text":"<p>The <code>signing-info</code> command allows users to query signing-info of the validator using consensus public key.</p> <pre><code>simd query slashing signing-infos [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query slashing signing-info '{\"@type\":\"/cosmos.crypto.ed25519.PubKey\",\"key\":\"Auxs3865HpB/EfssYOzfqNhEJjzys6jD5B6tPgC8=\"}'\n\n</code></pre> <p>Example Output:</p> <pre><code>address: cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c\nindex_offset: \"2068\"\njailed_until: \"1970-01-01T00:00:00Z\"\nmissed_blocks_counter: \"0\"\nstart_height: \"0\"\ntombstoned: false\n</code></pre>"},{"location":"slashing/#signing-infos","title":"signing-infos","text":"<p>The <code>signing-infos</code> command allows users to query signing infos of all validators.</p> <pre><code>simd query slashing signing-infos [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query slashing signing-infos\n</code></pre> <p>Example Output:</p> <pre><code>info:\n- address: cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c\n  index_offset: \"2075\"\n  jailed_until: \"1970-01-01T00:00:00Z\"\n  missed_blocks_counter: \"0\"\n  start_height: \"0\"\n  tombstoned: false\npagination:\n  next_key: null\n  total: \"0\"\n</code></pre>"},{"location":"slashing/#transactions","title":"Transactions","text":"<p>The <code>tx</code> commands allow users to interact with the <code>slashing</code> module.</p> <pre><code>simd tx slashing --help\n</code></pre>"},{"location":"slashing/#unjail_1","title":"unjail","text":"<p>The <code>unjail</code> command allows users to unjail a validator previously jailed for downtime.</p> <pre><code>  simd tx slashing unjail --from mykey [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx slashing unjail --from mykey\n</code></pre>"},{"location":"slashing/#grpc","title":"gRPC","text":"<p>A user can query the <code>slashing</code> module using gRPC endpoints.</p>"},{"location":"slashing/#params_1","title":"Params","text":"<p>The <code>Params</code> endpoint allows users to query the parameters of slashing module.</p> <pre><code>cosmos.slashing.v1beta1.Query/Params\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext localhost:9090 cosmos.slashing.v1beta1.Query/Params\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"params\": {\n    \"signedBlocksWindow\": \"100\",\n    \"minSignedPerWindow\": \"NTAwMDAwMDAwMDAwMDAwMDAw\",\n    \"downtimeJailDuration\": \"600s\",\n    \"slashFractionDoubleSign\": \"NTAwMDAwMDAwMDAwMDAwMDA=\",\n    \"slashFractionDowntime\": \"MTAwMDAwMDAwMDAwMDAwMDA=\"\n  }\n}\n</code></pre>"},{"location":"slashing/#signinginfo","title":"SigningInfo","text":"<p>The SigningInfo queries the signing info of given cons address.</p> <pre><code>cosmos.slashing.v1beta1.Query/SigningInfo\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext -d '{\"cons_address\":\"cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c\"}' localhost:9090 cosmos.slashing.v1beta1.Query/SigningInfo\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"valSigningInfo\": {\n    \"address\": \"cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c\",\n    \"indexOffset\": \"3493\",\n    \"jailedUntil\": \"1970-01-01T00:00:00Z\"\n  }\n}\n</code></pre>"},{"location":"slashing/#signinginfos","title":"SigningInfos","text":"<p>The SigningInfos queries signing info of all validators.</p> <pre><code>cosmos.slashing.v1beta1.Query/SigningInfos\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext localhost:9090 cosmos.slashing.v1beta1.Query/SigningInfos\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"info\": [\n    {\n      \"address\": \"cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c\",\n      \"indexOffset\": \"2467\",\n      \"jailedUntil\": \"1970-01-01T00:00:00Z\"\n    }\n  ],\n  \"pagination\": {\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"slashing/#rest","title":"REST","text":"<p>A user can query the <code>slashing</code> module using REST endpoints.</p>"},{"location":"slashing/#params_2","title":"Params","text":"<pre><code>/cosmos/slashing/v1beta1/params\n</code></pre> <p>Example:</p> <pre><code>curl \"localhost:1317/cosmos/slashing/v1beta1/params\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"params\": {\n    \"signed_blocks_window\": \"100\",\n    \"min_signed_per_window\": \"0.500000000000000000\",\n    \"downtime_jail_duration\": \"600s\",\n    \"slash_fraction_double_sign\": \"0.050000000000000000\",\n    \"slash_fraction_downtime\": \"0.010000000000000000\"\n}\n</code></pre>"},{"location":"slashing/#signing_info","title":"signing_info","text":"<pre><code>/cosmos/slashing/v1beta1/signing_infos/%s\n</code></pre> <p>Example:</p> <pre><code>curl \"localhost:1317/cosmos/slashing/v1beta1/signing_infos/cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"val_signing_info\": {\n    \"address\": \"cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c\",\n    \"start_height\": \"0\",\n    \"index_offset\": \"4184\",\n    \"jailed_until\": \"1970-01-01T00:00:00Z\",\n    \"tombstoned\": false,\n    \"missed_blocks_counter\": \"0\"\n  }\n}\n</code></pre>"},{"location":"slashing/#signing_infos","title":"signing_infos","text":"<pre><code>/cosmos/slashing/v1beta1/signing_infos\n</code></pre> <p>Example:</p> <pre><code>curl \"localhost:1317/cosmos/slashing/v1beta1/signing_infos\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"info\": [\n    {\n      \"address\": \"cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c\",\n      \"start_height\": \"0\",\n      \"index_offset\": \"4169\",\n      \"jailed_until\": \"1970-01-01T00:00:00Z\",\n      \"tombstoned\": false,\n      \"missed_blocks_counter\": \"0\"\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/","title":"Staking","text":""},{"location":"staking/#staking","title":"<code>staking</code>","text":""},{"location":"staking/#abstract","title":"Abstract","text":"<p>This paper specifies the Staking module</p> <p>The module enables Cosmos-SDK based blockchain to support an advanced Proof-of-Stake system. In this system, holders of the native staking token of the chain can become validators and can delegate tokens to validators, ultimately determining the effective validator set for the system.</p>"},{"location":"staking/#contents","title":"Contents","text":""},{"location":"staking/#state","title":"State","text":""},{"location":"staking/#pool","title":"Pool","text":"<p>Pool is used for tracking bonded and not-bonded token supply of the bond denomination.</p>"},{"location":"staking/#lasttotalpower","title":"LastTotalPower","text":"<p>LastTotalPower tracks the total amounts of bonded tokens recorded during the previous end block. Store entries prefixed with \"Last\" must remain unchanged until EndBlock.</p> <ul> <li>LastTotalPower: <code>0x12 -&gt; ProtocolBuffer(sdk.Int)</code></li> </ul>"},{"location":"staking/#params","title":"Params","text":"<p>Params is a module-wide configuration structure that stores system parameters and defines overall functioning of the staking module.</p> <ul> <li>Params: <code>Paramsspace(\"staking\") -&gt; legacy_amino(params)</code></li> </ul> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.1/proto/cosmos/staking/v1beta1/staking.proto#L230-L241</p>"},{"location":"staking/#validator","title":"Validator","text":"<p>Validators can have one of three statuses</p> <ul> <li><code>Unbonded</code>: The validator is not in the active set. They cannot sign blocks and do not earn   rewards. They can receive delegations.</li> <li><code>Bonded</code>: Once the validator receives sufficient bonded tokens they automtically join the   active set during <code>EndBlock</code> and their status is updated to <code>Bonded</code>.   They are signing blocks and receiving rewards. They can receive further delegations.   They can be slashed for misbehavior. Delegators to this validator who unbond their delegation   must wait the duration of the UnbondingTime, a chain-specific param, during which time   they are still slashable for offences of the source validator if those offences were committed   during the period of time that the tokens were bonded.</li> <li><code>Unbonding</code>: When a validator leaves the active set, either by choice or due to slashing, jailing or   tombstoning, an unbonding of all their delegations begins. All delegations must then wait the UnbondingTime   before their tokens are moved to their accounts from the <code>BondedPool</code>.</li> </ul> <p>Validators objects should be primarily stored and accessed by the <code>OperatorAddr</code>, an SDK validator address for the operator of the validator. Two additional indices are maintained per validator object in order to fulfill required lookups for slashing and validator-set updates. A third special index (<code>LastValidatorPower</code>) is also maintained which however remains constant throughout each block, unlike the first two indices which mirror the validator records within a block.</p> <ul> <li>Validators: <code>0x21 | OperatorAddrLen (1 byte) | OperatorAddr -&gt; ProtocolBuffer(validator)</code></li> <li>ValidatorsByConsAddr: <code>0x22 | ConsAddrLen (1 byte) | ConsAddr -&gt; OperatorAddr</code></li> <li>ValidatorsByPower: <code>0x23 | BigEndian(ConsensusPower) | OperatorAddrLen (1 byte) | OperatorAddr -&gt; OperatorAddr</code></li> <li>LastValidatorsPower: <code>0x11 | OperatorAddrLen (1 byte) | OperatorAddr -&gt; ProtocolBuffer(ConsensusPower)</code></li> </ul> <p><code>Validators</code> is the primary index - it ensures that each operator can have only one associated validator, where the public key of that validator can change in the future. Delegators can refer to the immutable operator of the validator, without concern for the changing public key.</p> <p><code>ValidatorByConsAddr</code> is an additional index that enables lookups for slashing. When Tendermint reports evidence, it provides the validator address, so this map is needed to find the operator. Note that the <code>ConsAddr</code> corresponds to the address which can be derived from the validator's <code>ConsPubKey</code>.</p> <p><code>ValidatorsByPower</code> is an additional index that provides a sorted list of potential validators to quickly determine the current active set. Here ConsensusPower is validator.Tokens/10^6 by default. Note that all validators where <code>Jailed</code> is true are not stored within this index.</p> <p><code>LastValidatorsPower</code> is a special index that provides a historical list of the last-block's bonded validators. This index remains constant during a block but is updated during the validator set update process which takes place in <code>EndBlock</code>.</p> <p>Each validator's state is stored in a <code>Validator</code> struct:</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/staking.proto#L65-L99</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/staking.proto#L24-L63</p>"},{"location":"staking/#delegation","title":"Delegation","text":"<p>Delegations are identified by combining <code>DelegatorAddr</code> (the address of the delegator) with the <code>ValidatorAddr</code> Delegators are indexed in the store as follows:</p> <ul> <li>Delegation: <code>0x31 | DelegatorAddrLen (1 byte) | DelegatorAddr | ValidatorAddrLen (1 byte) | ValidatorAddr -&gt; ProtocolBuffer(delegation)</code></li> </ul> <p>Stake holders may delegate coins to validators; under this circumstance their funds are held in a <code>Delegation</code> data structure. It is owned by one delegator, and is associated with the shares for one validator. The sender of the transaction is the owner of the bond.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/staking.proto#L159-L170</p>"},{"location":"staking/#delegator-shares","title":"Delegator Shares","text":"<p>When one Delegates tokens to a Validator they are issued a number of delegator shares based on a dynamic exchange rate, calculated as follows from the total number of tokens delegated to the validator and the number of shares issued so far:</p> <p><code>Shares per Token = validator.TotalShares() / validator.Tokens()</code></p> <p>Only the number of shares received is stored on the DelegationEntry. When a delegator then Undelegates, the token amount they receive is calculated from the number of shares they currently hold and the inverse exchange rate:</p> <p><code>Tokens per Share = validator.Tokens() / validatorShares()</code></p> <p>These <code>Shares</code> are simply an accounting mechanism. They are not a fungible asset. The reason for this mechanism is to simplify the accounting around slashing. Rather than iteratively slashing the tokens of every delegation entry, instead the Validators total bonded tokens can be slashed, effectively reducing the value of each issued delegator share.</p>"},{"location":"staking/#unbondingdelegation","title":"UnbondingDelegation","text":"<p>Shares in a <code>Delegation</code> can be unbonded, but they must for some time exist as an <code>UnbondingDelegation</code>, where shares can be reduced if Byzantine behavior is detected.</p> <p><code>UnbondingDelegation</code> are indexed in the store as:</p> <ul> <li>UnbondingDelegation: <code>0x32 | DelegatorAddrLen (1 byte) | DelegatorAddr | ValidatorAddrLen (1 byte) | ValidatorAddr -&gt; ProtocolBuffer(unbondingDelegation)</code></li> <li>UnbondingDelegationsFromValidator: <code>0x33 | ValidatorAddrLen (1 byte) | ValidatorAddr | DelegatorAddrLen (1 byte) | DelegatorAddr -&gt; nil</code></li> </ul> <p>The first map here is used in queries, to lookup all unbonding delegations for a given delegator, while the second map is used in slashing, to lookup all unbonding delegations associated with a given validator that need to be slashed.</p> <p>A UnbondingDelegation object is created every time an unbonding is initiated.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/staking.proto#L172-L198</p>"},{"location":"staking/#queues","title":"Queues","text":"<p>All queues objects are sorted by timestamp. The time used within any queue is first rounded to the nearest nanosecond then sorted. The sortable time format used is a slight modification of the RFC3339Nano and uses the the format string <code>\"2006-01-02T15:04:05.000000000\"</code>. Notably this format:</p> <ul> <li>right pads all zeros</li> <li>drops the time zone info (uses UTC)</li> </ul> <p>In all cases, the stored timestamp represents the maturation time of the queue element.</p>"},{"location":"staking/#unbondingdelegationqueue","title":"UnbondingDelegationQueue","text":"<p>For the purpose of tracking progress of unbonding delegations the unbonding delegations queue is kept.</p> <ul> <li>UnbondingDelegation: <code>0x41 | format(time) -&gt; []DVPair</code></li> </ul> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/staking.proto#L123-L133</p>"},{"location":"staking/#validatorqueue","title":"ValidatorQueue","text":"<p>For the purpose of tracking progress of unbonding validators the validator queue is kept.</p> <ul> <li>ValidatorQueueTime: <code>0x43 | format(time) -&gt; []sdk.ValAddress</code></li> </ul> <p>The stored object as each key is an array of validator operator addresses from which the validator object can be accessed. Typically it is expected that only a single validator record will be associated with a given timestamp however it is possible that multiple validators exist in the queue at the same location.</p>"},{"location":"staking/#historicalinfo","title":"HistoricalInfo","text":"<p>HistoricalInfo objects are stored and pruned at each block such that the staking keeper persists the <code>n</code> most recent historical info defined by staking module parameter: <code>HistoricalEntries</code>.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/staking.proto#L15-L22</p> <p>At each BeginBlock, the staking keeper will persist the current Header and the Validators that committed the current block in a <code>HistoricalInfo</code> object. The Validators are sorted on their address to ensure that they are in a determisnistic order. The oldest HistoricalEntries will be pruned to ensure that there only exist the parameter-defined number of historical entries.</p>"},{"location":"staking/#state-transitions","title":"State Transitions","text":"<p>This document describes the state transition operations pertaining to:</p>"},{"location":"staking/#validators","title":"Validators","text":"<p>State transitions in validators are performed on every <code>EndBlock</code> in order to check for changes in the active <code>ValidatorSet</code>.</p> <p>A validator can be <code>Unbonded</code>, <code>Unbonding</code> or <code>Bonded</code>. <code>Unbonded</code> and <code>Unbonding</code> are collectively called <code>Not Bonded</code>. A validator can move directly between all the states, except for from <code>Bonded</code> to <code>Unbonded</code>.</p>"},{"location":"staking/#not-bonded-to-bonded","title":"Not bonded to Bonded","text":"<p>The following transition occurs when a validator's ranking in the <code>ValidatorPowerIndex</code> surpasses that of the <code>LastValidator</code>.</p> <ul> <li>set <code>validator.Status</code> to <code>Bonded</code></li> <li>send the <code>validator.Tokens</code> from the <code>NotBondedTokens</code> to the <code>BondedPool</code> <code>ModuleAccount</code></li> <li>delete the existing record from <code>ValidatorByPowerIndex</code></li> <li>add a new updated record to the <code>ValidatorByPowerIndex</code></li> <li>update the <code>Validator</code> object for this validator</li> <li>if it exists, delete any <code>ValidatorQueue</code> record for this validator</li> </ul>"},{"location":"staking/#bonded-to-unbonding","title":"Bonded to Unbonding","text":"<p>When a validator begins the unbonding process the following operations occur:</p> <ul> <li>send the <code>validator.Tokens</code> from the <code>BondedPool</code> to the <code>NotBondedTokens</code> <code>ModuleAccount</code></li> <li>set <code>validator.Status</code> to <code>Unbonding</code></li> <li>delete the existing record from <code>ValidatorByPowerIndex</code></li> <li>add a new updated record to the <code>ValidatorByPowerIndex</code></li> <li>update the <code>Validator</code> object for this validator</li> <li>insert a new record into the <code>ValidatorQueue</code> for this validator</li> </ul>"},{"location":"staking/#unbonding-to-unbonded","title":"Unbonding to Unbonded","text":"<p>A validator moves from unbonding to unbonded when the <code>ValidatorQueue</code> object moves from bonded to unbonded</p> <ul> <li>update the <code>Validator</code> object for this validator</li> <li>set <code>validator.Status</code> to <code>Unbonded</code></li> </ul>"},{"location":"staking/#jailunjail","title":"Jail/Unjail","text":"<p>when a validator is jailed it is effectively removed from the Tendermint set. this process may be also be reversed. the following operations occur:</p> <ul> <li>set <code>Validator.Jailed</code> and update object</li> <li>if jailed delete record from <code>ValidatorByPowerIndex</code></li> <li>if unjailed add record to <code>ValidatorByPowerIndex</code></li> </ul> <p>Jailed validators are not present in any of the following stores:</p> <ul> <li>the power store (from consensus power to address)</li> </ul>"},{"location":"staking/#delegations","title":"Delegations","text":""},{"location":"staking/#delegate","title":"Delegate","text":"<p>When a delegation occurs both the validator and the delegation objects are affected</p> <ul> <li>determine the delegators shares based on tokens delegated and the validator's exchange rate</li> <li>remove tokens from the sending account</li> <li>add shares the delegation object or add them to a created validator object</li> <li>add new delegator shares and update the <code>Validator</code> object</li> <li>transfer the <code>delegation.Amount</code> from the delegator's account to the <code>BondedPool</code> or the <code>NotBondedPool</code> <code>ModuleAccount</code> depending if the <code>validator.Status</code> is <code>Bonded</code> or not</li> <li>delete the existing record from <code>ValidatorByPowerIndex</code></li> <li>add an new updated record to the <code>ValidatorByPowerIndex</code></li> </ul>"},{"location":"staking/#begin-unbonding","title":"Begin Unbonding","text":"<p>As a part of the Undelegate and Complete Unbonding state transitions Unbond Delegation may be called.</p> <ul> <li>subtract the unbonded shares from delegator</li> <li>if the validator is <code>Unbonding</code> or <code>Bonded</code> add the tokens to an <code>UnbondingDelegation</code> Entry</li> <li>if the validator is <code>Unbonded</code> send the tokens directly to the withdraw   account</li> <li>update the delegation or remove the delegation if there are no more shares</li> <li>if the delegation is the operator of the validator and no more shares exist then trigger a jail validator</li> <li>update the validator with removed the delegator shares and associated coins</li> <li>if the validator state is <code>Bonded</code>, transfer the <code>Coins</code> worth of the unbonded   shares from the <code>BondedPool</code> to the <code>NotBondedPool</code> <code>ModuleAccount</code></li> <li>remove the validator if it is unbonded and there are no more delegation shares.</li> </ul>"},{"location":"staking/#complete-unbonding","title":"Complete Unbonding","text":"<p>For undelegations which do not complete immediately, the following operations occur when the unbonding delegation queue element matures:</p> <ul> <li>remove the entry from the <code>UnbondingDelegation</code> object</li> <li>transfer the tokens from the <code>NotBondedPool</code> <code>ModuleAccount</code> to the delegator <code>Account</code></li> </ul>"},{"location":"staking/#slashing","title":"Slashing","text":""},{"location":"staking/#slash-validator","title":"Slash Validator","text":"<p>When a Validator is slashed, the following occurs:</p> <ul> <li>The total <code>slashAmount</code> is calculated as the <code>slashFactor</code> (a chain parameter) * <code>TokensFromConsensusPower</code>,   the total number of tokens bonded to the validator at the time of the infraction.</li> <li>Every unbonding delegation and pseudo-unbonding redelegation such that the infraction occured before the unbonding or   redelegation began from the validator are slashed by the <code>slashFactor</code> percentage of the initialBalance.</li> <li>Each amount slashed from unbonding delegations is subtracted from the   total slash amount.</li> <li>The <code>remaingSlashAmount</code> is then slashed from the validator's tokens in the <code>BondedPool</code> or   <code>NonBondedPool</code> depending on the validator's status. This reduces the total supply of tokens.</li> </ul> <p>In the case of a slash due to any infraction that requires evidence to submitted (for example double-sign), the slash occurs at the block where the evidence is included, not at the block where the infraction occured. Put otherwise, validators are not slashed retroactively, only when they are caught.</p>"},{"location":"staking/#slash-unbonding-delegation","title":"Slash Unbonding Delegation","text":"<p>When a validator is slashed, so are those unbonding delegations from the validator that began unbonding after the time of the infraction. Every entry in every unbonding delegation from the validator is slashed by <code>slashFactor</code>. The amount slashed is calculated from the <code>InitialBalance</code> of the delegation and is capped to prevent a resulting negative balance. Completed (or mature) unbondings are not slashed.</p>"},{"location":"staking/#how-shares-are-calculated","title":"How Shares are calculated","text":"<p>At any given point in time, each validator has a number of tokens, <code>T</code>, and has a number of shares issued, <code>S</code>. Each delegator, <code>i</code>, holds a number of shares, <code>S_i</code>. The number of tokens is the sum of all tokens delegated to the validator, plus the rewards, minus the slashes.</p> <p>The delegator is entitled to a portion of the underlying tokens proportional to their proportion of shares. So delegator <code>i</code> is entitled to <code>T * S_i / S</code> of the validator's tokens.</p> <p>When a delegator delegates new tokens to the validator, they receive a number of shares proportional to their contribution. So when delegator <code>j</code> delegates <code>T_j</code> tokens, they receive <code>S_j = S * T_j / T</code> shares. The total number of tokens is now <code>T + T_j</code>, and the total number of shares is <code>S + S_j</code>. <code>j</code>s proportion of the shares is the same as their proportion of the total tokens contributed: <code>(S + S_j) / S = (T + T_j) / T</code>.</p> <p>A special case is the initial delegation, when <code>T = 0</code> and <code>S = 0</code>, so <code>T_j / T</code> is undefined. For the initial delegation, delegator <code>j</code> who delegates <code>T_j</code> tokens receive <code>S_j = T_j</code> shares. So a validator that hasn't received any rewards and has not been slashed will have <code>T = S</code>.</p>"},{"location":"staking/#messages","title":"Messages","text":"<p>In this section we describe the processing of the staking messages and the corresponding updates to the state. All created/modified state objects specified by each message are defined within the state section.</p>"},{"location":"staking/#msgcreatevalidator","title":"MsgCreateValidator","text":"<p>A validator is created using the <code>MsgCreateValidator</code> message. The validator must be created with an initial delegation from the operator.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L16-L17</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L35-L51</p> <p>This message is expected to fail if:</p> <ul> <li>another validator with this operator address is already registered</li> <li>another validator with this pubkey is already registered</li> <li>the initial self-delegation tokens are of a denom not specified as the bonding denom</li> <li>the commission parameters are faulty, namely:</li> <li><code>MaxRate</code> is either &gt; 1 or &lt; 0</li> <li>the initial <code>Rate</code> is either negative or &gt; <code>MaxRate</code></li> <li>the initial <code>MaxChangeRate</code> is either negative or &gt; <code>MaxRate</code></li> <li>the description fields are too large</li> </ul> <p>This message creates and stores the <code>Validator</code> object at appropriate indexes. Additionally a self-delegation is made with the initial tokens delegation tokens <code>Delegation</code>. The validator always starts as unbonded but may be bonded in the first end-block.</p>"},{"location":"staking/#msgeditvalidator","title":"MsgEditValidator","text":"<p>The <code>Description</code>, <code>CommissionRate</code> of a validator can be updated using the <code>MsgEditValidator</code> message.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L19-L20</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L56-L76</p> <p>This message is expected to fail if:</p> <ul> <li>the initial <code>CommissionRate</code> is either negative or &gt; <code>MaxRate</code></li> <li>the <code>CommissionRate</code> has already been updated within the previous 24 hours</li> <li>the <code>CommissionRate</code> is &gt; <code>MaxChangeRate</code></li> <li>the description fields are too large</li> </ul> <p>This message stores the updated <code>Validator</code> object.</p>"},{"location":"staking/#msgdelegate","title":"MsgDelegate","text":"<p>Within this message the delegator provides coins, and in return receives some amount of their validator's (newly created) delegator-shares that are assigned to <code>Delegation.Shares</code>.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L22-L24</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90</p> <p>This message is expected to fail if:</p> <ul> <li>the validator does not exist</li> <li>the <code>Amount</code> <code>Coin</code> has a denomination different than one defined by <code>params.BondDenom</code></li> <li>the exchange rate is invalid, meaning the validator has no tokens (due to slashing) but there are outstanding shares</li> <li>the amount delegated is less than the minimum allowed delegation</li> </ul> <p>If an existing <code>Delegation</code> object for provided addresses does not already exist then it is created as part of this message otherwise the existing <code>Delegation</code> is updated to include the newly received shares.</p> <p>The delegator receives newly minted shares at the current exchange rate. The exchange rate is the number of existing shares in the validator divided by the number of currently delegated tokens.</p> <p>The validator is updated in the <code>ValidatorByPower</code> index, and the delegation is tracked in validator object in the <code>Validators</code> index.</p> <p>It is possible to delegate to a jailed validator, the only difference being it will not be added to the power index until it is unjailed.</p> <p></p>"},{"location":"staking/#msgundelegate","title":"MsgUndelegate","text":"<p>The <code>MsgUndelegate</code> message allows delegators to undelegate their tokens from validator.</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L30-L32</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121</p> <p>This message returns a response containing the completion time of the undelegation:</p> <p>+++ https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L123-L126</p> <p>This message is expected to fail if:</p> <ul> <li>the delegation doesn't exist</li> <li>the validator doesn't exist</li> <li>the delegation has less shares than the ones worth of <code>Amount</code></li> <li>existing <code>UnbondingDelegation</code> has maximum entries as defined by <code>params.MaxEntries</code></li> <li>the <code>Amount</code> has a denomination different than one defined by <code>params.BondDenom</code></li> </ul> <p>When this message is processed the following actions occur:</p> <ul> <li>validator's <code>DelegatorShares</code> and the delegation's <code>Shares</code> are both reduced by the message <code>SharesAmount</code></li> <li>calculate the token worth of the shares remove that amount tokens held within the validator</li> <li>with those removed tokens, if the validator is:</li> <li><code>Bonded</code> - add them to an entry in <code>UnbondingDelegation</code> (create <code>UnbondingDelegation</code> if it doesn't exist) with a completion time a full unbonding period from the current time. Update pool shares to reduce BondedTokens and increase NotBondedTokens by token worth of the shares.</li> <li><code>Unbonding</code> - add them to an entry in <code>UnbondingDelegation</code> (create <code>UnbondingDelegation</code> if it doesn't exist) with the same completion time as the validator (<code>UnbondingMinTime</code>).</li> <li><code>Unbonded</code> - then send the coins the message <code>DelegatorAddr</code></li> <li>if there are no more <code>Shares</code> in the delegation, then the delegation object is removed from the store</li> <li>under this situation if the delegation is the validator's self-delegation then also jail the validator.</li> </ul> <p></p>"},{"location":"staking/#begin-block","title":"Begin-Block","text":"<p>Each abci begin block call, the historical info will get stored and pruned according to the <code>HistoricalEntries</code> parameter.</p>"},{"location":"staking/#historical-info-tracking","title":"Historical Info Tracking","text":"<p>If the <code>HistoricalEntries</code> parameter is 0, then the <code>BeginBlock</code> performs a no-op.</p> <p>Otherwise, the latest historical info is stored under the key <code>historicalInfoKey|height</code>, while any entries older than <code>height - HistoricalEntries</code> is deleted. In most cases, this results in a single entry being pruned per block. However, if the parameter <code>HistoricalEntries</code> has changed to a lower value there will be multiple entries in the store that must be pruned.</p>"},{"location":"staking/#end-block","title":"End-Block","text":"<p>Each abci end block call, the operations to update queues and validator set changes are specified to execute.</p>"},{"location":"staking/#validator-set-changes","title":"Validator Set Changes","text":"<p>The staking validator set is updated during this process by state transitions that run at the end of every block. As a part of this process any updated validators are also returned back to Tendermint for inclusion in the Tendermint validator set which is responsible for validating Tendermint messages at the consensus layer. Operations are as following:</p> <ul> <li>the new validator set is taken as the top <code>params.MaxValidators</code> number of   validators retrieved from the <code>ValidatorsByPower</code> index</li> <li>the previous validator set is compared with the new validator set:</li> <li>missing validators begin unbonding and their <code>Tokens</code> are transferred from the      <code>BondedPool</code> to the <code>NotBondedPool</code> <code>ModuleAccount</code></li> <li>new validators are instantly bonded and their <code>Tokens</code> are transferred from the      <code>NotBondedPool</code> to the <code>BondedPool</code> <code>ModuleAccount</code></li> </ul> <p>In all cases, any validators leaving or entering the bonded validator set or changing balances and staying within the bonded validator set incur an update message reporting their new consensus power which is passed back to Tendermint.</p> <p>The <code>LastTotalPower</code> and <code>LastValidatorsPower</code> hold the state of the total power and validator power from the end of the last block, and are used to check for changes that have occured in <code>ValidatorsByPower</code> and the total new power, which is calculated during <code>EndBlock</code>.</p>"},{"location":"staking/#queues_1","title":"Queues","text":"<p>Within staking, certain state-transitions are not instantaneous but take place over a duration of time (typically the unbonding period). When these transitions are mature certain operations must take place in order to complete the state operation. This is achieved through the use of queues which are checked/processed at the end of each block.</p>"},{"location":"staking/#unbonding-validators","title":"Unbonding Validators","text":"<p>When a validator is kicked out of the bonded validator set (either through being jailed, or not having sufficient bonded tokens) it begins the unbonding process along with all its delegations begin unbonding (while still being delegated to this validator). At this point the validator is said to be an \"unbonding validator\", whereby it will mature to become an \"unbonded validator\" after the unbonding period has passed.</p> <p>Each block the validator queue is to be checked for mature unbonding validators (namely with a completion time &lt;= current time and completion height &lt;= current block height). At this point any mature validators which do not have any delegations remaining are deleted from state. For all other mature unbonding validators that still have remaining delegations, the <code>validator.Status</code> is switched from <code>types.Unbonding</code> to <code>types.Unbonded</code>.</p>"},{"location":"staking/#unbonding-delegations","title":"Unbonding Delegations","text":"<p>Complete the unbonding of all mature <code>UnbondingDelegations.Entries</code> within the <code>UnbondingDelegations</code> queue with the following procedure:</p> <ul> <li>transfer the balance coins to the delegator's wallet address</li> <li>remove the mature entry from <code>UnbondingDelegation.Entries</code></li> <li>remove the <code>UnbondingDelegation</code> object from the store if there are no   remaining entries.</li> </ul>"},{"location":"staking/#hooks","title":"Hooks","text":"<p>Other modules may register operations to execute when a certain event has occurred within staking.  These events can be registered to execute either right <code>Before</code> or <code>After</code> the staking event (as per the hook name). The following hooks can registered with staking:</p> <ul> <li><code>AfterValidatorCreated(Context, ValAddress)</code></li> <li>called when a validator is created</li> <li><code>BeforeValidatorModified(Context, ValAddress)</code></li> <li>called when a validator's state is changed</li> <li><code>AfterValidatorRemoved(Context, ConsAddress, ValAddress)</code></li> <li>called when a validator is deleted</li> <li><code>AfterValidatorBonded(Context, ConsAddress, ValAddress)</code></li> <li>called when a validator is bonded</li> <li><code>AfterValidatorBeginUnbonding(Context, ConsAddress, ValAddress)</code></li> <li>called when a validator begins unbonding</li> <li><code>BeforeDelegationCreated(Context, AccAddress, ValAddress)</code></li> <li>called when a delegation is created</li> <li><code>BeforeDelegationRemoved(Context, AccAddress, ValAddress)</code></li> <li>called when a delegation is removed</li> </ul>"},{"location":"staking/#events","title":"Events","text":"<p>The staking module emits the following events:</p>"},{"location":"staking/#endblocker","title":"EndBlocker","text":"Type Attribute Key Attribute Value complete_unbonding amount {totalUnbondingAmount} complete_unbonding validator {validatorAddress} complete_unbonding delegator {delegatorAddress} complete_redelegation amount {totalRedelegationAmount} complete_redelegation source_validator {srcValidatorAddress} complete_redelegation destination_validator {dstValidatorAddress} complete_redelegation delegator {delegatorAddress}"},{"location":"staking/#msgs","title":"Msg's","text":""},{"location":"staking/#msgcreatevalidator_1","title":"MsgCreateValidator","text":"Type Attribute Key Attribute Value create_validator validator {validatorAddress} create_validator amount {delegationAmount} message module staking message action create_validator message sender {senderAddress}"},{"location":"staking/#msgeditvalidator_1","title":"MsgEditValidator","text":"Type Attribute Key Attribute Value edit_validator commission_rate {commissionRate} edit_validator min_self_delegation {minSelfDelegation} message module staking message action edit_validator message sender {senderAddress}"},{"location":"staking/#msgdelegate_1","title":"MsgDelegate","text":"Type Attribute Key Attribute Value delegate validator {validatorAddress} delegate amount {delegationAmount} message module staking message action delegate message sender {senderAddress}"},{"location":"staking/#msgundelegate_1","title":"MsgUndelegate","text":"Type Attribute Key Attribute Value unbond validator {validatorAddress} unbond amount {unbondAmount} unbond completion_time [0] {completionTime} message module staking message action begin_unbonding message sender {senderAddress} <ul> <li>[0] Time is formatted in the RFC3339 standard</li> </ul>"},{"location":"staking/#parameters","title":"Parameters","text":"<p>The staking module contains the following parameters:</p> Key Type Example UnbondingTime string (time ns) \"259200000000000\" MaxValidators uint16 100 KeyMaxEntries uint16 7 HistoricalEntries uint16 3 BondDenom string \"stake\" PowerReduction string \"1000000\""},{"location":"staking/#client","title":"Client","text":""},{"location":"staking/#cli","title":"CLI","text":"<p>A user can query and interact with the <code>staking</code> module using the CLI.</p>"},{"location":"staking/#query","title":"Query","text":"<p>The <code>query</code> commands allows users to query <code>staking</code> state.</p> <pre><code>simd query staking --help\n</code></pre>"},{"location":"staking/#delegation_1","title":"delegation","text":"<p>The <code>delegation</code> command allows users to query delegations for an individual delegator on an individual validator.</p> <p>Usage:</p> <pre><code>simd query staking delegation [delegator-addr] [validator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking delegation cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre> <p>Example Output:</p> <pre><code>balance:\n  amount: \"10000000000\"\n  denom: stake\ndelegation:\n  delegator_address: cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\n  shares: \"10000000000.000000000000000000\"\n  validator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre>"},{"location":"staking/#delegations_1","title":"delegations","text":"<p>The <code>delegations</code> command allows users to query delegations for an individual delegator on all validators.</p> <p>Usage:</p> <pre><code>simd query staking delegations [delegator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking delegations cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\n</code></pre> <p>Example Output:</p> <pre><code>delegation_responses:\n- balance:\n    amount: \"10000000000\"\n    denom: stake\n  delegation:\n    delegator_address: cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\n    shares: \"10000000000.000000000000000000\"\n    validator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n- balance:\n    amount: \"10000000000\"\n    denom: stake\n  delegation:\n    delegator_address: cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\n    shares: \"10000000000.000000000000000000\"\n    validator_address: cosmosvaloper1x20lytyf6zkcrv5edpkfkn8sz578qg5sqfyqnp\npagination:\n  next_key: null\n  total: \"0\"\n</code></pre>"},{"location":"staking/#delegations-to","title":"delegations-to","text":"<p>The <code>delegations-to</code> command allows users to query delegations on an individual validator.</p> <p>Usage:</p> <pre><code>simd query staking delegations-to [validator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking delegations-to cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre> <p>Example Output:</p> <pre><code>- balance:\n    amount: \"504000000\"\n    denom: stake\n  delegation:\n    delegator_address: cosmos1q2qwwynhv8kh3lu5fkeex4awau9x8fwt45f5cp\n    shares: \"504000000.000000000000000000\"\n    validator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n- balance:\n    amount: \"78125000000\"\n    denom: uixo\n  delegation:\n    delegator_address: cosmos1qvppl3479hw4clahe0kwdlfvf8uvjtcd99m2ca\n    shares: \"78125000000.000000000000000000\"\n    validator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\npagination:\n  next_key: null\n  total: \"0\"\n</code></pre>"},{"location":"staking/#historical-info","title":"historical-info","text":"<p>The <code>historical-info</code> command allows users to query historical information at given height.</p> <p>Usage:</p> <pre><code>simd query staking historical-info [height] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking historical-info 10\n</code></pre> <p>Example Output:</p> <pre><code>header:\n  app_hash: Lbx8cXpI868wz8sgp4qPYVrlaKjevR5WP/IjUxwp3oo=\n  chain_id: testnet\n  consensus_hash: BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=\n  data_hash: 47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\n  evidence_hash: 47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\n  height: \"10\"\n  last_block_id:\n    hash: RFbkpu6pWfSThXxKKl6EZVDnBSm16+U0l0xVjTX08Fk=\n    part_set_header:\n      hash: vpIvXD4rxD5GM4MXGz0Sad9I7//iVYLzZsEU4BVgWIU=\n      total: 1\n  last_commit_hash: Ne4uXyx4QtNp4Zx89kf9UK7oG9QVbdB6e7ZwZkhy8K0=\n  last_results_hash: 47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\n  next_validators_hash: nGBgKeWBjoxeKFti00CxHsnULORgKY4LiuQwBuUrhCs=\n  proposer_address: mMEP2c2IRPLr99LedSRtBg9eONM=\n  time: \"2021-10-01T06:00:49.785790894Z\"\n  validators_hash: nGBgKeWBjoxeKFti00CxHsnULORgKY4LiuQwBuUrhCs=\n  version:\n    app: \"0\"\n    block: \"11\"\nvalset:\n- commission:\n    commission_rates:\n      max_change_rate: \"0.010000000000000000\"\n      max_rate: \"0.200000000000000000\"\n      rate: \"0.100000000000000000\"\n    update_time: \"2021-10-01T05:52:50.380144238Z\"\n  consensus_pubkey:\n    '@type': /cosmos.crypto.ed25519.PubKey\n    key: Auxs3865HpB/EfssYOzfqNhEJjzys2Fo6jD5B8tPgC8=\n  delegator_shares: \"10000000.000000000000000000\"\n  description:\n    details: \"\"\n    identity: \"\"\n    moniker: myvalidator\n    security_contact: \"\"\n    website: \"\"\n  jailed: false\n  min_self_delegation: \"1\"\n  operator_address: cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\n  status: BOND_STATUS_BONDED\n  tokens: \"10000000\"\n  unbonding_height: \"0\"\n  unbonding_time: \"1970-01-01T00:00:00Z\"\n</code></pre>"},{"location":"staking/#params_1","title":"params","text":"<p>The <code>params</code> command allows users to query values set as staking parameters.</p> <p>Usage:</p> <pre><code>simd query staking params [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking params\n</code></pre> <p>Example Output:</p> <pre><code>bond_denom: stake\nhistorical_entries: 10000\nmax_entries: 7\nmax_validators: 50\nunbonding_time: 1814400s\n</code></pre>"},{"location":"staking/#pool_1","title":"pool","text":"<p>The <code>pool</code> command allows users to query values for amounts stored in the staking pool.</p> <p>Usage:</p> <pre><code>simd q staking pool [flags]\n</code></pre> <p>Example:</p> <pre><code>simd q staking pool\n</code></pre> <p>Example Output:</p> <pre><code>bonded_tokens: \"10000000\"\nnot_bonded_tokens: \"0\"\n</code></pre>"},{"location":"staking/#redelegation","title":"redelegation","text":"<p>The <code>redelegation</code> command allows users to query a redelegation record based on delegator and a source and destination validator address.</p> <p>Usage:</p> <pre><code>simd query staking redelegation [delegator-addr] [src-validator-addr] [dst-validator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking redelegation cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p cosmosvaloper1l2rsakp388kuv9k8qzq6lrm9taddae7fpx59wm cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre> <p>Example Output:</p> <pre><code>pagination: null\nredelegation_responses:\n- entries:\n  - balance: \"50000000\"\n    redelegation_entry:\n      completion_time: \"2021-10-24T20:33:21.960084845Z\"\n      creation_height: 2.382847e+06\n      initial_balance: \"50000000\"\n      shares_dst: \"50000000.000000000000000000\"\n  - balance: \"5000000000\"\n    redelegation_entry:\n      completion_time: \"2021-10-25T21:33:54.446846862Z\"\n      creation_height: 2.397271e+06\n      initial_balance: \"5000000000\"\n      shares_dst: \"5000000000.000000000000000000\"\n  redelegation:\n    delegator_address: cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\n    entries: null\n    validator_dst_address: cosmosvaloper1l2rsakp388kuv9k8qzq6lrm9taddae7fpx59wm\n    validator_src_address: cosmosvaloper1l2rsakp388kuv9k8qzq6lrm9taddae7fpx59wm\n</code></pre>"},{"location":"staking/#unbonding-delegation","title":"unbonding-delegation","text":"<p>The <code>unbonding-delegation</code> command allows users to query unbonding delegations for an individual delegator on an individual validator.</p> <p>Usage:</p> <pre><code>simd query staking unbonding-delegation [delegator-addr] [validator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking unbonding-delegation cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre> <p>Example Output:</p> <pre><code>delegator_address: cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\nentries:\n- balance: \"52000000\"\n  completion_time: \"2021-11-02T11:35:55.391594709Z\"\n  creation_height: \"55078\"\n  initial_balance: \"52000000\"\nvalidator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre>"},{"location":"staking/#unbonding-delegations_1","title":"unbonding-delegations","text":"<p>The <code>unbonding-delegations</code> command allows users to query all unbonding-delegations records for one delegator.</p> <p>Usage:</p> <pre><code>simd query staking unbonding-delegations [delegator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking unbonding-delegations cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\n</code></pre> <p>Example Output:</p> <pre><code>pagination:\n  next_key: null\n  total: \"0\"\nunbonding_responses:\n- delegator_address: cosmos1gghjut3ccd8ay0zduzj64hwre2fxs9ld75ru9p\n  entries:\n  - balance: \"52000000\"\n    completion_time: \"2021-11-02T11:35:55.391594709Z\"\n    creation_height: \"55078\"\n    initial_balance: \"52000000\"\n  validator_address: cosmosvaloper1t8ehvswxjfn3ejzkjtntcyrqwvmvuknzmvtaaa\n\n</code></pre>"},{"location":"staking/#unbonding-delegations-from","title":"unbonding-delegations-from","text":"<p>The <code>unbonding-delegations-from</code> command allows users to query delegations that are unbonding from a validator.</p> <p>Usage:</p> <pre><code>simd query staking unbonding-delegations-from [validator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking unbonding-delegations-from cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre> <p>Example Output:</p> <pre><code>pagination:\n  next_key: null\n  total: \"0\"\nunbonding_responses:\n- delegator_address: cosmos1qqq9txnw4c77sdvzx0tkedsafl5s3vk7hn53fn\n  entries:\n  - balance: \"150000000\"\n    completion_time: \"2021-11-01T21:41:13.098141574Z\"\n    creation_height: \"46823\"\n    initial_balance: \"150000000\"\n  validator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n- delegator_address: cosmos1peteje73eklqau66mr7h7rmewmt2vt99y24f5z\n  entries:\n  - balance: \"24000000\"\n    completion_time: \"2021-10-31T02:57:18.192280361Z\"\n    creation_height: \"21516\"\n    initial_balance: \"24000000\"\n  validator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre>"},{"location":"staking/#validator_1","title":"validator","text":"<p>The <code>validator</code> command allows users to query details about an individual validator.</p> <p>Usage:</p> <pre><code>simd query staking validator [validator-addr] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking validator cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n</code></pre> <p>Example Output:</p> <pre><code>commission:\n  commission_rates:\n    max_change_rate: \"0.020000000000000000\"\n    max_rate: \"0.200000000000000000\"\n    rate: \"0.050000000000000000\"\n  update_time: \"2021-10-01T19:24:52.663191049Z\"\nconsensus_pubkey:\n  '@type': /cosmos.crypto.ed25519.PubKey\n  key: sIiexdJdYWn27+7iUHQJDnkp63gq/rzUq1Y+fxoGjXc=\ndelegator_shares: \"32948270000.000000000000000000\"\ndescription:\n  details: Witval is the validator arm from Vitwit. Vitwit is into software consulting\n    and services business since 2015. We are working closely with Cosmos ecosystem\n    since 2018. We are also building tools for the ecosystem, Aneka is our explorer\n    for the cosmos ecosystem.\n  identity: 51468B615127273A\n  moniker: Witval\n  security_contact: \"\"\n  website: \"\"\njailed: false\nmin_self_delegation: \"1\"\noperator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\nstatus: BOND_STATUS_BONDED\ntokens: \"32948270000\"\nunbonding_height: \"0\"\nunbonding_time: \"1970-01-01T00:00:00Z\"\n</code></pre>"},{"location":"staking/#validators_1","title":"validators","text":"<p>The <code>validators</code> command allows users to query details about all validators on a network.</p> <p>Usage:</p> <pre><code>simd query staking validators [flags]\n</code></pre> <p>Example:</p> <pre><code>simd query staking validators\n</code></pre> <p>Example Output:</p> <pre><code>pagination:\n  next_key: FPTi7TKAjN63QqZh+BaXn6gBmD5/\n  total: \"0\"\nvalidators:\ncommission:\n  commission_rates:\n    max_change_rate: \"0.020000000000000000\"\n    max_rate: \"0.200000000000000000\"\n    rate: \"0.050000000000000000\"\n  update_time: \"2021-10-01T19:24:52.663191049Z\"\nconsensus_pubkey:\n  '@type': /cosmos.crypto.ed25519.PubKey\n  key: sIiexdJdYWn27+7iUHQJDnkp63gq/rzUq1Y+fxoGjXc=\ndelegator_shares: \"32948270000.000000000000000000\"\ndescription:\n    details: Witval is the validator arm from Vitwit. Vitwit is into software consulting\n      and services business since 2015. We are working closely with Cosmos ecosystem\n      since 2018. We are also building tools for the ecosystem, Aneka is our explorer\n      for the cosmos ecosystem.\n    identity: 51468B615127273A\n    moniker: Witval\n    security_contact: \"\"\n    website: \"\"\n  jailed: false\n  min_self_delegation: \"1\"\n  operator_address: cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj\n  status: BOND_STATUS_BONDED\n  tokens: \"32948270000\"\n  unbonding_height: \"0\"\n  unbonding_time: \"1970-01-01T00:00:00Z\"\n- commission:\n    commission_rates:\n      max_change_rate: \"0.100000000000000000\"\n      max_rate: \"0.200000000000000000\"\n      rate: \"0.050000000000000000\"\n    update_time: \"2021-10-04T18:02:21.446645619Z\"\n  consensus_pubkey:\n    '@type': /cosmos.crypto.ed25519.PubKey\n    key: GDNpuKDmCg9GnhnsiU4fCWktuGUemjNfvpCZiqoRIYA=\n  delegator_shares: \"559343421.000000000000000000\"\n  description:\n    details: Noderunners is a professional validator in POS networks. We have a huge\n      node running experience, reliable soft and hardware. Our commissions are always\n      low, our support to delegators is always full. Stake with us and start receiving\n      your Cosmos rewards now!\n    identity: 812E82D12FEA3493\n    moniker: Noderunners\n    security_contact: info@noderunners.biz\n    website: http://noderunners.biz\n  jailed: false\n  min_self_delegation: \"1\"\n  operator_address: cosmosvaloper1q5ku90atkhktze83j9xjaks2p7uruag5zp6wt7\n  status: BOND_STATUS_BONDED\n  tokens: \"559343421\"\n  unbonding_height: \"0\"\n  unbonding_time: \"1970-01-01T00:00:00Z\"\n</code></pre>"},{"location":"staking/#transactions","title":"Transactions","text":"<p>The <code>tx</code> commands allows users to interact with the <code>staking</code> module.</p> <pre><code>simd tx staking --help\n</code></pre>"},{"location":"staking/#create-validator","title":"create-validator","text":"<p>The command <code>create-validator</code> allows users to create new validator initialized with a self-delegation to it.</p> <p>Usage:</p> <pre><code>simd tx staking create-validator [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx staking create-validator \\\n  --amount=1000000stake \\\n  --pubkey=$(simd tendermint show-validator) \\\n  --moniker=\"my-moniker\" \\\n  --website=\"https://myweb.site\" \\\n  --details=\"description of your validator\" \\\n  --chain-id=\"name_of_chain_id\" \\\n  --commission-rate=\"0.10\" \\\n  --commission-max-rate=\"0.20\" \\\n  --commission-max-change-rate=\"0.01\" \\\n  --min-self-delegation=\"1\" \\\n  --gas=\"auto\" \\\n  --gas-adjustment=\"1.2\" \\\n  --gas-prices=\"0.025stake\" \\\n  --from=mykey\n</code></pre>"},{"location":"staking/#delegate_1","title":"delegate","text":"<p>The command <code>delegate</code> allows users to delegate liquid tokens to a validator.</p> <p>Usage:</p> <pre><code>simd tx staking delegate [validator-addr] [amount] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx staking delegate cosmosvaloper1l2rsakp388kuv9k8qzq6lrm9taddae7fpx59wm 1000stake --from mykey\n</code></pre>"},{"location":"staking/#edit-validator","title":"edit-validator","text":"<p>The command <code>edit-validator</code> allows users to edit an existing validator account.</p> <p>Usage:</p> <pre><code>simd tx staking edit-validator [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx staking edit-validator --moniker \"new_moniker_name\" --website \"new_webiste_url\" --from mykey\n</code></pre>"},{"location":"staking/#unbond","title":"unbond","text":"<p>The command <code>unbond</code> allows users to unbond shares from a validator.</p> <p>Usage:</p> <pre><code>simd tx staking unbond [validator-addr] [amount] [flags]\n</code></pre> <p>Example:</p> <pre><code>simd tx staking unbond cosmosvaloper1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj 100stake --from mykey\n</code></pre>"},{"location":"staking/#grpc","title":"gRPC","text":"<p>A user can query the <code>staking</code> module using gRPC endpoints.</p>"},{"location":"staking/#validators_2","title":"Validators","text":"<p>The <code>Validators</code> endpoint queries all validators that match the given status.</p> <pre><code>cosmos.staking.v1beta1.Query/Validators\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext localhost:9090 cosmos.staking.v1beta1.Query/Validators\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validators\": [\n    {\n      \"operatorAddress\": \"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\",\n      \"consensusPubkey\": {\"@type\":\"/cosmos.crypto.ed25519.PubKey\",\"key\":\"Auxs3865HpB/EfssYOzfqNhEJjzys2Fo6jD5B8tPgC8=\"},\n      \"status\": \"BOND_STATUS_BONDED\",\n      \"tokens\": \"10000000\",\n      \"delegatorShares\": \"10000000000000000000000000\",\n      \"description\": {\n        \"moniker\": \"myvalidator\"\n      },\n      \"unbondingTime\": \"1970-01-01T00:00:00Z\",\n      \"commission\": {\n        \"commissionRates\": {\n          \"rate\": \"100000000000000000\",\n          \"maxRate\": \"200000000000000000\",\n          \"maxChangeRate\": \"10000000000000000\"\n        },\n        \"updateTime\": \"2021-10-01T05:52:50.380144238Z\"\n      },\n      \"minSelfDelegation\": \"1\"\n    }\n  ],\n  \"pagination\": {\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#validator_2","title":"Validator","text":"<p>The <code>Validator</code> endpoint queries validator information for given validator address.</p> <pre><code>cosmos.staking.v1beta1.Query/Validator\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext -d '{\"validator_addr\":\"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/Validator\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validator\": {\n    \"operatorAddress\": \"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\",\n    \"consensusPubkey\": {\"@type\":\"/cosmos.crypto.ed25519.PubKey\",\"key\":\"Auxs3865HpB/EfssYOzfqNhEJjzys2Fo6jD5B8tPgC8=\"},\n    \"status\": \"BOND_STATUS_BONDED\",\n    \"tokens\": \"10000000\",\n    \"delegatorShares\": \"10000000000000000000000000\",\n    \"description\": {\n      \"moniker\": \"myvalidator\"\n    },\n    \"unbondingTime\": \"1970-01-01T00:00:00Z\",\n    \"commission\": {\n      \"commissionRates\": {\n        \"rate\": \"100000000000000000\",\n        \"maxRate\": \"200000000000000000\",\n        \"maxChangeRate\": \"10000000000000000\"\n      },\n      \"updateTime\": \"2021-10-01T05:52:50.380144238Z\"\n    },\n    \"minSelfDelegation\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#validatordelegations","title":"ValidatorDelegations","text":"<p>The <code>ValidatorDelegations</code> endpoint queries delegate information for given validator.</p> <pre><code>cosmos.staking.v1beta1.Query/ValidatorDelegations\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext -d '{\"validator_addr\":\"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/ValidatorDelegations\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"delegationResponses\": [\n    {\n      \"delegation\": {\n        \"delegatorAddress\": \"cosmos1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgy3ua5t\",\n        \"validatorAddress\": \"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\",\n        \"shares\": \"10000000000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"10000000\"\n      }\n    }\n  ],\n  \"pagination\": {\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#validatorunbondingdelegations","title":"ValidatorUnbondingDelegations","text":"<p>The <code>ValidatorUnbondingDelegations</code> endpoint queries delegate information for given validator.</p> <pre><code>cosmos.staking.v1beta1.Query/ValidatorUnbondingDelegations\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext -d '{\"validator_addr\":\"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/ValidatorUnbondingDelegations\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"unbonding_responses\": [\n    {\n      \"delegator_address\": \"cosmos1z3pzzw84d6xn00pw9dy3yapqypfde7vg6965fy\",\n      \"validator_address\": \"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\",\n      \"entries\": [\n        {\n          \"creation_height\": \"25325\",\n          \"completion_time\": \"2021-10-31T09:24:36.797320636Z\",\n          \"initial_balance\": \"20000000\",\n          \"balance\": \"20000000\"\n        }\n      ]\n    },\n    {\n      \"delegator_address\": \"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\",\n      \"validator_address\": \"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\",\n      \"entries\": [\n        {\n          \"creation_height\": \"13100\",\n          \"completion_time\": \"2021-10-30T12:53:02.272266791Z\",\n          \"initial_balance\": \"1000000\",\n          \"balance\": \"1000000\"\n        }\n      ]\n    },\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"8\"\n  }\n}\n</code></pre>"},{"location":"staking/#delegation_2","title":"Delegation","text":"<p>The <code>Delegation</code> endpoint queries delegate information for given validator delegator pair.</p> <pre><code>cosmos.staking.v1beta1.Query/Delegation\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n-d '{\"delegator_addr\": \"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\", validator_addr\":\"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/Delegation\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"delegation_response\":\n  {\n    \"delegation\":\n      {\n        \"delegator_address\":\"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\",\n        \"validator_address\":\"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\",\n        \"shares\":\"25083119936.000000000000000000\"\n      },\n    \"balance\":\n      {\n        \"denom\":\"stake\",\n        \"amount\":\"25083119936\"\n      }\n  }\n}\n</code></pre>"},{"location":"staking/#unbondingdelegation_1","title":"UnbondingDelegation","text":"<p>The <code>UnbondingDelegation</code> endpoint queries unbonding information for given validator delegator.</p> <pre><code>cosmos.staking.v1beta1.Query/UnbondingDelegation\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n-d '{\"delegator_addr\": \"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\", validator_addr\":\"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/UnbondingDelegation\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"unbond\": {\n    \"delegator_address\": \"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\",\n    \"validator_address\": \"cosmosvaloper1rne8lgs98p0jqe82sgt0qr4rdn4hgvmgp9ggcc\",\n    \"entries\": [\n      {\n        \"creation_height\": \"136984\",\n        \"completion_time\": \"2021-11-08T05:38:47.505593891Z\",\n        \"initial_balance\": \"400000000\",\n        \"balance\": \"400000000\"\n      },\n      {\n        \"creation_height\": \"137005\",\n        \"completion_time\": \"2021-11-08T05:40:53.526196312Z\",\n        \"initial_balance\": \"385000000\",\n        \"balance\": \"385000000\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"staking/#delegatordelegations","title":"DelegatorDelegations","text":"<p>The <code>DelegatorDelegations</code> endpoint queries all delegations of a given delegator address.</p> <pre><code>cosmos.staking.v1beta1.Query/DelegatorDelegations\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n-d '{\"delegator_addr\": \"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/DelegatorDelegations\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"delegation_responses\": [\n    {\"delegation\":{\"delegator_address\":\"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\",\"validator_address\":\"cosmosvaloper1eh5mwu044gd5ntkkc2xgfg8247mgc56fww3vc8\",\"shares\":\"25083339023.000000000000000000\"},\"balance\":{\"denom\":\"stake\",\"amount\":\"25083339023\"}}\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#delegatorunbondingdelegations","title":"DelegatorUnbondingDelegations","text":"<p>The <code>DelegatorUnbondingDelegations</code> endpoint queries all unbonding delegations of a given delegator address.</p> <pre><code>cosmos.staking.v1beta1.Query/DelegatorUnbondingDelegations\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n-d '{\"delegator_addr\": \"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/DelegatorUnbondingDelegations\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"unbonding_responses\": [\n    {\n      \"delegator_address\": \"cosmos1y8nyfvmqh50p6ldpzljk3yrglppdv3t8phju77\",\n      \"validator_address\": \"cosmosvaloper1sjllsnramtg3ewxqwwrwjxfgc4n4ef9uxyejze\",\n      \"entries\": [\n        {\n          \"creation_height\": \"136984\",\n          \"completion_time\": \"2021-11-08T05:38:47.505593891Z\",\n          \"initial_balance\": \"400000000\",\n          \"balance\": \"400000000\"\n        },\n        {\n          \"creation_height\": \"137005\",\n          \"completion_time\": \"2021-11-08T05:40:53.526196312Z\",\n          \"initial_balance\": \"385000000\",\n          \"balance\": \"385000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#delegatorvalidators","title":"DelegatorValidators","text":"<p>The <code>DelegatorValidators</code> endpoint queries all validators information for given delegator.</p> <pre><code>cosmos.staking.v1beta1.Query/DelegatorValidators\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n-d '{\"delegator_addr\": \"cosmos1ld5p7hn43yuh8ht28gm9pfjgj2fctujp2tgwvf\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/DelegatorValidators\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validators\": [\n    {\n      \"operator_address\": \"cosmosvaloper1eh5mwu044gd5ntkkc2xgfg8247mgc56fww3vc8\",\n      \"consensus_pubkey\": {\n        \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n        \"key\": \"UPwHWxH1zHJWGOa/m6JB3f5YjHMvPQPkVbDqqi+U7Uw=\"\n      },\n      \"jailed\": false,\n      \"status\": \"BOND_STATUS_BONDED\",\n      \"tokens\": \"347260647559\",\n      \"delegator_shares\": \"347260647559.000000000000000000\",\n      \"description\": {\n        \"moniker\": \"BouBouNode\",\n        \"identity\": \"\",\n        \"website\": \"https://boubounode.com\",\n        \"security_contact\": \"\",\n        \"details\": \"AI-based Validator. #1 AI Validator on Game of Stakes. Fairly priced. Don't trust (humans), verify. Made with BouBou love.\"\n      },\n      \"unbonding_height\": \"0\",\n      \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n      \"commission\": {\n        \"commission_rates\": {\n          \"rate\": \"0.061000000000000000\",\n          \"max_rate\": \"0.300000000000000000\",\n          \"max_change_rate\": \"0.150000000000000000\"\n        },\n        \"update_time\": \"2021-10-01T15:00:00Z\"\n      },\n      \"min_self_delegation\": \"1\"\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#delegatorvalidator","title":"DelegatorValidator","text":"<p>The <code>DelegatorValidator</code> endpoint queries validator information for given delegator validator</p> <pre><code>cosmos.staking.v1beta1.Query/DelegatorValidator\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext \\\n-d '{\"delegator_addr\": \"cosmos1eh5mwu044gd5ntkkc2xgfg8247mgc56f3n8rr7\", \"validator_addr\": \"cosmosvaloper1eh5mwu044gd5ntkkc2xgfg8247mgc56fww3vc8\"}' \\\nlocalhost:9090 cosmos.staking.v1beta1.Query/DelegatorValidator\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validator\": {\n    \"operator_address\": \"cosmosvaloper1eh5mwu044gd5ntkkc2xgfg8247mgc56fww3vc8\",\n    \"consensus_pubkey\": {\n      \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n      \"key\": \"UPwHWxH1zHJWGOa/m6JB3f5YjHMvPQPkVbDqqi+U7Uw=\"\n    },\n    \"jailed\": false,\n    \"status\": \"BOND_STATUS_BONDED\",\n    \"tokens\": \"347262754841\",\n    \"delegator_shares\": \"347262754841.000000000000000000\",\n    \"description\": {\n      \"moniker\": \"BouBouNode\",\n      \"identity\": \"\",\n      \"website\": \"https://boubounode.com\",\n      \"security_contact\": \"\",\n      \"details\": \"AI-based Validator. #1 AI Validator on Game of Stakes. Fairly priced. Don't trust (humans), verify. Made with BouBou love.\"\n    },\n    \"unbonding_height\": \"0\",\n    \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n    \"commission\": {\n      \"commission_rates\": {\n        \"rate\": \"0.061000000000000000\",\n        \"max_rate\": \"0.300000000000000000\",\n        \"max_change_rate\": \"0.150000000000000000\"\n      },\n      \"update_time\": \"2021-10-01T15:00:00Z\"\n    },\n    \"min_self_delegation\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#historicalinfo_1","title":"HistoricalInfo","text":"<pre><code>cosmos.staking.v1beta1.Query/HistoricalInfo\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext -d '{\"height\" : 1}' localhost:9090 cosmos.staking.v1beta1.Query/HistoricalInfo\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"hist\": {\n    \"header\": {\n      \"version\": {\n        \"block\": \"11\",\n        \"app\": \"0\"\n      },\n      \"chain_id\": \"simd-1\",\n      \"height\": \"140142\",\n      \"time\": \"2021-10-11T10:56:29.720079569Z\",\n      \"last_block_id\": {\n        \"hash\": \"9gri/4LLJUBFqioQ3NzZIP9/7YHR9QqaM6B2aJNQA7o=\",\n        \"part_set_header\": {\n          \"total\": 1,\n          \"hash\": \"Hk1+C864uQkl9+I6Zn7IurBZBKUevqlVtU7VqaZl1tc=\"\n        }\n      },\n      \"last_commit_hash\": \"VxrcS27GtvGruS3I9+AlpT7udxIT1F0OrRklrVFSSKc=\",\n      \"data_hash\": \"80BjOrqNYUOkTnmgWyz9AQ8n7SoEmPVi4QmAe8RbQBY=\",\n      \"validators_hash\": \"95W49n2hw8RWpr1GPTAO5MSPi6w6Wjr3JjjS7AjpBho=\",\n      \"next_validators_hash\": \"95W49n2hw8RWpr1GPTAO5MSPi6w6Wjr3JjjS7AjpBho=\",\n      \"consensus_hash\": \"BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=\",\n      \"app_hash\": \"ZZaxnSY3E6Ex5Bvkm+RigYCK82g8SSUL53NymPITeOE=\",\n      \"last_results_hash\": \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\",\n      \"evidence_hash\": \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\",\n      \"proposer_address\": \"aH6dO428B+ItuoqPq70efFHrSMY=\"\n    },\n  \"valset\": [\n      {\n        \"operator_address\": \"cosmosvaloper196ax4vc0lwpxndu9dyhvca7jhxp70rmcqcnylw\",\n        \"consensus_pubkey\": {\n          \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n          \"key\": \"/O7BtNW0pafwfvomgR4ZnfldwPXiFfJs9mHg3gwfv5Q=\"\n        },\n        \"jailed\": false,\n        \"status\": \"BOND_STATUS_BONDED\",\n        \"tokens\": \"1426045203613\",\n        \"delegator_shares\": \"1426045203613.000000000000000000\",\n        \"description\": {\n          \"moniker\": \"SG-1\",\n          \"identity\": \"48608633F99D1B60\",\n          \"website\": \"https://sg-1.online\",\n          \"security_contact\": \"\",\n          \"details\": \"SG-1 - your favorite validator on Witval. We offer 100% Soft Slash protection.\"\n        },\n        \"unbonding_height\": \"0\",\n        \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n        \"commission\": {\n          \"commission_rates\": {\n            \"rate\": \"0.037500000000000000\",\n            \"max_rate\": \"0.200000000000000000\",\n            \"max_change_rate\": \"0.030000000000000000\"\n          },\n          \"update_time\": \"2021-10-01T15:00:00Z\"\n        },\n        \"min_self_delegation\": \"1\"\n      }\n    ]\n  }\n}\n\n</code></pre>"},{"location":"staking/#pool_2","title":"Pool","text":"<p>The <code>Pool</code> endpoint queries the pool information.</p> <pre><code>cosmos.staking.v1beta1.Query/Pool\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext -d localhost:9090 cosmos.staking.v1beta1.Query/Pool\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"pool\": {\n    \"not_bonded_tokens\": \"369054400189\",\n    \"bonded_tokens\": \"15657192425623\"\n  }\n}\n</code></pre>"},{"location":"staking/#params_2","title":"Params","text":"<p>The <code>Params</code> endpoint queries the pool information.</p> <pre><code>cosmos.staking.v1beta1.Query/Params\n</code></pre> <p>Example:</p> <pre><code>grpcurl -plaintext localhost:9090 cosmos.staking.v1beta1.Query/Params\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"params\": {\n    \"unbondingTime\": \"1814400s\",\n    \"maxValidators\": 100,\n    \"maxEntries\": 7,\n    \"historicalEntries\": 10000,\n    \"bondDenom\": \"stake\"\n  }\n}\n</code></pre>"},{"location":"staking/#rest","title":"REST","text":"<p>A user can query the <code>staking</code> module using REST endpoints.</p>"},{"location":"staking/#delegatordelegations_1","title":"DelegatorDelegations","text":"<p>The <code>DelegtaorDelegations</code> REST endpoint queries all delegations of a given delegator address.</p> <pre><code>/cosmos/staking/v1beta1/delegations/{delegatorAddr}\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \"http://localhost:1317/cosmos/staking/v1beta1/delegations/cosmos1vcs68xf2tnqes5tg0khr0vyevm40ff6zdxatp5\" -H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"delegation_responses\": [\n    {\n      \"delegation\": {\n        \"delegator_address\": \"cosmos1vcs68xf2tnqes5tg0khr0vyevm40ff6zdxatp5\",\n        \"validator_address\": \"cosmosvaloper1quqxfrxkycr0uzt4yk0d57tcq3zk7srm7sm6r8\",\n        \"shares\": \"256250000.000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"256250000\"\n      }\n    },\n    {\n      \"delegation\": {\n        \"delegator_address\": \"cosmos1vcs68xf2tnqes5tg0khr0vyevm40ff6zdxatp5\",\n        \"validator_address\": \"cosmosvaloper194v8uwee2fvs2s8fa5k7j03ktwc87h5ym39jfv\",\n        \"shares\": \"255150000.000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"255150000\"\n      }\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"2\"\n  }\n}\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"redelegation_responses\": [\n    {\n      \"redelegation\": {\n        \"delegator_address\": \"cosmos1thfntksw0d35n2tkr0k8v54fr8wxtxwxl2c56e\",\n        \"validator_src_address\": \"cosmosvaloper1lzhlnpahvznwfv4jmay2tgaha5kmz5qx4cuznf\",\n        \"validator_dst_address\": \"cosmosvaloper1vq8tw77kp8lvxq9u3c8eeln9zymn68rng8pgt4\",\n        \"entries\": null\n      },\n      \"entries\": [\n        {\n          \"redelegation_entry\": {\n            \"creation_height\": 151523,\n            \"completion_time\": \"2021-11-09T06:03:25.640682116Z\",\n            \"initial_balance\": \"200000000\",\n            \"shares_dst\": \"200000000.000000000000000000\"\n          },\n          \"balance\": \"200000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": null\n}\n</code></pre>"},{"location":"staking/#delegatorunbondingdelegations_1","title":"DelegatorUnbondingDelegations","text":"<p>The <code>DelegatorUnbondingDelegations</code> REST endpoint queries all unbonding delegations of a given delegator address.</p> <pre><code>/cosmos/staking/v1beta1/delegators/{delegatorAddr}/unbonding_delegations\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \\\n\"http://localhost:1317/cosmos/staking/v1beta1/delegators/cosmos1nxv42u3lv642q0fuzu2qmrku27zgut3n3z7lll/unbonding_delegations\" \\\n-H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"unbonding_responses\": [\n    {\n      \"delegator_address\": \"cosmos1nxv42u3lv642q0fuzu2qmrku27zgut3n3z7lll\",\n      \"validator_address\": \"cosmosvaloper1e7mvqlz50ch6gw4yjfemsc069wfre4qwmw53kq\",\n      \"entries\": [\n        {\n          \"creation_height\": \"2442278\",\n          \"completion_time\": \"2021-10-12T10:59:03.797335857Z\",\n          \"initial_balance\": \"50000000000\",\n          \"balance\": \"50000000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#delegatorvalidators_1","title":"DelegatorValidators","text":"<p>The <code>DelegatorValidators</code> REST endpoint queries all validators information for given delegator address.</p> <pre><code>/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \\\n\"http://localhost:1317/cosmos/staking/v1beta1/delegators/cosmos1xwazl8ftks4gn00y5x3c47auquc62ssune9ppv/validators\" \\\n-H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validators\": [\n    {\n      \"operator_address\": \"cosmosvaloper1xwazl8ftks4gn00y5x3c47auquc62ssuvynw64\",\n      \"consensus_pubkey\": {\n        \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n        \"key\": \"5v4n3px3PkfNnKflSgepDnsMQR1hiNXnqOC11Y72/PQ=\"\n      },\n      \"jailed\": false,\n      \"status\": \"BOND_STATUS_BONDED\",\n      \"tokens\": \"21592843799\",\n      \"delegator_shares\": \"21592843799.000000000000000000\",\n      \"description\": {\n        \"moniker\": \"jabbey\",\n        \"identity\": \"\",\n        \"website\": \"https://twitter.com/JoeAbbey\",\n        \"security_contact\": \"\",\n        \"details\": \"just another dad in the cosmos\"\n      },\n      \"unbonding_height\": \"0\",\n      \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n      \"commission\": {\n        \"commission_rates\": {\n          \"rate\": \"0.100000000000000000\",\n          \"max_rate\": \"0.200000000000000000\",\n          \"max_change_rate\": \"0.100000000000000000\"\n        },\n        \"update_time\": \"2021-10-09T19:03:54.984821705Z\"\n      },\n      \"min_self_delegation\": \"1\"\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#delegatorvalidator_1","title":"DelegatorValidator","text":"<p>The <code>DelegatorValidator</code> REST endpoint queries validator information for given delegator validator pair.</p> <pre><code>/cosmos/staking/v1beta1/delegators/{delegatorAddr}/validators/{validatorAddr}\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \\\n\"http://localhost:1317/cosmos/staking/v1beta1/delegators/cosmos1xwazl8ftks4gn00y5x3c47auquc62ssune9ppv/validators/cosmosvaloper1xwazl8ftks4gn00y5x3c47auquc62ssuvynw64\" \\\n-H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validator\": {\n    \"operator_address\": \"cosmosvaloper1xwazl8ftks4gn00y5x3c47auquc62ssuvynw64\",\n    \"consensus_pubkey\": {\n      \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n      \"key\": \"5v4n3px3PkfNnKflSgepDnsMQR1hiNXnqOC11Y72/PQ=\"\n    },\n    \"jailed\": false,\n    \"status\": \"BOND_STATUS_BONDED\",\n    \"tokens\": \"21592843799\",\n    \"delegator_shares\": \"21592843799.000000000000000000\",\n    \"description\": {\n      \"moniker\": \"jabbey\",\n      \"identity\": \"\",\n      \"website\": \"https://twitter.com/JoeAbbey\",\n      \"security_contact\": \"\",\n      \"details\": \"just another dad in the cosmos\"\n    },\n    \"unbonding_height\": \"0\",\n    \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n    \"commission\": {\n      \"commission_rates\": {\n        \"rate\": \"0.100000000000000000\",\n        \"max_rate\": \"0.200000000000000000\",\n        \"max_change_rate\": \"0.100000000000000000\"\n      },\n      \"update_time\": \"2021-10-09T19:03:54.984821705Z\"\n    },\n    \"min_self_delegation\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#historicalinfo_2","title":"HistoricalInfo","text":"<p>The <code>HistoricalInfo</code> REST endpoint queries the historical information for given height.</p> <pre><code>/cosmos/staking/v1beta1/historical_info/{height}\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \"http://localhost:1317/cosmos/staking/v1beta1/historical_info/153332\" -H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"hist\": {\n    \"header\": {\n      \"version\": {\n        \"block\": \"11\",\n        \"app\": \"0\"\n      },\n      \"chain_id\": \"cosmos-1\",\n      \"height\": \"153332\",\n      \"time\": \"2021-10-12T09:05:35.062230221Z\",\n      \"last_block_id\": {\n        \"hash\": \"NX8HevR5khb7H6NGKva+jVz7cyf0skF1CrcY9A0s+d8=\",\n        \"part_set_header\": {\n          \"total\": 1,\n          \"hash\": \"zLQ2FiKM5tooL3BInt+VVfgzjlBXfq0Hc8Iux/xrhdg=\"\n        }\n      },\n      \"last_commit_hash\": \"P6IJrK8vSqU3dGEyRHnAFocoDGja0bn9euLuy09s350=\",\n      \"data_hash\": \"eUd+6acHWrNXYju8Js449RJ99lOYOs16KpqQl4SMrEM=\",\n      \"validators_hash\": \"mB4pravvMsJKgi+g8aYdSeNlt0kPjnRFyvtAQtaxcfw=\",\n      \"next_validators_hash\": \"mB4pravvMsJKgi+g8aYdSeNlt0kPjnRFyvtAQtaxcfw=\",\n      \"consensus_hash\": \"BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=\",\n      \"app_hash\": \"fuELArKRK+CptnZ8tu54h6xEleSWenHNmqC84W866fU=\",\n      \"last_results_hash\": \"p/BPexV4LxAzlVcPRvW+lomgXb6Yze8YLIQUo/4Kdgc=\",\n      \"evidence_hash\": \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\",\n      \"proposer_address\": \"G0MeY8xQx7ooOsni8KE/3R/Ib3Q=\"\n    },\n    \"valset\": [\n      {\n        \"operator_address\": \"cosmosvaloper196ax4vc0lwpxndu9dyhvca7jhxp70rmcqcnylw\",\n        \"consensus_pubkey\": {\n          \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n          \"key\": \"/O7BtNW0pafwfvomgR4ZnfldwPXiFfJs9mHg3gwfv5Q=\"\n        },\n        \"jailed\": false,\n        \"status\": \"BOND_STATUS_BONDED\",\n        \"tokens\": \"1416521659632\",\n        \"delegator_shares\": \"1416521659632.000000000000000000\",\n        \"description\": {\n          \"moniker\": \"SG-1\",\n          \"identity\": \"48608633F99D1B60\",\n          \"website\": \"https://sg-1.online\",\n          \"security_contact\": \"\",\n          \"details\": \"SG-1 - your favorite validator on cosmos. We offer 100% Soft Slash protection.\"\n        },\n        \"unbonding_height\": \"0\",\n        \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n        \"commission\": {\n          \"commission_rates\": {\n            \"rate\": \"0.037500000000000000\",\n            \"max_rate\": \"0.200000000000000000\",\n            \"max_change_rate\": \"0.030000000000000000\"\n          },\n          \"update_time\": \"2021-10-01T15:00:00Z\"\n        },\n        \"min_self_delegation\": \"1\"\n      },\n      {\n        \"operator_address\": \"cosmosvaloper1t8ehvswxjfn3ejzkjtntcyrqwvmvuknzmvtaaa\",\n        \"consensus_pubkey\": {\n          \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n          \"key\": \"uExZyjNLtr2+FFIhNDAMcQ8+yTrqE7ygYTsI7khkA5Y=\"\n        },\n        \"jailed\": false,\n        \"status\": \"BOND_STATUS_BONDED\",\n        \"tokens\": \"1348298958808\",\n        \"delegator_shares\": \"1348298958808.000000000000000000\",\n        \"description\": {\n          \"moniker\": \"Cosmostation\",\n          \"identity\": \"AE4C403A6E7AA1AC\",\n          \"website\": \"https://www.cosmostation.io\",\n          \"security_contact\": \"admin@stamper.network\",\n          \"details\": \"Cosmostation validator node. Delegate your tokens and Start Earning Staking Rewards\"\n        },\n        \"unbonding_height\": \"0\",\n        \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n        \"commission\": {\n          \"commission_rates\": {\n            \"rate\": \"0.050000000000000000\",\n            \"max_rate\": \"1.000000000000000000\",\n            \"max_change_rate\": \"0.200000000000000000\"\n          },\n          \"update_time\": \"2021-10-01T15:06:38.821314287Z\"\n        },\n        \"min_self_delegation\": \"1\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"staking/#parameters_1","title":"Parameters","text":"<p>The <code>Parameters</code> REST endpoint queries the staking parameters.</p> <pre><code>/cosmos/staking/v1beta1/params\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \"http://localhost:1317/cosmos/staking/v1beta1/params\" -H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"params\": {\n    \"unbonding_time\": \"2419200s\",\n    \"max_validators\": 100,\n    \"max_entries\": 7,\n    \"historical_entries\": 10000,\n    \"bond_denom\": \"stake\"\n  }\n}\n</code></pre>"},{"location":"staking/#pool_3","title":"Pool","text":"<p>The <code>Pool</code> REST endpoint queries the pool information.</p> <pre><code>/cosmos/staking/v1beta1/pool\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \"http://localhost:1317/cosmos/staking/v1beta1/pool\" -H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"pool\": {\n    \"not_bonded_tokens\": \"432805737458\",\n    \"bonded_tokens\": \"15783637712645\"\n  }\n}\n</code></pre>"},{"location":"staking/#validators_3","title":"Validators","text":"<p>The <code>Validators</code> REST endpoint queries all validators that match the given status.</p> <pre><code>/cosmos/staking/v1beta1/validators\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \"http://localhost:1317/cosmos/staking/v1beta1/validators\" -H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validators\": [\n    {\n      \"operator_address\": \"cosmosvaloper1q3jsx9dpfhtyqqgetwpe5tmk8f0ms5qywje8tw\",\n      \"consensus_pubkey\": {\n        \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n        \"key\": \"N7BPyek2aKuNZ0N/8YsrqSDhGZmgVaYUBuddY8pwKaE=\"\n      },\n      \"jailed\": false,\n      \"status\": \"BOND_STATUS_BONDED\",\n      \"tokens\": \"383301887799\",\n      \"delegator_shares\": \"383301887799.000000000000000000\",\n      \"description\": {\n        \"moniker\": \"SmartNodes\",\n        \"identity\": \"D372724899D1EDC8\",\n        \"website\": \"https://smartnodes.co\",\n        \"security_contact\": \"\",\n        \"details\": \"Earn Rewards with Crypto Staking &amp; Node Deployment\"\n      },\n      \"unbonding_height\": \"0\",\n      \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n      \"commission\": {\n        \"commission_rates\": {\n          \"rate\": \"0.050000000000000000\",\n          \"max_rate\": \"0.200000000000000000\",\n          \"max_change_rate\": \"0.100000000000000000\"\n        },\n        \"update_time\": \"2021-10-01T15:51:31.596618510Z\"\n      },\n      \"min_self_delegation\": \"1\"\n    },\n    {\n      \"operator_address\": \"cosmosvaloper1q5ku90atkhktze83j9xjaks2p7uruag5zp6wt7\",\n      \"consensus_pubkey\": {\n        \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n        \"key\": \"GDNpuKDmCg9GnhnsiU4fCWktuGUemjNfvpCZiqoRIYA=\"\n      },\n      \"jailed\": false,\n      \"status\": \"BOND_STATUS_UNBONDING\",\n      \"tokens\": \"1017819654\",\n      \"delegator_shares\": \"1017819654.000000000000000000\",\n      \"description\": {\n        \"moniker\": \"Noderunners\",\n        \"identity\": \"812E82D12FEA3493\",\n        \"website\": \"http://noderunners.biz\",\n        \"security_contact\": \"info@noderunners.biz\",\n        \"details\": \"Noderunners is a professional validator in POS networks. We have a huge node running experience, reliable soft and hardware. Our commissions are always low, our support to delegators is always full. Stake with us and start receiving your cosmos rewards now!\"\n      },\n      \"unbonding_height\": \"147302\",\n      \"unbonding_time\": \"2021-11-08T22:58:53.718662452Z\",\n      \"commission\": {\n        \"commission_rates\": {\n          \"rate\": \"0.050000000000000000\",\n          \"max_rate\": \"0.200000000000000000\",\n          \"max_change_rate\": \"0.100000000000000000\"\n        },\n        \"update_time\": \"2021-10-04T18:02:21.446645619Z\"\n      },\n      \"min_self_delegation\": \"1\"\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": \"FONDBFkE4tEEf7yxWWKOD49jC2NK\",\n    \"total\": \"2\"\n  }\n}\n</code></pre>"},{"location":"staking/#validator_3","title":"Validator","text":"<p>The <code>Validator</code> REST endpoint queries validator information for given validator address.</p> <pre><code>/cosmos/staking/v1beta1/validators/{validatorAddr}\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \\\n\"http://localhost:1317/cosmos/staking/v1beta1/validators/cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\" \\\n-H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"validator\": {\n    \"operator_address\": \"cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\",\n    \"consensus_pubkey\": {\n      \"@type\": \"/cosmos.crypto.ed25519.PubKey\",\n      \"key\": \"sIiexdJdYWn27+7iUHQJDnkp63gq/rzUq1Y+fxoGjXc=\"\n    },\n    \"jailed\": false,\n    \"status\": \"BOND_STATUS_BONDED\",\n    \"tokens\": \"33027900000\",\n    \"delegator_shares\": \"33027900000.000000000000000000\",\n    \"description\": {\n      \"moniker\": \"Witval\",\n      \"identity\": \"51468B615127273A\",\n      \"website\": \"\",\n      \"security_contact\": \"\",\n      \"details\": \"Witval is the validator arm from Vitwit. Vitwit is into software consulting and services business since 2015. We are working closely with Cosmos ecosystem since 2018. We are also building tools for the ecosystem, Aneka is our explorer for the cosmos ecosystem.\"\n    },\n    \"unbonding_height\": \"0\",\n    \"unbonding_time\": \"1970-01-01T00:00:00Z\",\n    \"commission\": {\n      \"commission_rates\": {\n        \"rate\": \"0.050000000000000000\",\n        \"max_rate\": \"0.200000000000000000\",\n        \"max_change_rate\": \"0.020000000000000000\"\n      },\n      \"update_time\": \"2021-10-01T19:24:52.663191049Z\"\n    },\n    \"min_self_delegation\": \"1\"\n  }\n}\n</code></pre>"},{"location":"staking/#validatordelegations_1","title":"ValidatorDelegations","text":"<p>The <code>ValidatorDelegations</code> REST endpoint queries delegate information for given validator.</p> <pre><code>/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \"http://localhost:1317/cosmos/staking/v1beta1/validators/cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q/delegations\" -H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"delegation_responses\": [\n    {\n      \"delegation\": {\n        \"delegator_address\": \"cosmos190g5j8aszqhvtg7cprmev8xcxs6csra7xnk3n3\",\n        \"validator_address\": \"cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\",\n        \"shares\": \"31000000000.000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"31000000000\"\n      }\n    },\n    {\n      \"delegation\": {\n        \"delegator_address\": \"cosmos1ddle9tczl87gsvmeva3c48nenyng4n56qwq4ee\",\n        \"validator_address\": \"cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\",\n        \"shares\": \"628470000.000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"628470000\"\n      }\n    },\n    {\n      \"delegation\": {\n        \"delegator_address\": \"cosmos10fdvkczl76m040smd33lh9xn9j0cf26kk4s2nw\",\n        \"validator_address\": \"cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\",\n        \"shares\": \"838120000.000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"838120000\"\n      }\n    },\n    {\n      \"delegation\": {\n        \"delegator_address\": \"cosmos1n8f5fknsv2yt7a8u6nrx30zqy7lu9jfm0t5lq8\",\n        \"validator_address\": \"cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\",\n        \"shares\": \"500000000.000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"500000000\"\n      }\n    },\n    {\n      \"delegation\": {\n        \"delegator_address\": \"cosmos16msryt3fqlxtvsy8u5ay7wv2p8mglfg9hrek2e\",\n        \"validator_address\": \"cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\",\n        \"shares\": \"61310000.000000000000000000\"\n      },\n      \"balance\": {\n        \"denom\": \"stake\",\n        \"amount\": \"61310000\"\n      }\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"5\"\n  }\n}\n</code></pre>"},{"location":"staking/#delegation_3","title":"Delegation","text":"<p>The <code>Delegation</code> REST endpoint queries delegate information for given validator delegator pair.</p> <pre><code>/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \\\n\"http://localhost:1317/cosmos/staking/v1beta1/validators/cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q/delegations/cosmos1n8f5fknsv2yt7a8u6nrx30zqy7lu9jfm0t5lq8\" \\\n-H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"delegation_response\": {\n    \"delegation\": {\n      \"delegator_address\": \"cosmos1n8f5fknsv2yt7a8u6nrx30zqy7lu9jfm0t5lq8\",\n      \"validator_address\": \"cosmosvaloper16msryt3fqlxtvsy8u5ay7wv2p8mglfg9g70e3q\",\n      \"shares\": \"500000000.000000000000000000\"\n    },\n    \"balance\": {\n      \"denom\": \"stake\",\n      \"amount\": \"500000000\"\n    }\n  }\n}\n</code></pre>"},{"location":"staking/#unbondingdelegation_2","title":"UnbondingDelegation","text":"<p>The <code>UnbondingDelegation</code> REST endpoint queries unbonding information for given validator delegator pair.</p> <pre><code>/cosmos/staking/v1beta1/validators/{validatorAddr}/delegations/{delegatorAddr}/unbonding_delegation\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \\\n\"http://localhost:1317/cosmos/staking/v1beta1/validators/cosmosvaloper13v4spsah85ps4vtrw07vzea37gq5la5gktlkeu/delegations/cosmos1ze2ye5u5k3qdlexvt2e0nn0508p04094ya0qpm/unbonding_delegation\" \\\n-H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"unbond\": {\n    \"delegator_address\": \"cosmos1ze2ye5u5k3qdlexvt2e0nn0508p04094ya0qpm\",\n    \"validator_address\": \"cosmosvaloper13v4spsah85ps4vtrw07vzea37gq5la5gktlkeu\",\n    \"entries\": [\n      {\n        \"creation_height\": \"153687\",\n        \"completion_time\": \"2021-11-09T09:41:18.352401903Z\",\n        \"initial_balance\": \"525111\",\n        \"balance\": \"525111\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"staking/#validatorunbondingdelegations_1","title":"ValidatorUnbondingDelegations","text":"<p>The <code>ValidatorUnbondingDelegations</code> REST endpoint queries unbonding delegations of a validator.</p> <pre><code>/cosmos/staking/v1beta1/validators/{validatorAddr}/unbonding_delegations\n</code></pre> <p>Example:</p> <pre><code>curl -X GET \\\n\"http://localhost:1317/cosmos/staking/v1beta1/validators/cosmosvaloper13v4spsah85ps4vtrw07vzea37gq5la5gktlkeu/unbonding_delegations\" \\\n-H  \"accept: application/json\"\n</code></pre> <p>Example Output:</p> <pre><code>{\n  \"unbonding_responses\": [\n    {\n      \"delegator_address\": \"cosmos1q9snn84jfrd9ge8t46kdcggpe58dua82vnj7uy\",\n      \"validator_address\": \"cosmosvaloper13v4spsah85ps4vtrw07vzea37gq5la5gktlkeu\",\n      \"entries\": [\n        {\n          \"creation_height\": \"90998\",\n          \"completion_time\": \"2021-11-05T00:14:37.005841058Z\",\n          \"initial_balance\": \"24000000\",\n          \"balance\": \"24000000\"\n        }\n      ]\n    },\n    {\n      \"delegator_address\": \"cosmos1qf36e6wmq9h4twhdvs6pyq9qcaeu7ye0s3dqq2\",\n      \"validator_address\": \"cosmosvaloper13v4spsah85ps4vtrw07vzea37gq5la5gktlkeu\",\n      \"entries\": [\n        {\n          \"creation_height\": \"47478\",\n          \"completion_time\": \"2021-11-01T22:47:26.714116854Z\",\n          \"initial_balance\": \"8000000\",\n          \"balance\": \"8000000\"\n        }\n      ]\n    }\n  ],\n  \"pagination\": {\n    \"next_key\": null,\n    \"total\": \"2\"\n  }\n}\n</code></pre>"},{"location":"validator/","title":"Overview","text":""},{"location":"validator/#setup-and-configuration","title":"Setup and configuration","text":""},{"location":"validator/#run-validator","title":"Run validator","text":""},{"location":"validator/#configuration","title":"configuration","text":""},{"location":"validator/#hdd-usage-optimization","title":"HDD usage optimization","text":""},{"location":"validator/#state-synchronization","title":"State Synchronization","text":""},{"location":"validator/#memory-pool","title":"memory pool","text":""},{"location":"validator/#validator-faq","title":"Validator FAQ","text":""},{"location":"validator/#authenticator-security","title":"Authenticator Security","text":""},{"location":"validator/#sentinel-node-ddos-protected","title":"Sentinel Node (DDOS Protected)","text":""},{"location":"validator/#key-backup","title":"Key backup","text":""},{"location":"validator/#upgrade","title":"upgrade","text":""},{"location":"validator/#upgrade-checklist","title":"Upgrade Checklist","text":""},{"location":"validator/#hard-fork-upgrade","title":"Hard Fork Upgrade","text":""},{"location":"validator/#manual-upgrade","title":"Manual upgrade","text":""},{"location":"validator/#testnet","title":"Testnet","text":""},{"location":"validator/#mainnet","title":"Mainnet","text":""},{"location":"chat/chat_doc/","title":"Service Documentation","text":""},{"location":"chat/chat_doc/#overview","title":"Overview","text":"<p>The chat service is a chat service developed based on the chat protocol, which supports encrypted communication based on rooms and events. At the same time, it supports federated cross-service node communication and point-to-point audio and video calls based on webrtc.</p> <p>Communication across service nodes</p> <pre><code>    { Chat client A }                             { Chat client B }\n        ^          |                                    ^          |\n        |  events  |  Client-Server API                 |  events  |\n        |          V                                    |          V\n    +------------------+                            +------------------+\n    |                  |---------( HTTP )---------&gt; |                  |\n    |   homeserver     |                            |   homeserver     |\n    |                  |&lt;--------( HTTP )---------- |                  |\n    +------------------+      Server-Server API     +------------------+\n                          History Synchronisation\n                              (Federation)\n</code></pre>"},{"location":"chat/chat_doc/#basic-concepts","title":"Basic Concepts","text":""},{"location":"chat/chat_doc/#servername-virtual-domain-name","title":"Servername (virtual domain name)","text":"<p>servername is the virtual domain name (domain) of the chat service, and together with the user's wallet address constitutes the user ID</p>"},{"location":"chat/chat_doc/#users","title":"Users","text":"<p>Each client is associated with an account, which is used as the unique identification of the chat system, that is, userID. This account is associated with the homeserver to form a space-separated account, which looks like:</p> <pre><code>@localpart:domain\n</code></pre>"},{"location":"chat/chat_doc/#devices","title":"Devices","text":"<p>The concept of a device is defined in the chat system, which can be a desktop client, some browsers, an Android device or an iPhone, etc. (currently only Android devices are open). A chat system device is associated with a real physical device or mobile application.</p> <p>The device is mainly used to manage the key used for end-to-end encryption (each device can get its own copy of the decryption key), and at the same time provide assistance when other devices with the same account are connected.</p> <p>When a user uses the client for the first time, the client registers itself as a new device. Different devices are identified by device ID (device_id), which is unique to each user. Users can define a human-readable device name for the device, which is used for them to manage the device.</p>"},{"location":"chat/chat_doc/#events","title":"Events","text":"<p>All data exchange in the chat is based on event events. Client behavior is defined through events, and each event has a type attribute to distinguish data types. Each event type must be globally unique, Follow the naming rules of the Java namespace, for example, m.room.message represents the message event in the room.</p>"},{"location":"chat/chat_doc/#event-graphs","title":"Event Graphs","text":"<p>All event data exchanges in the room are stored in a directed acyclic graph called Event Graphs. Each event in the graph is arranged in chronological order.</p> <p>Typically, an event has only one parent: the latest message in the room at the time the message was sent. However, homeservers may legitimately race with each other in sending messages, resulting in multiple successors to a single event. Therefore, the next event added to the graph will have multiple parents. Every event graph has a root event with no parent event.</p> <p>To sort and simplify chronological comparisons between events in the graph, the home server maintains a deep metadata field on each event. An event's depth is a positive integer strictly greater than the depth of any of its parent events. Root events should have a depth of 1. Therefore, if one event precedes another, its depth must be strictly less than 1.</p>"},{"location":"chat/chat_doc/#room-structure","title":"Room structure","text":"<p>A room is a conceptual place where users can send and receive events. Events are sent to a room where all participants with sufficient access will receive the event. Rooms are uniquely identified internally by a \"room ID\", which has the following form:</p> <pre><code>!room_id:domain # room_id: a 16-bit random string\n</code></pre> <p>Each room has only one room ID. While room IDs do contain domains, it is only used for global namespace room IDs. The room is not in the specified domain.</p> <p>The conceptual diagram below shows an m.room.message event being sent to room !qporfwt:daodst.com:</p> <pre><code>\n    { @alice:daodst.com }                             { @bob:example.org }\n            |                                                 ^\n            |                                                 |\n    [HTTP POST]                                  [HTTP GET]\n    Room ID: !qporfwt:daodst.com                 Room ID: !qporfwt:daodst.com\n    Event type: m.room.message                   Event type: m.room.message\n    Content: { JSON object }                     Content: { JSON object }\n            |                                                 |\n            V                                                 |\n    +------------------+                          +------------------+\n    |   homeserver     |                          |   homeserver     |\n    |   daodst.com     |                          |   example.org    |\n    +------------------+                          +------------------+\n            |                                                 ^\n            |         [HTTP PUT]                              |\n            |         Room ID: !qporfwt:daodst.com            |\n            |         Event type: m.room.message              |\n            |         Content: { JSON object }                |\n            `-------&gt; Pointer to the preceding message  ------`\n                      PKI signature from daodst.com\n                      Transaction-layer metadata\n                      PKI Authorization header\n\n                  ....................................\n                 |           Shared Data              |\n                 | State:                             |\n                 |   Room ID: !qporfwt:daodst.com     |\n                 |   Servers: daodst.com, example.org |\n                 |   Members:                         |\n                 |    - @alice:daodst.com             |\n                 |    - @bob:example.org              |\n                 | Messages:                          |\n                 |   - @alice:daodst.com              |\n                 |     Content: { JSON object }       |\n                 |....................................|\n\n</code></pre> <p>The federation mechanism maintains a shared data structure for each room among multiple homeservers. The data is divided into message events and status events.</p> <p>Messaging Events: These describe transient \"one-off\" activity within the room, such as instant messages, VoIP call setup, file transfers, etc. They generally describe communication activities.</p> <p>State Events: These describe updates to a given persistent information (\"state\") associated with a room, such as the room's name, subject, membership, participating servers, etc. The state is modeled as a lookup table of key/value pairs per room, where each key is a tuple of state_key and the event type. Each state event updates the value for the given key.</p> <p>The room state at a given point is computed by considering all events in the graph preceding and including the given event. In cases where events describe the same state, the merge conflict algorithm is applied. The state resolution algorithm is transitive and does not depend on server state, since it must always select the same event, regardless of the server or the order in which the events were received. Events are signed by the origin server (signature includes parent, type, depth and payload hash) and pushed to participating servers in the room via federation, currently using a full mesh topology. Servers can also request backfill events from other servers participating in the room through federation.</p>"},{"location":"chat/chat_doc/#room-aliases","title":"Room Aliases","text":"<p>Each room can also have multiple \"room aliases\", as follows:</p> <pre><code>   #room_alias:domain\n</code></pre> <p>The room alias \"points to\" the room ID, which is the human-readable label used to advertise and discover the room. The room ID pointed to by the alias can be obtained by accessing the specified domain. Note that the mapping from room aliases to room IDs is not fixed and may change over time to point to different room IDs. Therefore, clients should resolve the room alias to a room ID once, and then use that ID in subsequent requests.</p> <p>When resolving a room alias, the server will also respond with a list of servers in the room that are available to join.</p> <pre><code>    HTTP GET\n    #matrix:example.org      !aaabaa:daodst.com\n       |                    ^\n       |                    |\n    _______V____________________|____\n    |          example.org           |\n    | Mappings:                      |\n    | #matrix &gt;&gt; !aaabaa:daodst.com  |\n    | #golf   &gt;&gt; !wfeiofh:sport.com  |\n    | #bike   &gt;&gt; !4rguxf:daodst.com  |\n    |________________________________|\n</code></pre>"},{"location":"chat/chat_doc/#identity","title":"Identity","text":"<p>Users in Matrix are identified by their Matrix User ID. However, it is also possible to use existing 3rd party ID namespaces to identify Matrix users. The matrix \"identity\" describes the user ID and any other existing IDs in the third-party namespace linked to their account. Matrix users can link third-party IDs (3PIDs) such as email addresses, social networking accounts, and phone numbers to their user IDs. Linking 3PIDs creates a mapping from 3PIDs to user IDs. Matrix users can then use this map to discover the user IDs of their contacts. To ensure that the mapping from 3PIDs to user IDs is authentic, a globally federated cluster of trusted \"Identity Servers\" (ISs) is used to verify the 3PIDs and to save and replicate the mappings.</p> <p>In order for a client application to be part of the Matrix ecosystem, the use of IS is not required. However, without a client there will be no way to use 3PID to look up the user ID.</p>"},{"location":"chat/chat_doc/#private-user-data","title":"Private User Data","text":"<p>Users can also store arbitrary private key/value data in their accounts -- such as client preferences or server configuration settings lacking any other dedicated APIs. The API is symmetric with the management profile data.</p>"},{"location":"chat/customise_doc/","title":"Service customization","text":""},{"location":"chat/customise_doc/#overview","title":"Overview","text":"<p>Based on the matrix protocol, we have done some customization work to adapt to the cosmos ecology. Including customized cosmos signature verification login, and a series of chat restrictions increase.</p>"},{"location":"chat/customise_doc/#cosmos-signature-verification-login","title":"Cosmos signature verification login","text":"<p>Add com.xs.cosmos_sign_auth login type on the basis of the original login API, and realize automatic registration if the user is not registered when logging in. The process is as follows:</p> <pre><code>     1. Verify signature\n     2. Determine whether the signature is consistent with the public key export address\n     3. Determine whether the user exists\n     4. If 3, it is judged that it does not exist, automatically register the user to the chat system\n</code></pre>"},{"location":"chat/customise_doc/#space-limits","title":"Space Limits","text":"<pre><code>Usage Quota Calculation Method\n\nMedal level, each level increases the bonus by 3%, and level 33 can get a maximum bonus of 100%\n\nUser base = remaining disk used by the node / number of users who have uploaded today on the node / data cleaning cycle / 2\n\nUser bonus amount = user base amount x medal level increase\n\nRoll over the oldest file when the quota is insufficient\n\n\n++++++++++ Example: ++++++++++++++\n\nThe remaining disk available for the node is 100G, the data cleaning cycle is 3 days, and the number of daily active users on the node today is 500\n\n100G / 500 / 3 /2 = 35M (base storage capacity of node users)\n\nUser A's medal level is level 10, and the bonus ratio is 9%\n\n35M x (1 + 0.09) = 38.15M (the actual storage capacity after medal bonus)\n</code></pre>"},{"location":"chat/customise_doc/#bandwidth-limit","title":"Bandwidth limit","text":""},{"location":"chat/customise_doc/#public-room-limit","title":"Public room limit","text":"<p>Users are not allowed to create public rooms before level 5, and after level 5, each level increases the permission to create a public room</p>"},{"location":"chat/customise_doc/#tourist-mode","title":"Tourist Mode","text":"<p>Tourist mode is different from official users. Tourist representatives only register in the chat service, but users who have not registered on the chain for pledge, tourists are not allowed to send messages when they have not pledged enough.</p>"},{"location":"chat/faq/","title":"common problem","text":""},{"location":"chat/installation/","title":"Install start","text":""},{"location":"chat/installation/#install","title":"Install","text":""},{"location":"chat/installation/#windows-installation","title":"Windows Installation","text":"<p>It can be installed with the PC program</p>"},{"location":"chat/installation/#linux-installation","title":"Linux installation","text":"<p>Unzip chat_linux.tar.gz to the current folder, a chat/ directory will be generated, including the startup program (completed by the script)</p>"},{"location":"chat/installation/#configuration","title":"Configuration","text":""},{"location":"chat/installation/#configuration-file","title":"configuration file","text":"<ul> <li>chat_key.pem: server key file</li> <li>chat.yaml: service startup configuration file</li> </ul>"},{"location":"chat/installation/#configuration-file-initialization","title":"Configuration file initialization","text":"<p>Generated automatically when the gateway program starts</p>"},{"location":"chat/installation/#start-up","title":"start up","text":""},{"location":"chat/installation/#start-preconditions","title":"Start preconditions","text":"<ul> <li>registered gateway</li> <li>A number segment has been set for this gateway</li> </ul>"},{"location":"chat/installation/#start-command","title":"start command","text":""},{"location":"chat/installation/#notice","title":"Notice","text":"<p>The following commands are all executed by the gateway program without manual calls</p>"},{"location":"chat/installation/#windows","title":"windows","text":"<pre><code>chat.exe -public-ip XXX.XXX.XXX.XXX\n</code></pre>"},{"location":"chat/installation/#linux","title":"Linux","text":"<pre><code>chat -public-ip XXX.XXX.XXX.XXX\n</code></pre>"},{"location":"chat/optional_cfg/","title":"Optional","text":""},{"location":"chat/optional_cfg/#bandwidth-sharing-node-pool-configuration","title":"Bandwidth sharing node pool configuration","text":"<p>The bandwidth sharing requirement is designed to allow node owners to form an alliance, communicate the turn transfer service internally, and modify the configuration file so that users can use the turn service across nodes. To achieve the purpose of sharing bandwidth during audio and video communication.</p>"},{"location":"chat/optional_cfg/#configuration-changes","title":"Configuration changes","text":"<p>When generating the configuration file, the current node information is added to the trusted_servers configuration item by default. as follows:</p> <pre><code>\n  turn:\n    turn_user_lifetime: \"1m\"\n    turn_uris: [\"turn:192.168.10.242:3478?transport=udp\"]\n    turn_shared_secret: \"\"\n    turn_username: \"test\"\n    turn_password: \"pwd_test\"\n    trusted_servers:\n      - servername: self   # Any name\n        host: 192.168.3.32  # Server public IP\n        bandwidth: 100  # Server network bandwidth (unit: M)\n        turn_uris: [\"turn:192.168.3.32:3478?transport=udp\"]\n        salt_str: salt_str_here # Salt string used for interface parameter signature\n\n</code></pre>"},{"location":"chat/optional_cfg/#share-configuration","title":"Share configuration","text":"<p>When the node owner reaches a shared bandwidth consensus in private, he only needs to configure the first trusted_server under the trusted_servers configuration item of his node, that is, the The configuration is sent to each other, and then the other party appends the received configuration to trusted_servers and restarts the service. The example is as follows:</p> <pre><code>\nturn:\n  turn_user_lifetime: \"1m\"\n  turn_uris: [\"turn:192.168.10.242:3478?transport=udp\"]\n  turn_shared_secret: \"\"\n  turn_username: \"test\"\n  turn_password: \"pwd_test\"\n  trusted_servers:\n    - servername: self # The trusted_server configuration of your own node, the name is taken by yourself\n      host: 192.168.3.32 # server public network IP\n      bandwidth: 100 # server network bandwidth (unit M), this configuration is temporarily useless\n      turn_uris: [\"turn:192.168.3.32:3478?transport=udp\"]\n      salt_str: salt_str_here # Salt string used for interface parameter signature\n\n    - servername: other1 # The trusted_server configuration of the other node, the name is taken by yourself\n      host: 192.168.3.30 # server public network IP\n      bandwidth: 50 # server network bandwidth (unit M), this configuration is temporarily useless\n      turn_uris: [\"turn:192.168.3.30:3478?transport=udp\"]\n      salt_str: other_salt_str_here # Salt string used for interface parameter signature\n\n</code></pre>"},{"location":"chat/optional_cfg/#2-trusted-node-pool-configuration","title":"2-Trusted node pool configuration","text":"<p>The gateway can be configured through the trusted gateway node pool to achieve cross-node communication for users within each gateway. Just modify the corresponding configuration items of chat.yaml. The example is as follows:</p> <pre><code>trusted_federation_servers: [\"1111111.nxn\", \"2222222.nxn\"] # The configuration content is the servername of the gateway\ndisable_federation: false\n</code></pre>"},{"location":"chat/optional_cfg/#notice","title":"Notice","text":"<pre><code>     When the file storage cleanup time period configuration of this node is modified, the chat service configuration file will be regenerated.\n     This means that the shared bandwidth configuration here will be invalid, so it needs to be reconfigured\n</code></pre>"},{"location":"chat/prometheus_doc/","title":"Prometheus status monitoring","text":"<pre><code>    # HELP dendrite_caching_ristretto_cost *ristretto cache consumption\n\n    # TYPE dendrite_caching_ristretto_cost gauge\n\n    dendrite_caching_ristretto_cost 0\n\n  # HELP dendrite_caching_ristretto_ratio\n\n  # TYPE dendrite_caching_ristretto_ratio gauge\n\n    dendrite_caching_ristretto_ratio 0\n\n  # HELP dendrite_clientapi_reg_users_total Total number of registered users Total number of registered users\n\n  # TYPE dendrite_clientapi_reg_users_total counter\n\n    dendrite_clientapi_reg_users_total 0\n\n  # HELP dendrite_federationapi_destination_queues_backing_off The number of cross-node event sending\n\n  # TYPE dendrite_federationapi_destination_queues_backing_off gauge\n\n    dendrite_federationapi_destination_queues_backing_off 0\n\n  # HELP dendrite_federationapi_destination_queues_running The number of cross-node event processing\n\n  # TYPE dendrite_federationapi_destination_queues_running gauge\n\n    dendrite_federationapi_destination_queues_running 0\n\n  # HELP dendrite_federationapi_destination_queues_total total number of cross-node events\n\n  # TYPE dendrite_federationapi_destination_queues_total gauge\n\n    dendrite_federationapi_destination_queues_total 0\n\n  # HELP dendrite_federationapi_recv_edus Number of incoming EDUs from remote servers The number of cross-node events received from remote servers\n\n  # TYPE dendrite_federationapi_recv_edus counter\n\n    dendrite_federationapi_recv_edus 0\n\n  # HELP dendrite_syncapi_active_sync_requests The number of sync requests that are active right now The number of sync requests that are active right now\n\n  # TYPE dendrite_syncapi_active_sync_requests gauge\n\n    dendrite_syncapi_active_sync_requests 0\n\n  # HELP dendrite_syncapi_waiting_sync_requests The number of sync requests that are waiting to be woken by a notifier\n\n  # TYPE dendrite_syncapi_waiting_sync_requests gauge\n\n    dendrite_syncapi_waiting_sync_requests 0\n\n  # HELP dendrite_user_online_num_requests_total Total number of internal API calls Total number of internal API calls\n\n  # TYPE dendrite_user_online_num_requests_total counter\n\n    dendrite_user_online_num_requests_total{code=\"200\"} 1214\n\n    # HELP dendrite_user_online_num_response_size_bytes A histogram of response sizes for requests. The historical return data size of user online number requests\n\n    # TYPE dendrite_user_online_num_response_size_bytes histogram\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"200\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"500\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"900\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"1500\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"5000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"15000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"50000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"100000\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_bucket{le=\"+Inf\"} 1214\n\n    dendrite_user_online_num_response_size_bytes_sum 1214\n\n    dendrite_user_online_num_response_size_bytes_count 1214\n\n    # HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n\n    # TYPE go_gc_duration_seconds summary\n\n    go_gc_duration_seconds{quantile=\"0\"} 2.5635e-05\n\n    go_gc_duration_seconds{quantile=\"0.25\"} 4.6248e-05\n\n    go_gc_duration_seconds{quantile=\"0.5\"} 5.2428e-05\n\n    go_gc_duration_seconds{quantile=\"0.75\"} 6.108e-05\n\n    go_gc_duration_seconds{quantile=\"1\"} 0.0001923\n\n    go_gc_duration_seconds_sum 0.002047596\n\n    go_gc_duration_seconds_count 37\n\n    # HELP go_goroutines Number of goroutines that currently exist.\n\n    # TYPE go_goroutines gauge\n\n    go_goroutines 168\n\n    # HELP go_info Information about the Go environment.\n\n    # TYPE go_info gauge\n\n    go_info{version=\"go1.18.3\"} 1\n\n    # HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n\n    # TYPE go_memstats_alloc_bytes gauge\n\n    go_memstats_alloc_bytes 8.1388416e+07\n\n    # HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n\n    # TYPE go_memstats_alloc_bytes_total counter\n\n    go_memstats_alloc_bytes_total 2.02933024e+08\n\n    # HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n\n    # TYPE go_memstats_buck_hash_sys_bytes gauge\n\n    go_memstats_buck_hash_sys_bytes 1.482235e+06\n\n    # HELP go_memstats_frees_total Total number of frees.\n\n    # TYPE go_memstats_frees_total counter\n\n    go_memstats_frees_total 849112\n\n    # HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n\n    # TYPE go_memstats_gc_sys_bytes gauge\n\n    go_memstats_gc_sys_bytes 7.936496e+06\n\n    # HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n\n    # TYPE go_memstats_heap_alloc_bytes gauge\n\n    go_memstats_heap_alloc_bytes 8.1388416e+07\n\n    # HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n\n    # TYPE go_memstats_heap_idle_bytes gauge\n\n    go_memstats_heap_idle_bytes 8.8064e+06\n\n    # HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n\n    # TYPE go_memstats_heap_inuse_bytes gauge\n\n    go_memstats_heap_inuse_bytes 8.5794816e+07\n\n    # HELP go_memstats_heap_objects Number of allocated objects.\n\n    # TYPE go_memstats_heap_objects gauge\n\n    go_memstats_heap_objects 77324\n\n    # HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n\n    # TYPE go_memstats_heap_released_bytes gauge\n\n    go_memstats_heap_released_bytes 1.572864e+06\n\n    # HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n\n    # TYPE go_memstats_heap_sys_bytes gauge\n\n    go_memstats_heap_sys_bytes 9.4601216e+07\n\n    # HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n\n    # TYPE go_memstats_last_gc_time_seconds gauge\n\n    go_memstats_last_gc_time_seconds 1.6812883440088644e+09\n\n    # HELP go_memstats_lookups_total Total number of pointer lookups.\n\n    # TYPE go_memstats_lookups_total counter\n\n    go_memstats_lookups_total 0\n\n    # HELP go_memstats_mallocs_total Total number of mallocs.\n\n    # TYPE go_memstats_mallocs_total counter\n\n    go_memstats_mallocs_total 926436\n\n    # HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n\n    # TYPE go_memstats_mcache_inuse_bytes gauge\n\n    go_memstats_mcache_inuse_bytes 9600\n\n    # HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n\n    # TYPE go_memstats_mcache_sys_bytes gauge\n\n    go_memstats_mcache_sys_bytes 15600\n\n    # HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n\n    # TYPE go_memstats_mspan_inuse_bytes gauge\n\n    go_memstats_mspan_inuse_bytes 274448\n\n    # HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n\n    # TYPE go_memstats_mspan_sys_bytes gauge\n\n    go_memstats_mspan_sys_bytes 342720\n\n    # HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n\n    # TYPE go_memstats_next_gc_bytes gauge\n\n    go_memstats_next_gc_bytes 1.5774864e+08\n\n    # HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n\n    # TYPE go_memstats_other_sys_bytes gauge\n\n    go_memstats_other_sys_bytes 1.646717e+06\n\n    # HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n\n    # TYPE go_memstats_stack_inuse_bytes gauge\n\n    go_memstats_stack_inuse_bytes 1.867776e+06\n\n    # HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n\n    # TYPE go_memstats_stack_sys_bytes gauge\n\n    go_memstats_stack_sys_bytes 1.867776e+06\n\n    # HELP go_memstats_sys_bytes Number of bytes obtained from system.\n\n    # TYPE go_memstats_sys_bytes gauge\n\n    go_memstats_sys_bytes 1.0789276e+08\n\n    # HELP go_threads Number of OS threads created.\n\n    # TYPE go_threads gauge\n\n    go_threads 14\n\n    # HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n\n    # TYPE process_cpu_seconds_total counter\n\n    process_cpu_seconds_total 4.27\n\n    # HELP process_max_fds Maximum number of open file descriptors.\n\n    # TYPE process_max_fds gauge\n\n    process_max_fds 65535\n\n    # HELP process_open_fds Number of open file descriptors.\n\n    # TYPE process_open_fds gauge\n\n    process_open_fds 12\n\n    # HELP process_resident_memory_bytes Resident memory size in bytes.\n\n    # TYPE process_resident_memory_bytes gauge\n\n    process_resident_memory_bytes 5.7909248e+07\n\n    # HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n\n    # TYPE process_start_time_seconds gauge\n\n    process_start_time_seconds 1.68128474314e+09\n\n    # HELP process_virtual_memory_bytes Virtual memory size in bytes.\n\n    # TYPE process_virtual_memory_bytes gauge\n\n    process_virtual_memory_bytes 1.50509568e+09\n\n    # HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n\n    # TYPE process_virtual_memory_max_bytes gauge\n\n    process_virtual_memory_max_bytes 1.8446744073709552e+19\n\n    # HELP promhttp_metric_handler_requests_in_flight Current number of scrapes being served.\n\n    # TYPE promhttp_metric_handler_requests_in_flight gauge\n\n    promhttp_metric_handler_requests_in_flight 1\n\n    # HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.\n\n    # TYPE promhttp_metric_handler_requests_total counter\n\n    promhttp_metric_handler_requests_total{code=\"200\"} 1\n\n    promhttp_metric_handler_requests_total{code=\"500\"} 0\n\n    promhttp_metric_handler_requests_total{code=\"503\"} 0\n\n\n</code></pre>"},{"location":"chat/voip_signaling/","title":"Call flow","text":"<p>Useful links: - https://codelabs.developers.google.com/codelabs/webrtc-web/#0 - http://webrtc.github.io/webrtc-org/native-code/android/</p> <p> </p>"},{"location":"gateway/config/","title":"configuration","text":""},{"location":"gateway/config/#block-time","title":"block time","text":"<p>The commit timeout value in the node config defines how long we wait after committing a block before starting a new height (this gives us the chance to receive more precommits even though we already have +2/3) . The current default is <code>6s</code>.</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>\ud83d\udce3 Tip: As of v6, this is automatically handled by the server when initializing the node. Validators need to ensure that their local nodes are configured to speed up the network to ~2 second block times. :::</p> <pre><code># In $install_path/.stcd/config/config.toml\n\n#######################################################\n###         Consensus Configuration Options         ###\n#######################################################\n[consensus]\n\n### ... \n\n# How long we wait after committing a block, before starting on the new\n# height (this gives us a chance to receive some more precommits, even\n# though we already have +2/3).\ntimeout_commit = \"1s\"\n</code></pre>"},{"location":"gateway/config/#node","title":"node","text":"<p>In <code>$install_path/.stcd/config/config.toml</code> you can set your peers.</p> <p>See Adding Persistent Nodes in our docs for an automated method, but the fields should look like comma-separated peer strings (don't copy it, just an example):</p> <pre><code>persistent_peers = \"5576b0160761fe81ccdf88e06031a01bc8643d51@195.201.108.97:24656,13e850d14610f966de38fc2f925f6dc35c7f4bf4@176.9.60.27:26656,38eb4984f89899a5d8d1f04a79b356f15681bb78@18.169.155.159:26656,59c4351009223b3652674bd5ee4324926a5a11aa@51.15.133.26:26656,3a5a9022c8aa2214a7af26ebbfac49b77e34e5c5@65.108.1.46:26656,4fc0bea2044c9fd1ea8cc987119bb8bdff91aaf3@65.21.246.124:26656,6624238168de05893ca74c2b0270553189810aa7@95.216.100.80:26656,9d247286cd407dc8d07502240245f836e18c0517@149.248.32.208:26656,37d59371f7578101dee74d5a26c86128a229b8bf@194.163.172.168:26656,b607050b4e5b06e52c12fcf2db6930fd0937ef3b@95.217.107.96:26656,7a6bbbb6f6146cb11aebf77039089cd038003964@94.130.54.247:26656\"\n</code></pre>"},{"location":"gateway/config/#share-your-node","title":"Share your node","text":"<p>You can view and share your peers with the <code>tendermint show-node-id</code> command</p> <pre><code>stcd tendermint show-node-id\nac29d21d0a6885465048a4481d16c12f59b2e58b\n</code></pre> <ul> <li>node format: <code>node-id@ip:port</code></li> <li>Example: <code>ac29d21d0a6885465048a4481d16c12f59b2e58b@143.198.224.124:26656</code></li> </ul>"},{"location":"gateway/config/#health-node","title":"Health Node","text":"<p>If you only rely on seed nodes and have no persistent peers or only a small number, please add the following parameters to <code>config.toml</code>:</p> <pre><code># Maximum number of inbound peers\nmax_num_inbound_peers = 120\n\n# Maximum number of outbound peers to connect to, excluding persistent peers\nmax_num_outbound_peers = 60\n</code></pre>"},{"location":"gateway/disk-usage/","title":"Disk usage optimization","text":"<p>Customize configuration settings to reduce disk requirements for validator nodes.</p> <p>Blockchain databases tend to grow over time, depending on things like block speed and transaction amounts. For Daodst we're talking close to 100GB of disk usage for the first two weeks.</p> <p>Few configurations can significantly reduce the required disk usage. Some of these changes will not fully take effect until you configure and sync from using them.</p>"},{"location":"gateway/disk-usage/#index","title":"index","text":"<p>If you don't need to query transactions from a specific node, you can disable the index. Set it in <code>config.toml</code></p> <pre><code>indexer = \"null\"\n</code></pre> <p>If you do this on a node that is already synced, the collected indexes will not be cleared automatically, you will need to delete them manually. The index is located under the database directory named <code>data/tx_index.db/</code>.</p>"},{"location":"gateway/disk-usage/#state-synchronization-snapshot","title":"State synchronization snapshot","text":"<p>I believe this is disabled by default on Daodst, but will be listed here anyway. In <code>app.toml</code> set</p> <pre><code>snapshot-interval = 0\n</code></pre> <p>Note that if state sync is enabled on the network and working properly, it will allow one to sync a new node in a matter of minutes. But this node will not have history.</p>"},{"location":"gateway/disk-usage/#configure-pruning","title":"Configure pruning","text":"<p>By default, every 500 states are kept, and the last 100 states are kept. In the long run, this consumes a lot of disk space, which can be optimized with the following custom configuration:</p> <pre><code>pruning = \"custom\"\npruning-keep-recent = \"100\"\npruning-keep-every = \"0\"\npruning-interval = \"10\"\n</code></pre>"},{"location":"gateway/disk-usage/#index_1","title":"index","text":"<p>If you don't need to query transactions from a specific node, you can disable the index. Set it in <code>config.toml</code></p> <pre><code>indexer = \"null\"\n</code></pre> <p>If you do this on a node that is already synced, the collected indexes will not be cleared automatically, you will need to delete them manually. The index is located under the database directory named <code>data/tx_index.db/</code>.</p>"},{"location":"gateway/disk-usage/#state-synchronization-snapshot_1","title":"State synchronization snapshot","text":"<p>I believe this is disabled by default on Daodst, but will be listed here anyway. In <code>app.toml</code> set</p> <pre><code>snapshot-interval = 0\n</code></pre> <p>Note that if state sync is enabled on the network and working properly, it will allow one to sync a new node in a matter of minutes. But this node will not have history.</p>"},{"location":"gateway/disk-usage/#configure-pruning_1","title":"Configure pruning","text":"<p>By default, every 500 states are kept, and the last 100 states are kept. In the long run, this consumes a lot of disk space, which can be optimized with the following custom configuration:</p> <pre><code>5.3G    ./state.db\n70G     ./application.db\n20K     ./snapshots/metadata.db\n24K     ./snapshots\n9.0G    ./blockstore.db\n20K     ./evidence.db\n1018M   ./cs.wal\n4.7G    ./tx_index.db\n90G     .\n</code></pre> <p>This optimized configuration has reduced disk usage to 17 GB.</p> <pre><code>17G     .\n1.1G    ./cs.wal\n946M    ./application.db\n20K     ./evidence.db\n9.1G    ./blockstore.db\n24K     ./snapshots\n20K     ./snapshots/metadata.db\n5.3G    ./state.db\n</code></pre>"},{"location":"gateway/faq/","title":"Authenticator FAQ","text":"<p>Review frequently asked questions about running validators on DST.</p>"},{"location":"gateway/faq/#general-concepts","title":"General concepts","text":"What is a validator? <p>DST is powered by [Tendermint](https://docs.tendermint.com/v0.34/introduction/what-is-tendermint.html) Core, which relies on a set of validators to secure the network. </p> <p>Validators run a full node and participate in consensus by broadcasting votes containing cryptographic signatures signed by their private keys. Validators submit new blocks in the blockchain and earn income in exchange for their work. </p> <p>They also participate in financial governance within the protocol by voting on governance proposals. Validators' voting influence is weighted by their total stake. </p> What is \"staking\"? <p>DST is a public proof-of-stake (PoS) blockchain, which means validators are weighted based on the amount of Mortgage Tokens (FM) held as collateral. These staked tokens can be directly staked by validators or delegated to them by FM holders. </p> <p>Any user in the system can declare their intent to become a validator by sending a <code>create-validator</code> transaction. From there, they become validators. A validator's weight (i.e. total stake or voting power) determines whether it is an active validator, and also determines how often the node proposes blocks and how much it will earn. </p> <p>Initially, only the top 150 validators with the highest weight will be active validators. If validators double-sign or are often offline, they risk staked tokens (including user-delegated FMs) being \u201cslashed\u201d by the protocol to punish negligence and misconduct. </p> What is a full node? <p>A full node is a program that fully verifies the transactions and blocks of a blockchain. It differs from light client nodes that only process block headers and a small set of transactions. Running a full node requires more resources than a light client, but it is required to be a validator. </p> <p>In practice, running a full node simply means running an uncompromised and up-to-date version of the software, with low network latency and no downtime. Of course, any user can and is encouraged to run a full node, even if they don't intend to become a validator. </p> What is pos commission? <p>Delegators are FM holders who cannot or do not want to run validator operations themselves. . Users can delegate FM to validators and receive a portion of their revenue in exchange (for more details on how revenue is distributed, see What is the motivation for staking? and What is Validation below? server commissions? section). </p> <p>Because they share revenue with their validators, delegators also share responsibility. If a validator misbehaves, each of its delegators will be partially slashed in proportion to their stake. This is why delegators should do due diligence on validators before delegating and diversify by spreading their stake across multiple validators. </p> <p>Delegators play a key role in the system as they are responsible for selecting validators. Note that being a principal is not a passive role. Delegators are obliged to be vigilant and actively monitor the behavior of their validators and switch if they fail to act responsibly. </p>"},{"location":"gateway/faq/#become-a-validator","title":"Become a validator","text":"How to become a validator? <p> Any participant in the network can indicate their intention to become a validator by creating a validator and registering their validator profile. To do this, candidates broadcast a <code>create-validator</code> transaction in which they must submit the following information: <ul> <li>Validator's PubKey: Validator operators can have different accounts for validating and holding liquidity. </li> The submitted PubKey must be associated with the private key with which the validator intends to sign prevotes and precommits.  <li>Validator's Address: dstvaloper1- address. This is the address used to publicly identify your validator. The private key associated with this address is used for binding, unbinding and claiming rewards. </li> <li>Validator's name (also known as nickname)</li> <li>Validator's website(optional)</li> <li>Validator's description (optional)</li> <li>Initial commission rate: Block rewards and fees charged to delegators.</li> <li>Maximum commission: The maximum commission rate this validator will be allowed to charge. </li> <li>Commission change rate: Maximum daily increase in validator commission. </li> <li>Minimum self-bond amount: The minimum amount of FMs that the validator needs to always bond with. If a validator's self-staking stake falls below this limit, its entire staking pool will be unstaked. </li> <li>Initial self-bond amount: The initial FM amount that the validator wants to self-bond. </li> </ul> <pre><code>stcd tx staking create-validator\n--pubkey dstvalconspub1zcjduepqs5s0vddx5m65h5ntjzwd0x8g3245rgrytpds4ds7vdtlwx06mcesmnkzly\n--amount \"2fm\"\n--from tmp\n--commission-rate=\"0.20\"\n--commission-max-rate=\"1.00\"\n--commission-max-change-rate=\"0.01\"\n--min-self-delegation \"1\"\n--moniker \"validator\"\n--chain-id \"fm_9000-4\"\n--gas auto\n--node tcp://127.0.0.1:26647\n</code></pre> </p> <p> \ud83d\udea8 Dangerous: DO NOT use test as the keyring backend to create your mainnet validator keys. Doing so can result in the loss of funds, as your funds can be accessed remotely via the <code>eth_sendTransaction</code> JSON-RPC endpoint. </p> <p> Once a validator is created and registered, FM holders can delegate FM to it, effectively adding stake to their pool. The total pledge amount of the validator is the sum of the FM staked by the validator operator itself and the FM staked by the external delegator. </p> <p> Only the top 150 validators holding the most stake are considered active and become Bind authenticator. If the validator's total stake falls below the top 150, the validator will lose its validator privileges (meaning it will not generate rewards) and will no longer be part of the active set (i.e. not participate in consensus), enter  to unbind mode and eventually becomes Unbind. </p>"},{"location":"gateway/faq/#authenticator-key-and-state","title":"Authenticator key and state","text":"What are the different types of keys? <p>In short, there are two types of keys:</p> <ul> <li>Tendermint key: This is the unique key used to sign the block hash. It is associated with the public key <code>dstvalconspub</code>.  <ul> <li>Generated when a node is created with <code>stcd init</code>. </li> <li>Use <code>stcd tendermint show-validator</code> to get this value, for example <code>dstvalconspub1zcjduc3qcyj09qc03elte23zwshdx92jm6ce88fgc90rtqhjx8v0608qh5ssp0w94c</code></li> </ul> </li> <li>Application Keys: These keys are created from the application and are used to sign transactions. As a validator, you might use one key to sign staking-related transactions and another key to sign oracle-related transactions. The application key is associated with the public key <code>dstpub-</code> and the address <code>dst-</code>. Both are derived from account keys generated by <code>stcd keys add</code>. </li> </ul> <p> \u26a0\ufe0fNote: The validator's operator key is bound directly to the application key, but the reserved prefixes are used only for this purpose: <code>dstvaloper</code> and <code>dstvaloperpub</code> </p> What are the different states that a validator can be in? <p>Once a validator is created using the create-validator transaction, it can be in three states:</p> <ul> <li>bonded: The validator is in the active set and participating in consensus. Validators are being rewarded and can be slashed for misbehavior. </li> <li>unbonding: The validator is not in the active set and does not participate in the consensus.  Validators are not rewarded, but can still be slashed for misbehavior. This is the transition state from bound to unbound. If a validator does not send a rebond transaction in unbond mode, it takes two weeks to complete the state transition. </li> <li>unbonded: The validator is not in the active set and therefore does not sign blocks.  Unbonded validators cannot be slashed, but do not receive any rewards for their actions. FM can still be delegated to this validator.  Unbonding from an <code>unbonded</code> validator is immediate. Delegators have the same state as their validators. </li> </ul> \u26a0\ufe0fNote: A delegate is not necessarily bound. FM can be delegated and bound, delegated and unbound, delegated and unbound, or liquid.  What is a \"self-mortgage\"? How do I increase my \"self-mortgage\"? <p> A validator operator's self-staking refers to the amount of FM pledged to itself. You can increase your self-staking by delegating more FM to your validator account. </p> Is there a testnet faucet? <p> If you want to get testnet coins, you can use water-tap </p> Is there a minimum amount of FMs that must be staked to be an active (bonded) validator?  <p> There is no minimum. The top 150 validators with the highest total stake (where <code>total stake = self-bonded stake + delegators stake</code>) are active validators. </p> How will delegators choose their validators?  <p> Delegators are free to choose validators based on their own subjective criteria. That said, criteria expected to be important include: </p> <ul> <li>Number of self-bonded FMs: The number of FMs the validator has self-bonded to its staking pool. Validators with more self-bonded FMs have more skin in the game, making them more responsible for their actions. </li> <li>Number of FMs Delegated: The total number of FMs delegated to the validator. A high stake indicates that the community trusts the validator, but also means that the validator is a bigger target for hackers. As the number of delegated FMs grows, validators are expected to become less and less attractive. Larger validators also increase the centralization of the network. </li> <li>Commission Rate: The commission that validators apply to earnings before distributing them to their delegators</li> <li>Track History: Delegators may view the track records of the validators they plan to delegate to. This includes seniority, past votes on proposals, historical average uptime, and how often nodes are compromised. </li> </ul> <p> In addition to these criteria, validators can also provide a website address to complete their resume. Validators need to build a reputation somehow to attract delegators. For example, it is good practice for validators to have their settings audited by a third party. Note, however, that the DST community does not self-approve or conduct any moderation. </p>"},{"location":"gateway/faq/#responsibilities","title":"Responsibilities","text":"Do verifiers need to disclose their identities?  <p> No they don't. Each delegator will evaluate validators according to their own criteria. Validators will be able to (and be advised to) register a website address when they nominate themselves so they can advertise their operations as they see fit. Some delegators may prefer a website that clearly shows the team running the validator and their bio, while others may prefer an anonymous validator with a good track record. Authenticators and anonymous verifiers will most likely co-exist in the validator set. </p> What is the role of a validator? <p> Validators have three main responsibilities:  <ul> <li> Be able to consistently run the correct version of the software: Validators need to ensure that their servers are always online and their private keys are not compromised. </li> <li> Provide oversight and feedback on the proper deployment of community pool funds: The Daodst Protocol includes a proposal governance system to facilitate the adoption of its currency. Validators are expected to hold budget implementers accountable for providing transparency and efficient use of funds. </li> </ul>  Additionally, validators should be active members of the community. They should always be aware of the current state of the ecosystem so they can easily adapt to any changes. </p> What does staking mean? <p> Staking FM can be regarded as a security deposit for verification activities. When a validator or delegator wants to get back some or all of their stake, they send an unbond transaction. Deposits then go through a *two-week unbonding period* during which they may be slashed for potential misconduct by validators before the unbonding process begins. </p> Can a validator run away with a delegator's FM?  <p> By delegating to a validator, a user delegates a stake. The more collateral a validator has, the more weight it has in the consensus and process. This does not mean that validators can take custody of their delegators' FM. Verifiers must never run away with delegator funds.  Even if delegated funds cannot be stolen by their validators, delegators are still liable if their validators misbehave. In this case, each settlor's stake will be partially cut in proportion to their relative stake. </p> How often will a validator be elected to propose the next block? Will it increase with the number of staked FM <p> The verifier selected to mine the next block is called the proposer, which is the `leader`\"` in this round of consensus. Each proposer is deterministically selected and is selected by The selected frequency is equal to the validator's relative total stake (where total stake = self-mortgaged stake + delegator's stake). For example, if the total stake of all validators is 100 FM, and the total stake of a validator is 10 FM, then that validator will have a 10% chance of being elected as a proposer.  To learn more about the proposer selection process in the Tendermint BFT consensus, read more (https://docs.tendermint.com/master/spec/consensus/proposer-selection.html) </p>"},{"location":"gateway/faq/#incentives","title":"Incentives","text":"What is the motivation for staking?   Each member of a validator stake pool receives a different type of income:  <p> Block Reward: The native token of the application run by the validator (e.g. FM on Daodst) is inflated to generate block terms. These terms exist to incentivize FM holders to bind their stake, as unbound FM will Diluted over time. </p> <p> Transaction Fees: Daodst maintains a whitelist of tokens that are accepted as payment for fees. The initial fee token is `dst`. <p>  This total revenue is distributed to validators' stake pools according to each validator's weight. Then, in each The validator\u2019s staking pool revenue is distributed to delegators in proportion to each delegator\u2019s stake. commission The delegator's income is applied by the validators before being distributed.   What is the motivation for running the validator?   Validators earn more than their delegators due to commissions.  Validators also play an important role in governance. If a delegator does not vote, they will inherit their voting rights validator. This gives validators primary responsibility in the ecosystem.   What is a validator commission?   The revenue received by the validator pool is distributed between the validator and its delegators. Validators can apply A commission allocated to a portion of the principal's income. This commission is set as a percentage.  Each validator is free to set its initial commission, maximum daily commission change rate, and maximum commission. Daodst enforces parameters set by each validator. These parameters can only be defined when initially declaring Candidature, and can be further restricted only if declared.   How are collective provisions assigned?  <p> Block terms (rewards) are distributed among all validators proportional to their total stake (voting power). This means that even though each validator earns FM per supply, all validators will remain equal weight. </p> <p> Let's take an example where we have 10 validators with the same stake and 1% commission rate. let us also Suppose the supply of a block is 1000 FM, and each validator has 20% self-mortgaged FM. these tokens Do not go directly to the proposer. Instead, they are evenly distributed among validators. So now each validator's pool There are 100 FMs. The 100 FM will be distributed according to each participant's stake: </p> <ul> <li>Commission: `100*80%*1% = 0.8 FM`</li> <li>Validator gets: `100\\*20% + commission = 20.8 FM`</li> <li>All principals get: `100\\*80% - commission = 79.2 FM`</li> </ul> Each delegator can then claim a portion of the 79.2 FM in proportion to their stake in the validator's stake pool. Note that validator commissions do not apply to block terms. Note that block rewards are distributed according to the same mechanism.   How will costs be allocated?  <p> Fees are distributed in a similar manner, except block proposers get a block fee bonus Suggest if it contains more than the strict minimum required precommit. </p> <p> When a validator is chosen to propose the next block, it must include at least \u2154 precommits of the previous block The form of the verifier's signature. However, there is an incentive to include more than \u2154 of pre-commits bonus. Rewards are linear: if a proposer includes \u2154rd precommits (the minimum for a block), the reward ranges from 1% valid) to 5%, if the proposer includes 100% pre-commit. Of course suitors can't wait too long or whatever A validator may timeout and move on to the next proposer. Therefore, validators must find a balance between The wait time for getting the most signatures and the risk of losing the proposed next block. The mechanism is designed to Incentivizes non-empty block proposals, better networking among validators, and mitigation of censorship. </p> <p> Let us take a concrete example to illustrate the above concept. In this example, there are 10 validators equal interest. They charge 1% commission each and have a 20% self-insured FM. Now comes a successful block A total of 1005 dst will be charged. Suppose the proposer includes 100% of the signatures in its proposal clogged. Get a full 5% bonus. </p> <p> We have to solve this simple equation to find the reward for each validator: </p>  $$9R ~ + ~ R ~ + ~ 5\\%(R) ~ = ~ 1005 ~ \\left and right arrows ~ R ~ = ~ 1005 ~/ ~10.05 ~ = ~ 100$$  <p> For proposer validators: </p> <ul> <li>Pool gets $R ~ + ~ 5\\%(R)$: 105 DST</li> <li>Commission: $105 ~ *~ 80\\% ~* ~ 1\\%$ = 0.84 DST</li> <li>Validator reward: $105 ~ * ~ 20\\% ~ + ~ commission = 21.84 DST</li> <li>Delegator Rewards: $105 ~ * ~ 80\\% ~ - ~ Commission = 83.16 DST (each delegator can claim his own portion These rewards are proportional to their stake)</li> <li>Pool gets $R$: 100 DST</li> <li>Commission: $100 ~ *~ 80\\% ~* ~ 1\\%$ = 0.8 DST</li> <li>Validator reward: $100 ~ * ~ 20\\% ~ + ~ commission = 20.8 DST</li> <li>Delegator Rewards: $100 ~ * ~ 80\\% ~ - ~ Commission = 79.2 DST (each delegator can claim his own portion These rewards are proportional to their stake)</li> </ul> What are the cut conditions?  <p> If a validator misbehaves, its pledged stake and its delegator's stake will be slashed. the severity of Penalties depend on the type of error. There are 3 major bugs that could result in a validator's funds being slashed and its principals: </p> <p> Double Signature: If someone on chain A reports that the validator signed two blocks at the same height on chain A and Chain B, if chain A and chain B share a common ancestor, then this validator will be slashed on chain A. punish Double sign is 10.00% of the total shares. </p> <ul> <li>Downtime: If validators miss more than 50% of the last 90.000 blocks, they will be slashed by 0.50%. </li> <li>Unavailability: If the validator's signature is not included in the last X blocks, the validator will get is cut by a marginal quantity proportional to X. If X is above some limit Y, the validator will unbind. </li> </ul> <p> Note that even if a validator does not misbehave intentionally, it will still be slashed if its node crashes, loses Connectivity, get DDoSed, or have their private key compromised. </p> Do validators need to self-bind FM?  <p> No they don't. A validator's total stake is equal to the sum of its own collateral stake and its delegated stake. This means that validators can compensate their small self-staking stake by attracting more delegators. This is Why reputation is very important for validators. </p> <p> Even though validators are not obliged to bind FM themselves, delegators should expect their validators to have Self-bond FM in their staking pool. In other words, validators should participate. </p> <p> To give delegators some assurance about how much stake their validators have, the latter can signal Minimal amount of self-bonded FM. If the validator's self-constraint is lower than its predefined limit, then this The validator and all its delegators will be unbound. </p> How to prevent the concentration of stake in the hands of a few top validators?  <p> For now, the community should act in a smart and self-protective manner. When bitcoin mining pools become too The community usually stops contributing much mining power to the pool. Daodst will initially rely on the same effect. In the future, other mechanisms will be deployed to smooth this process as much as possible: </p> <p> Penalty-free re-delegation: This is to allow delegators to easily switch from one validator to another so that To reduce the stickiness of the verifier. </p> <p> UI warning: Wallets can implement warnings that will be shown to users if they want to delegate to a validator Already owns a substantial mortgage. </p>"},{"location":"gateway/faq/#skills-requirement","title":"skills requirement","text":"What are the hardware requirements?  <p> Validators should expect redundant power, network, firewall, HSMs and servers. </p>  We anticipate that modest hardware specifications will be required initially, and that they may increase as the network grows Use increased. Participating in the testnet is the best way to learn more.   What are the software requirements?   In addition to running Daodst nodes, validators should also develop monitoring, alerting, and management solutions.   What are the bandwidth requirements?  <p> Daodst has very high throughput compared to chains like Ethereum or Bitcoin. </p> <p> Therefore, we recommend that data center nodes only connect to trusted full nodes or other validators in the cloud Get to know each other socially. This offloads data center nodes from mitigating denial-of-service attacks. </p> <p> Eventually, as the network is used more and more, one can actually expect bandwidth on the order of several gigabytes per day. </p> What does it mean to run a validator?   A successful validator operation will require the effort and ongoing operation of multiple highly skilled personnel attention. This is much more complicated than running a bitcoin miner, for example.   How is key management handled?   Validators should expect to run HSMs that support ed25519 keys  <p> The Daodst team does not recommend one solution over another. Encourage the community to step up efforts to Improved security for HSMs and key management. </p> What can validators expect in terms of operations?   Running efficient operations is key to avoiding accidental unbundling or hacking. This includes being able to Respond to attacks, outages, and maintain data center security and isolation.   What are the maintenance requirements?   Validators should expect to perform regular software updates to accommodate upgrades and bug fixes. inevitably there will be Problems early in the network boot phase require a high level of vigilance.   How do validators protect themselves from denial of service attacks?  <p> A denial of service attack occurs when an attacker sends a large amount of Internet traffic to an IP address to prevent server access On an IP address connected to the Internet. </p> <p> The attacker scans the network, trying to learn the IP addresses of various validator nodes and disconnect them from Communicate by flooding them with traffic. </p> <p> A recommended way to mitigate these risks is for validators to carefully structure their network topology in a so-called Sentinel node architecture. </p> <p> Validator nodes should only connect to full nodes they trust because they operate themselves or are run by others Validators they know socially. Validator nodes typically run in data centers. Most data centers provide direct Links to the network of major cloud providers. Validators can use these links to connect to Sentinel nodes in the cloud. This shifts the burden of denial of service from the validator's node directly to its sentinel nodes, and may require new Start or activate Sentinel nodes to mitigate attacks on existing nodes. </p> <p> Sentinel nodes can quickly start or change their IP address. Because the link to the Sentinel node is private IPspace, Internet-based attacks cannot directly interfere with them. This will ensure validators block proposals and votes Always let it reach the rest of the network. </p> <p> It is expected that good operating procedures by this subset of validators will fully mitigate these threats. </p>"},{"location":"gateway/guide-linux/","title":"linux operation guide","text":""},{"location":"gateway/guide-linux/#install","title":"install","text":""},{"location":"gateway/guide-linux/#centos","title":"centos","text":"<pre><code>After entering the installation directory for the first time, right-click \"Terminal Open\" to open the command line interface\n</code></pre> <pre><code>Enter the initialization command \"pkexec xxx/init.sh $USER\",xxx is the absolute path of the project\n</code></pre> <pre><code>During the initialization process, it is necessary to enter the password of the currently logged-in user once to authorize the operation\n</code></pre> <pre><code>After the initialization is complete, the interface will prompt to restart the server to complete the initialization configuration\n</code></pre> <pre><code>After restarting, enter the installation root directory and double-click the newly generated icon start.desktop ,click trust and Launch to start. In the future, you only need to double-click the start icon to start the program every time you start it.\n</code></pre>"},{"location":"gateway/guide-linux/#ubuntu","title":"ubuntu","text":"<pre><code>After entering the installation directory for the first time, right-click \"Terminal Open\" to open the command line interface\n</code></pre> <pre><code>Enter the initialization command \"pkexec xxx/init.sh $USER\",xxx is the absolute path of the project\n</code></pre> <pre><code>At the beginning of initialization, you need to enter the password of the currently logged-in user once to authorize the operation\n</code></pre> <pre><code>After the initialization is complete, the interface will prompt to restart the server to complete the initialization configuration\n</code></pre> <pre><code>After restarting, enter the installation root directory, double-click secret_telegram to start the application\n</code></pre>"},{"location":"gateway/guide-linux/#process","title":"process","text":"<pre><code>Create or import wallet address --&gt; create dpos --&gt; create gateway --&gt; pledge FM --&gt; receive rewards\n</code></pre>"},{"location":"gateway/guide-linux/#new-wallet","title":"new wallet","text":""},{"location":"gateway/guide-linux/#import-wallet","title":"import wallet","text":""},{"location":"gateway/guide-linux/#create-validator","title":"create validator","text":""},{"location":"gateway/guide-linux/#create-gateway","title":"create gateway","text":""},{"location":"gateway/guide-linux/#pledge-fm","title":"Pledge FM","text":""},{"location":"gateway/guide-linux/#receive-award","title":"Receive award","text":""},{"location":"gateway/guide-linux/#front-page","title":"front page","text":"<pre><code>The home page contains some global views and functions\n These include:\n\n\nView block synchronization (top right of the interface)\n</code></pre> <pre><code>View task status (upper right corner of interface)\n</code></pre> <pre><code>Management software settings (bottom left corner of the interface)\n</code></pre>"},{"location":"gateway/guide-linux/#actions","title":"Actions","text":"<pre><code>The Actions in the upper right corner can manage DID and modify gateway information\n</code></pre>"},{"location":"gateway/guide-linux/#did-segment-management","title":"DID segment management","text":"<pre><code>More DID numbers can be obtained by staking FM\n</code></pre> <pre><code>Select the line on the left side of the homepage, including two tabs for assets and gateways\n</code></pre>"},{"location":"gateway/guide-linux/#property","title":"Property","text":"<pre><code>Asset interface management includes balance, transfer, transaction records, and account management\n\nThe three buttons on the left correspond to the three main coins of DST, FM and HASH respectively\n</code></pre> <pre><code>On the right side, you can view the balance quantity, transaction records, and send and receive the main currency\n</code></pre> <pre><code>Here export the mnemonic and change the password\n</code></pre>"},{"location":"gateway/guide-linux/#gateway","title":"gateway","text":"<pre><code>Gateway function management dpos pledge, gateway server, gateway app, gateway key, etc.\n</code></pre>"},{"location":"gateway/guide-linux/#dpos-pledge-management","title":"DPOS pledge management","text":"<pre><code>After becoming a validator, you can check the DPOS status of this node on the _DPOS pledge management_ page\n\nAvailable for pledge and redemption\n</code></pre> <pre><code>The redemption of DPOS is not immediately received, check the redemption status here\n</code></pre> <pre><code>Can view and claim staking rewards and commissions\n</code></pre> <pre><code>Modify the settings of the gateway here\n</code></pre>"},{"location":"gateway/guide-linux/#gateway-server-resources","title":"Gateway server resources","text":""},{"location":"gateway/guide-linux/#gateway-app","title":"gateway app","text":""},{"location":"gateway/guide-linux/#gateway-key","title":"gateway key","text":"<pre><code>For details on how to use the gateway key, see\n</code></pre>"},{"location":"gateway/guide-linux/#how-to-use-the-gateway-key","title":"How to use the gateway key","text":""},{"location":"gateway/guide-linux/#setting-method","title":"Setting method","text":"<pre><code>Settings include: version detection, language detection, history clearing settings, node settings, data directory settings, routing layer detection\n</code></pre>"},{"location":"gateway/guide-linux/#upgrade","title":"upgrade","text":""},{"location":"gateway/guide-linux/#centos_1","title":"centos","text":"<pre><code>If the system has an upgrade task, the interface will automatically pop up an upgrade window\n</code></pre> <pre><code>Click to update and the latest app will be downloaded automatically\n</code></pre> <pre><code>After the new application download is complete, you will be prompted with the upgrade steps, then click Exit\n</code></pre> <pre><code>Double-click the newly generated icon upgrade.desktop, click trust and Launch to start the upgrade.\n</code></pre> <pre><code>During the upgrade process, it is necessary to enter the password of the currently logged-in user once to authorize the operation\n</code></pre>"},{"location":"gateway/guide-linux/#ubuntu_1","title":"ubuntu","text":"<pre><code>If the system has an upgrade task, the interface will automatically pop up an upgrade window\n</code></pre> <pre><code>Click to update and the latest app will be downloaded automatically\n</code></pre> <pre><code>After the new application download is complete, you will be prompted with the upgrade steps, then click Exit\n</code></pre> <pre><code>Right-click the electric shock icon upgrade.desktop, click properties\n</code></pre> <pre><code>Tick Allow Executing Files\n</code></pre> <pre><code>Right-click the icon upgrade.desktop, and select Run as a program to upgrade.\n</code></pre> <pre><code>During execution, you will be prompted to enter the current user password to authorize the operation\n</code></pre>"},{"location":"gateway/guide-linux/#manual-upgrade","title":"Manual upgrade","text":"<pre><code>Manual upgrade requires running commands as an administrator in the command window: ./gateway upgrade Perform a manual upgrade. If the gateway program is running, it will prompt to close the gateway and provide a command to exit the gateway: curl http://127.0.0.1:50321/soft/exit\n</code></pre> <pre><code>The gateway will automatically exit after executing the exit command\n</code></pre> <pre><code>Re execute upgrade command ./gateway upgrade  The program will prompt for the current version number and upgrade version number. After checking, enter y to perform the upgrade operation\n</code></pre> <pre><code>During the upgrade process, the download directory and URL address will be prompted\n</code></pre> <pre><code>If upgrading encounters permission errors, please rerun the upgrade command in administrator mode\n</code></pre> <pre><code>After the upgrade is completed, you will be prompted to enter the specified directory and perform the initialization operation again as an administrator. After completion, the program can be started normally\n</code></pre>"},{"location":"gateway/guide-win/","title":"Instructions for use on the PC side","text":""},{"location":"gateway/guide-win/#install","title":"install","text":"<pre><code>Open the installation package, jump out of the following interface, click OK (some antivirus software will falsely report)\n</code></pre> <pre><code>Select the installation directory (recommended to be larger than 1TB)\n</code></pre> <pre><code>Wait patiently for the installation to complete\n</code></pre>"},{"location":"gateway/guide-win/#process","title":"process","text":"<pre><code>Create or import wallet address --&gt; create dpos --&gt; create gateway --&gt; pledge FM --&gt; receive rewards\n</code></pre>"},{"location":"gateway/guide-win/#new-wallet","title":"new wallet","text":""},{"location":"gateway/guide-win/#import-wallet","title":"import wallet","text":""},{"location":"gateway/guide-win/#create-validator","title":"create validator","text":""},{"location":"gateway/guide-win/#create-gateway","title":"create gateway","text":""},{"location":"gateway/guide-win/#pledge-fm","title":"Pledge FM","text":""},{"location":"gateway/guide-win/#receive-award","title":"Receive award","text":""},{"location":"gateway/guide-win/#front-page","title":"front page","text":"<pre><code>The home page contains some global views and functions\n These include:\n\n\nView block synchronization (top right of the interface)\n</code></pre> <pre><code>View task status (upper right corner of interface)\n</code></pre> <pre><code>Management software settings (bottom left corner of the interface)\n</code></pre>"},{"location":"gateway/guide-win/#actions","title":"Actions","text":"<pre><code>The Actions in the upper right corner can manage DID and modify gateway information\n</code></pre>"},{"location":"gateway/guide-win/#did-segment-management","title":"DID segment management","text":"<pre><code>More DID numbers can be obtained by staking FM\n</code></pre> <pre><code>Select the line on the left side of the homepage, including two tabs for assets and gateways\n</code></pre>"},{"location":"gateway/guide-win/#property","title":"Property","text":"<pre><code>Asset interface management includes balance, transfer, transaction records, and account management\n\nThe three buttons on the left correspond to the three main coins of DST, FM and HASH respectively\n</code></pre> <pre><code>On the right side, you can view the balance quantity, transaction records, and send and receive the main currency\n</code></pre> <pre><code>Here export the mnemonic and change the password\n</code></pre>"},{"location":"gateway/guide-win/#gateway","title":"gateway","text":"<pre><code>Gateway function management dpos pledge, gateway server, gateway app, gateway key, etc.\n</code></pre>"},{"location":"gateway/guide-win/#dpos-pledge-management","title":"DPOS pledge management","text":"<pre><code>After becoming a validator, you can check the DPOS status of this node on the _DPOS pledge management_ page\n\nAvailable for pledge and redemption\n</code></pre> <pre><code>The redemption of DPOS is not immediately received, check the redemption status here\n</code></pre> <pre><code>Can view and claim staking rewards and commissions\n</code></pre> <pre><code>Modify the settings of the gateway here\n</code></pre>"},{"location":"gateway/guide-win/#gateway-server-resources","title":"Gateway server resources","text":""},{"location":"gateway/guide-win/#gateway-app","title":"gateway app","text":""},{"location":"gateway/guide-win/#gateway-key","title":"gateway key","text":"<pre><code>For details on how to use the gateway key, see\n</code></pre>"},{"location":"gateway/guide-win/#how-to-use-the-gateway-key","title":"How to use the gateway key","text":""},{"location":"gateway/guide-win/#setting-method","title":"Setting method","text":"<pre><code>Settings include: version detection, language detection, history clearing settings, node settings, data directory settings, routing layer detection\n</code></pre>"},{"location":"gateway/guide-win/#upgrade","title":"upgrade","text":"<pre><code>Check for updates by checking for updates\n</code></pre> <pre><code>Wait for the download to complete\n</code></pre> <pre><code>Just exit the update\n</code></pre>"},{"location":"gateway/key-backup/","title":"backup","text":"<p> Users can choose to back up the gateway key, authenticator key and app encryption file for recovery when needed</p> <p>Backup is divided into manual backup and on-chain backup. On-chain backup only needs a small amount of gas to back up to the chain and can be downloaded at any time</p>"},{"location":"gateway/key-backup/#manual-backup","title":"Manual backup","text":"<p>Click the gateway option on the left, click the [Download Key File] button, and save it to the specified location</p>"},{"location":"gateway/key-backup/#on-chain-backup","title":"On-chain backup","text":"<p>Click the gateway option on the left, click the [Storage on Gateway Key Chain] button, enter the password, and the storage will be completed after the chain is successfully uploaded</p>"},{"location":"gateway/key-backup/#restore","title":"restore","text":"<p>If it is stored on the chain, the [Storage button on the gateway key chain] button will be changed to [Download the key on the chain], after clicking, the three files will be saved in the GatewayKey directory under the gateway directory</p> <pre><code> GatewayKey/\n \u251c\u2500\u2500 fmc.jks # app signature file\n \u2502\u2500\u2500 node_key.json # Gateway key file\n \u2514\u2500\u2500 priv_validator_key.json # validator private key file\n</code></pre> <p>in the chain stop state Move fmc.jks to the home directory</p> <p>In the linux system, use the</p> <pre><code>echo $HOME\n</code></pre> <p>command to view the location of the current user's home directory</p> <p>In the windows system, open the resource manager and enter</p> <pre><code>%homepath%\n</code></pre> <p>in the address bar You can enter the current user's home directory</p> <p>Move node_ key.json and priv_ validator_ key.json to the gateway directory .stcd/config/ Down</p> <p>If it is stored manually, similarly, restore the corresponding file to the corresponding location</p>"},{"location":"gateway/mainnet/","title":"mainnet","text":"<p>This document outlines the steps to join an existing mainnet.</p>"},{"location":"gateway/mainnet/#prerequisites-to-read","title":"Prerequisites to read","text":"<ul> <li>Authenticator Security</li> </ul>"},{"location":"gateway/mainnet/#mainnet_1","title":"Mainnet","text":"<p>You need to setup a genesis file and a seed node. If you need more information on past networks, check out our mainnet repo. The table below outlines all mainnet chain IDs. Note that the displayed version may differ when there is an active software upgrade proposal on-chain.</p> Chain ID describe Location Version state <code>daodst_7777-1</code> Daodst Mainnet 1 Daodst <code>v1.0.0</code> <code>active</code> <p>\u26a0\ufe0f IMPORTANT: If you join mainnet as a validator, please make sure you follow all security recommendations!</p>"},{"location":"gateway/mainnet/#install-daodst","title":"Install <code>daodst</code>","text":"<p>Follow the installation documentation to install the program</p> <p>\u26a0\ufe0f Note : Make sure you have the correct version of the program installed.</p>"},{"location":"gateway/mainnet/#save-chain-id","title":"Save Chain ID","text":"<p>We recommend saving the mainnet <code>chain-id</code> to your app's <code>client.toml</code>. This will save you from having to manually pass the <code>chain-id</code> flag for every CLI command.</p> <p>\ud83d\udce3 Tip : Please refer to the official chain ID for reference.</p> <pre><code>stcd config chain-id daodst_7777-1\n</code></pre>"},{"location":"gateway/mainnet/#initialize-node","title":"Initialize node","text":"<p>We need to initialize the node to create all necessary validators and node configuration files:</p> <pre><code>stcd init &lt;your_custom_moniker&gt; --chain-id daodst_7777-1\n</code></pre> <p>\u26a0\ufe0fDangerous : Name objects can only contain ASCII characters. Using Unicode characters will make your node inaccessible.</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>By default, the <code>init</code> command creates the <code>$install_path/.stcd</code> (ie <code>$HOME</code>) directory with subfolders <code>config/</code> and <code>data/</code>. In the <code>config</code> directory, the most important configuration files are <code>app.toml</code> and <code>config.toml</code>.</p>"},{"location":"gateway/mainnet/#genesis-seed-nodes","title":"Genesis &amp; Seed Nodes","text":""},{"location":"gateway/mainnet/#copy-the-genesis-file","title":"Copy the genesis file","text":"<p>Download the <code>genesis.json</code> file from <code>github</code> and copy it to the <code>config</code> directory: <code>$install_path/.stcd/config/genesis.json</code>. This is a genesis file that contains the chain ID and the balance of the genesis account.</p> <pre><code>wget https://github.com/daodst/mainnet/daodst_7777-1/genesis.json\nmv genesis.json $install_path/.stcd/config/\n</code></pre> <p>Then verify the correctness of the genesis configuration file:</p> <pre><code>stcd validate-genesis\n</code></pre>"},{"location":"gateway/mainnet/#add-seed-node","title":"Add seed node","text":"<p>Your peers need to know how to find peers.</p> <p>You need to add a healthy seed node to <code>$install_path/.stcd/config/config.toml</code> <code>mainnet</code> repository contains some links seed node.</p> <p>Edit the files located in <code>$install_path/.stcd/config/config.toml</code> and <code>seeds</code> to the following:</p> <pre><code>#######################################################\n###           P2P Configuration Options             ###\n#######################################################\n[p2p]\n\n# ...\n\n# Comma separated list of seed nodes to connect to\nseeds = \"&lt;node-id&gt;@&lt;ip&gt;:&lt;p2p port&gt;\"\n</code></pre> <p>You can fetch a seed from the repository and add it to your config with the following code:</p> <pre><code>SEEDS=`curl -sL https://raw.githubusercontent.com/daodst/mainnet/main/daodst_7777-1/seeds.txt | awk '{print $1}' | paste -s -d, -`\nsed -i.bak -e \"s/^seeds =.*/seeds = \\\"$SEEDS\\\"/\" $install_path/.stcd/config/config.toml\n</code></pre> <p>\ud83d\udce3 Tips: For more information on torrents and peers, you can check out the Tendermint P2P Documentation.</p>"},{"location":"gateway/mainnet/#add-persistent-node","title":"Add persistent node","text":"<p>We can set <code>persistent_peers</code> Fields in <code>$install_path/.stcd/config/config.toml</code> specify the peers with which your node will maintain persistent connections. You can retrieve them from the list of available nodes in the <code>mainnet</code> repository.</p> <p>You can grab 10 random entries from the <code>peers.txt</code> file for the <code>PEERS</code> variable by running:</p> <pre><code>PEERS=`curl -sL https://raw.githubusercontent.com/daodst/mainnet/main/daodst_7777-1/peers.txt | sort -R | head -n 10 | awk '{print $1}' | paste -s -d, -`\n</code></pre> <p>Use <code>sed</code> to include them into the configuration. You can also add them manually:</p> <pre><code>sed -i.bak -e \"s/^persistent_peers *=.*/persistent_peers = \\\"$PEERS\\\"/\" $install_path/.stcd/config/config.toml\n</code></pre>"},{"location":"gateway/mainnet/#run-mainnet-validator","title":"Run mainnet validator","text":"<p>\ud83d\udce3 Tips: For more details on how to run a validator, follow the validator these instruct.</p> <pre><code>stcd tx staking create-validator \\\n--amount=1000000000000dst \\\n--pubkey=$(stcd tendermint show-validator) \\\n--moniker=\"Daodst1\" \\\n--chain-id=&lt;chain_id&gt; \\\n--commission-rate=\"0.05\" \\\n--commission-max-rate=\"0.20\" \\\n--commission-max-change-rate=\"0.01\" \\\n--min-self-delegation=\"1000000\" \\\n--gas=\"auto\" \\\n--gas-prices=\"0.025dst\" \\\n--from=&lt;key_name&gt;\n</code></pre> <p>\ud83d\udea8 DANGER: NEVER create validator keys using <code>test</code> as the keyring backend. Doing so may cause your funds to be accessed remotely via the <code>eth_sendTransaction</code> JSON-RPC endpoint, resulting in loss of funds.</p> <p>Reference: Security Advisory: Insecurely configured geth can make funds remotely accessible</p>"},{"location":"gateway/mainnet/#start-the-mainnet","title":"Start the mainnet","text":"<p>The last step is to start the node. Once enough voting power (+2/3) Starting from the genesis validator, nodes will start producing blocks.</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"gateway/mainnet/#share-your-node","title":"Share your node","text":"<p>You can share your peers and post them in the <code>#find-peers</code> channel on the Daodst Discord.</p> <p>\ud83d\udce3 Hint: To get your node ID, use</p> <pre><code>stcd tendermint show-node-id\n</code></pre>"},{"location":"gateway/mainnet/#state-synchronization-node","title":"State synchronization node","text":"<p>If you want to join the network using state-sync (fast, but not for archive nodes), check out our state-sync page.</p>"},{"location":"gateway/mempool/","title":"memory pool","text":"<p>Learn about the memory pool options available in Tendermint.</p>"},{"location":"gateway/mempool/#first-in-first-out-memory-pool","title":"First in first out memory pool","text":"<p>The mempool holds uncommitted transactions, which have not yet been included in a block. The default mempool implementation of the Tendermint blockchain follows the first-in-first-out (FIFO) principle, meaning that the order of transactions is determined only by the order in which they arrive at nodes. The first transaction received will be the first transaction to be processed. This works for gossiping received transactions to other nodes and including them in a block.</p>"},{"location":"gateway/mempool/#priority-memory-pool","title":"Priority memory pool","text":"<p>From Tendermint v0.35 (Also backported to v0.34.20) This can be achieved using a priority memory pool. This allows validators to select transactions based on associated fees or other incentives. It does this by passing a <code>priority</code> field for each <code>CheckTx</code> response , It operates on any transaction trying to enter the mempool.</p> <p>daodst supports EIP-1559 through its EVM transactions. This transaction type uses a base fee and an optional priority tip, which add up to the total transaction fee. Priority memory pools provide an option to automatically use this mechanism for block generation.</p> <p>When using a priority mempool, the next transaction to generate a block is selected in order of priority (i.e. fee) from high to low. If the mempool is full, the priority implementation allows the lowest priority transactions to be dropped until enough disk space is available for incoming, higher priority transactions (see v1/mempool.go for more details).</p> <p>\ud83d\udce3 Tip: Although transactions can be prioritized, transaction gossip will always be FIFO.</p>"},{"location":"gateway/mempool/#configuration","title":"configuration","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>To use the preferred mempool, adjust <code>version = \"v1\"</code> in your node configuration in <code>$install_path/.stcd/config/config.toml</code>. The default value <code>v0</code> means a traditional FIFO memory pool.</p> <p>\ud83d\udce3 Tip: Remember to restart the node for the changes to take effect.</p> <p>See the relevant excerpt from <code>config.toml</code> here:</p> <pre><code>#######################################################\n###          Mempool Configuration Option          ###\n#######################################################\n[mempool]\n\n# Mempool version to use:\n#   1) \"v0\" - (default) FIFO mempool.\n#   2) \"v1\" - prioritized mempool.\nversion = \"v1\"\n</code></pre>"},{"location":"gateway/mempool/#resource","title":"resource","text":"<p>More detailed information can be found here:</p> <ul> <li>Tendermint ADR-067 - Mempool Refactor.</li> <li>Blogpost: Tendermint v0.35 Announcement</li> <li>EIP-1559: Fee market change for ETH 1.0 chain</li> <li>EIP-1559 FAQ</li> <li>Blogpost: What is EIP-1559? How will it change Ethereum?</li> </ul>"},{"location":"gateway/run/","title":"run validator","text":"<p>Learn how to run a validator node.</p>"},{"location":"gateway/run/#prerequisites","title":"prerequisites","text":"<ul> <li>Validator Overview</li> <li>validator-security</li> </ul> <p>\ud83d\udce3 Tips: If you plan to use a Key Management System (KMS), you should first complete the following steps: Use KMS.</p>"},{"location":"gateway/run/#create-your-validator","title":"Create your validator","text":"<p>Your node consensus public key (<code>dstvalconspub...</code>) can be used to create new validators by staking FM tokens. You can find your validator public key by running:</p> <pre><code>stcd tendermint show-validator\n</code></pre> <p>\ud83d\udea8 DANGER: NEVER use the <code>test</code> keying backend to create your mainnet validator keys. Doing so may cause your funds to be accessed remotely via the <code>eth_sendTransaction</code> JSON-RPC endpoint, resulting in loss of funds.</p> <p>Ref: Security Alert: Insecurely configured geth can make funds remotely</p> <p>To create a validator on the testnet, simply use the following command:</p> <pre><code>stcd tx staking create-validator \\\n  --amount=100000000000000000000dst \\\n  --pubkey=$(stcd tendermint show-validator) \\\n  --moniker=\"choose a moniker\" \\\n  --chain-id=&lt;chain_id&gt; \\\n  --commission-rate=\"0.05\" \\\n  --commission-max-rate=\"0.10\" \\\n  --commission-max-change-rate=\"0.01\" \\\n  --min-self-delegation=\"1000000\" \\\n  --gas=\"auto\" \\\n  --gas-prices=\"0.025dst\" \\\n  --from=&lt;key_name&gt;\n</code></pre> <p>\ud83d\udce3 Tip: When specifying commission parameters, <code>commission-max-change-rate</code> is used to measure % point change relative to <code>commission-rate</code>. For example. 1% to 2% is 100% growth, but only 1 percentage point.</p> <p>\ud83d\udce3 Tip: <code>Min-self-delegation</code> is a strictly positive integer representing the minimum self-delegating voting power your validators must always have. <code>min-self-delegation</code> of <code>1000000000000000000</code> means that your validators can never self-delegate below <code>1 dst</code></p> <p>You can use a third-party browser to confirm that you are in the validator set.</p>"},{"location":"gateway/run/#edit-validator-description","title":"Edit validator description","text":"<p>You can edit a validator's public description. This information is used to identify your validators and will be used by delegators to decide which validators to stake with. Make sure to provide input for each of the flags below. If no flag is included in the command, the field will default to empty (<code>--moniker</code> defaults to the machine name), if the field has never been set, or remain unchanged if it was set in the past.</p> <p> specifies the validator you are editing. If you choose not to include certain flags, remember that you must include the --from flag to identify which validators to update. <p><code>--identity</code> can be used to authenticate with systems like Keybase or UPort. When used with Keybase, <code>--identity</code> should be populated with a 16-digit string generated by the keybase.io account. This is an encrypted and secure method of verifying your identity across multiple online networks. The Keybase API allows us to retrieve your Keybase avatar. This is how you can add your logo to your validator profile.</p> <pre><code>stcd tx staking edit-validator\n  --moniker=\"choose a moniker\" \\\n  --website=\"https://daodst.com\" \\\n  --identity=6A0D65E29A4CBC8E \\\n  --details=\"To infinity and beyond!\" \\\n  --chain-id=&lt;chain_id&gt; \\\n  --gas=\"auto\" \\\n  --gas-prices=\"0.025dst\" \\\n  --from=&lt;key_name&gt; \\\n  --commission-rate=\"0.10\"\n</code></pre> <p>\u26a0\ufe0f NOTE: <code>commission-rate</code> value must comply with the following requirements:</p> <ul> <li>Must be between 0 and the validator's <code>commission-max-rate</code></li> <li>MUST NOT exceed the validator's <code>commission-max-change-rate</code>, which is the maximum percentage change rate per day. In other words, a validator can only change its commission once per day in the range <code>commission-max-change-rate</code>.</li> </ul>"},{"location":"gateway/run/#view-validator-description","title":"View validator description","text":"<p>Use this command to view the validator's information:</p> <pre><code>stcd query staking validator &lt;account_cosmos&gt;\n</code></pre>"},{"location":"gateway/run/#signing-info-track-validator-signing-information","title":"signing-info Track validator signing information","text":"<p>In order to keep track of past validator signatures, you can use the <code>signing-info</code> command:</p> <pre><code>stcd query slashing signing-info &lt;validator-pubkey&gt;\\\n   --chain-id=&lt;chain_id&gt;\n</code></pre>"},{"location":"gateway/run/#unjail-unjail-validator","title":"unjail unjail validator","text":"<p>When validators are \"jailed\" due to downtime, you must submit an <code>Unjail</code> transaction from your operator account to be able to receive block proposer rewards again (subject to regional fee distribution).</p> <pre><code>stcd tx slashing unjail \\\n   --from=&lt;key_name&gt; \\\n   --chain-id=&lt;chain_id&gt;\n</code></pre>"},{"location":"gateway/run/#verify-your-validator-is-running","title":"Verify your validator is running","text":"<p>If the following command returns nothing, your validator is active:</p> <pre><code>stcd query tendermint-validator-set | grep \"$(stcd tendermint show-address)\"\n</code></pre> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>You should now see your authenticator in one of the Daodst browsers. You are looking for the <code>bech32</code> encoded <code>address</code> in the <code>$install_path/.stcd/config/priv_validator.json</code> file.</p> <p>\u26a0\ufe0f NOTE To enter the validator set, you need to have more total voting power than the 100th validator.</p>"},{"location":"gateway/run/#stop-your-validator","title":"Stop your validator","text":"<p>Having your validators stop systematically and gracefully is useful when trying to perform routine maintenance or plan for an upcoming coordinated upgrade.</p> <p>You can do this by setting <code>halt-height</code> to the height you want the node to be closed at or by passing the <code>--halt-height</code> flag to <code>stcd</code>.</p> <p>After committing a block, the node will shut down with a zero exit code at the given height.</p>"},{"location":"gateway/run/#common-problem","title":"common problem","text":""},{"location":"gateway/run/#problem-1-my-validator-is-voting_power-0","title":"Problem #1: My validator is <code>voting_power: 0</code>","text":"<p>Your validator is in jail. If a validator does not vote for <code>500</code> out of the last <code>10000</code> blocks, or if they double-sign, the validator will be jailed, i.e. removed from the set of active validators.</p> <p>If you go to jail for downtime, you can give your voting power back to your validators. First, restart <code>stcd</code> if it is not running:</p> <pre><code>stcd daemon\n</code></pre> <p>Wait for your full nodes to catch up with the latest blocks. You can then unjail your validator Finally, check your validator again to see if your voting power is restored.</p> <pre><code>stcd status\n</code></pre> <p>You may notice that your voting rights are less than before. That's because you got cut for downtime!</p>"},{"location":"gateway/run/#problem-2-my-node-crashes-with-too-many-open-files","title":"Problem #2: My node crashes with <code>too many open files</code>","text":"<p>The default number of files (per process) that Linux can open is <code>1024</code>. <code>stcd</code> is known to open more than <code>1024</code> files. This causes the process to crash. A quick fix is to run <code>ulimit -n 40960</code> (increase the number of open files allowed), then restart the process with the <code>stcd daemon</code>. If you use <code>systemd</code> or another process manager to start <code>stcd</code>, this may require some configuration at that level. An example <code>systemd</code> file to fix this is as follows:</p> <pre><code># /etc/systemd/system/stcd.service\n[Unit]\nDescription=Daodst Chain Node\nAfter=network.target\n\n[Service]\nType=simple\nUser=ubuntu\nWorkingDirectory=/home/ubuntu\nExecStart=/home/ubuntu/go/bin/stcd start\nRestart=on-failure\nRestartSec=3\nLimitNOFILE=4096\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"gateway/safe-node/","title":"Sentinel Nodes","text":""},{"location":"gateway/safe-node/#set-sentry-nodes","title":"Set Sentry Nodes","text":"<p>When setting up a validator, there are countless ways to configure your settings. This guide aims to showcase one of them, namely the design of Sentry Nodes. This design is mainly designed to prevent DDOS</p>"},{"location":"gateway/safe-node/#network-layout","title":"Network layout","text":"<p>This image is based on AWS, and other cloud providers will also have similar solutions to design. Running nodes is not limited to cloud providers, but you can also run nodes on bare metal systems. Regardless of which setting you decide to adopt, the architecture will be the same.</p> <p>The proposed network diagram is similar to the classic separation of backend/front-end services in enterprise environments. In this case, the 'backend' is the dedicated network of validators in the data center. The data center network may involve multiple subnets, firewalls, and redundant devices, which are not detailed in this figure. An important point is that the data center allows direct connection to the selected cloud environment. Amazon AWS has' Direct Connect ', while Google Cloud has' Partner Interconnect'. This is a dedicated connection with a cloud provider (usually directly connected to a virtual private cloud instance in a certain region).</p> <p>All sentinel nodes (\"front-end\") are connected to the validator using this private connection. The verifier does not have a public IP address to provide the service.</p> <p>Amazon has multiple available zones within a region. Sentry nodes can also be installed in other regions. In this case, the second, third, and more regions need to have private connections to the validator node. This can be achieved through VPC peer-to-peer interconnection (referred to as \"VPC network peer-to-peer interconnection\" in Google Cloud). In this case, the second, third, and more region sentinel nodes will be directed to the first region and connected directly to the data center to reach the validator.</p> <p>A more durable solution (not detailed in the figure) is multiple direct connections from the data center to different regions. In this way, VPC peer-to-peer connection is not mandatory, but it still benefits sentinel nodes. This overcomes the risk of relying on one region. It has a higher cost.</p>"},{"location":"gateway/safe-node/#local-configuration","title":"Local configuration","text":"<p>The validator will only communicate with the provided sentinel, and the sentinel node will communicate with the validator through a secret connection and communicate with the rest of the network through a normal connection. Sentry nodes can also choose to communicate with each other. When 'config. toml' initializes a node, five parameters may need to be changed.</p> <ul> <li><code>pex:</code> Boolean value. This will turn on or off the peer to peer network information exchange for the node. When 'pex=false', only 'persistent'_ The 'peers' list can be used to connect</li> <li><code>persistent_peers:</code> Comma separated` nodeID@ip A list of port values that define a list of peers expected to always be online. This is necessary during the first startup because by setting 'pex=false' nodes, they will not be able to join the network</li> <li><code>unconditional_peer_ids:</code> Comma separated list of node IDs. Regardless of the limitations of inbound and outbound peers, these nodes will connect to. This is very useful when sentinel nodes have a complete address book.</li> <li><code>private_peer_ids:</code> Comma separated list of node IDs. These nodes will not be propagated to the network. This is an important field because you do not want your validator IP to be propagated to the network.</li> <li><code>addr_book_strict:</code> Boolean value. By default, nodes with routable addresses will be considered for connection. If this setting is turned off (false), non routable IP addresses (such as those in private networks) can be added to the address book.</li> <li><code>double_sign_check_height</code> int64 Height. How many memory blocks should be reviewed to check the existence of node consensus voting before joining the consensus. When non zero, if the same consensus key is used to sign the last memory block of {double_sign_check_height}, the node will panic upon reboot. Therefore, the validator should stop the state machine, wait for some blocks, and then restart the state machine to avoid panic.</li> </ul>"},{"location":"gateway/safe-node/#verifier-node-configuration","title":"Verifier node configuration","text":"configuration option setting pex false persistent_peers Sentry Node List private_peer_ids none unconditional_peer_ids Optional Sentinel Node ID addr_book_strict false double_sign_check_height 10 <p>The validator node should have the characteristic of 'pex=false' so that it does not spread gossip to the entire network. The persistent peer will be your Sentinel node. Private nodes can be left blank because the validator does not attempt to hide who is communicating with. For validators, setting unconditional peers is optional as they do not have a complete address book.</p>"},{"location":"gateway/safe-node/#sentry-node-configuration","title":"Sentry Node Configuration","text":"configuration option setting pex true persistent_peers Verifier node, optional other Sentry nodes private_peer_ids Verifier Node ID unconditional_peer_ids Verifier node, optional other Sentry nodes addr_book_strict false <p>Sentry nodes should be able to communicate with the entire network, which is why 'pex=true'. The persistent peer of the Sentinel node will be the validator, and it can also be other Sentinel nodes. Sentry nodes should ensure that they do not propagate the validator's IP, so you must set the validator's nodeID as a private peer. The unconditional peer ID will be the verifier ID and optional other sentinel nodes.</p> <p>Note: Do not forget to protect the firewall of the node when setting it</p>"},{"location":"gateway/safe-node/#obtain-node-nodeid","title":"Obtain node nodeid","text":"<p>First, enter the directory where the stcd command is located, and then run the following command to obtain the NodeId</p> <pre><code>./stcd tendermint show-node-id\n</code></pre> <p>Nodeid is a string of length 40, for example:</p> <pre><code>b86863115efa5ded87ec36d0ad287aaee050e4d2\n</code></pre> <p>The default communication port of the node is 26656. If the current node IP is 8.8.8.8, the final address combination of the node should be as follows:</p> <pre><code>b86863115efa5ded87ec36d0ad287aaee050e4d2@8.8.8.8:26656\n</code></pre> <p>More information can be found in the following link:</p> <ul> <li>https://kb.certus.one/</li> <li>https://forum.cosmos.network/t/sentry-node-architecture-overview/454</li> </ul>"},{"location":"gateway/security/","title":"Authenticator security checklist","text":"<p>Find below a security checklist survey for validator security measurements. Investigate managed data center and node setups and compare your results to the recommended best practices below.</p>"},{"location":"gateway/security/#general-controls-for-hosting-data-centers","title":"General controls for hosting data centers","text":"Control Classes Best Practice Notes Data Center Redundant Power Supply Data Center Redundant Cooling Data Center Redundant Network Data Center Physical Cage / Gated Access Data Center Remote Alarm Security Cameras"},{"location":"gateway/security/#node-settings","title":"node settings","text":"Control Classes Best Practice Notes General System Security Operating system is properly patched. The kernel is updated to the latest stable version. The node must run in x86_64 environment General System Security Automatic updates of the operating system are configured. Toolkits exist for automatic upgrades (e.g. auter, yum-cron, dnf-automatic, unattended-upgrades) General System Security Enables and enforces the security framework. SELinux / AppArmor / Tomoyo / Grsecurity enabled. General System Security No unsafe and unnecessary services installed. (e.g. telnet, rsh, inetd, etc... General System Security GRUB boot loader password configured. Grub2 configuration password General system security Root access to core system files only File directory security Make sure the directory \"~/.stcd\" is only accessible to the owner Binary Configuration The following settings in config.toml are recommended for performance and security - for sentry nodes: <code>max_num_inbound_peers = 500, max_num_outbound_peers = 50, flush_throttle_timeout = \"300ms\"</code> - for validator nodes : <code>max_num_inbound_peers = 100 , max_num_outbound_peers = 10, flush_throttle_timeout = \"100ms\"</code> Account Security and Remote Access The following password policies are enforced: no blank passwords; weak passwords are not allowed Account Security and Remote Access Enable the following SSH configurations: PermitRootLogin: <code>no</code>; PasswordAuthentication <code>no</code>; ChallengeResponseAuthentication <code>no</code>; Use PAM <code>yes</code>; AllowUsers <code>only necessary users</code>; AllowGroups <code>only necessary groups</code>. Networking Use speedtest for network throughput testing. A minimum upload speed of 5 Mbps and a download speed of at least 5 Mbps is recommended) Networking Enable host-based (such as iptables) or cloud-based (such as AWS Security Groups) firewalls to protect all relevant nodes. Remote management ports (eg SSH - TCP 22) should only be exposed to selected IPs and not the Internet. Overly permissive rules should not be set (for example, a broad port range of 1-65535 is allowed). For internal communication channels between nodes, they should be set with specific source and destination addresses. For Internet reachable nodes, set TCP 26656 as the only incoming port if possible. Networking Installing and implementing an intrusion detection/prevention system (e.g. Fail2Ban, Snort, OSSEC) Networking Set up a sentinel architecture to protect validators and firewall rules to limit direct internet access to them. Networking Remote Procedure Calls (RPC) provide sensitive operations and information that should not be exposed on the Internet. By default, RPC is turned on and only connections from <code>127.0.0.1</code> are allowed. Be extra careful if you need to allow RPCs from other IP addresses. Redundancy The hot standby node sets the same configuration as the primary node Redundancy Set up system monitoring and alerts to alert owners of anomalies"},{"location":"gateway/state-sync/","title":"state synchronization","text":"<p>Learn about Tendermint Core state synchronization and support provided by the Cosmos SDK.</p> <p>\ud83d\udce3 Tip: Just concerned about how to sync nodes with the network? Skip to this section.</p>"},{"location":"gateway/state-sync/#tendermint-core-state-synchronization","title":"Tendermint core state synchronization","text":"<p>State synchronization allows new nodes to join the network by taking a snapshot of the most recent state of the network, rather than fetching and replaying all historical blocks. Since the application state is smaller than all blocks combined, and restoring state is faster than replaying blocks, this reduces the time to sync with the network from days to minutes.</p> <p>This part of the document provides a brief overview of the Tendermint state synchronization protocol, and how nodes are synchronized. For more details, see the ABCI Application Guide and the ABCI Reference Documentation.</p>"},{"location":"gateway/state-sync/#state-synchronization-snapshot","title":"State synchronization snapshot","text":"<p>A guiding principle when designing Tendermint state synchronization is to provide as much flexibility as possible for applications. Therefore, Tendermint doesn't care what the snapshots contain, how they were taken or how they were restored. It is only concerned with discovering existing snapshots in the network, fetching them and passing them to the application via ABCI.</p> <p>Tendermint uses light client validation to check the final application hash of the restored application against the chain application hash, but any further validation must be done by the application itself during recovery.</p> <p>Snapshots consist of binary blocks of arbitrary format. Chunks cannot be larger than 16 MB, otherwise there is no limit. Snapshot Metadata, exchanged via ABCI and P2P, contains the following fields:</p> <ul> <li><code>height</code> (<code>uint64</code>): The height at which the snapshot was taken</li> <li><code>format</code> (<code>uint32</code>): Arbitrary application-specific format identifier (e.g. version)</li> <li><code>chunks</code> (<code>uint32</code>): number of binary chunks in the snapshot</li> <li><code>hash</code> (<code>bytes</code>): Arbitrary snapshot hash for comparing snapshots across nodes</li> <li><code>metadata</code> (<code>bytes</code>): Arbitrary binary snapshot metadata for use by the application</li> </ul> <p>The <code>format</code> field allows an application to change its snapshot format in a backwards-compatible manner by providing snapshots in multiple formats and choosing which formats to accept during restore.</p> <p>This is useful, for example, when changing the serialization or compression format: as a node may be able to provide a snapshot to a node running an older version, or use an old snapshot when starting with a newer version.</p> <p>The <code>hash</code> field contains an arbitrary snapshot hash. Snapshots with the same <code>metadata</code> fields (including <code>hash</code>) across nodes are considered to be the same, and <code>chunks</code> will be fetched from any of those nodes.</p> <p>The <code>hash</code> is trustless and not verified by Tendermint itself, which prevents unintentional non-determinism in snapshot generation.</p> <p><code>hash</code> can be verified by the application instead.</p> <p>The <code>metadata</code> field can contain any arbitrary metadata required by the application. For example, applications may wish to include block checksums to discard corrupt <code>chunks</code>, or Merkle proofs validates each block individually against the chain application hash. Snapshot <code>metadata</code> messages cannot exceed 4 MB in Protobuf encoded form.</p>"},{"location":"gateway/state-sync/#take-and-provide-snapshots","title":"Take and provide snapshots","text":"<p>To enable state synchronization, certain nodes in the network must take and provide snapshots. When a peer attempts a state sync, an existing Tendermint node will call the following ABCI method on the application to provide snapshot data to the peer:</p> <ul> <li><code>ListSnapshots</code>: Returns a list of available snapshots, along with metadata</li> <li><code>LoadSnapshotChunk</code>: returns binary chunk data</li> </ul> <p>Snapshots should generally be generated periodically, rather than on-demand: this improves state synchronization performance, since snapshot generation can be slow, and avoids a denial-of-service vector for attackers flooding nodes with such requests.</p> <p>Older snapshots can usually be deleted, but it may be useful to keep at least the two most recent snapshots to avoid deleting previous snapshots when the node recovers.</p> <p>It is entirely up to the application to decide how to take a snapshot, but it should strive to meet the following guarantees:</p> <ul> <li>async: Snapshot should not stop block processing, so it should happen asynchronously, eg. in a separate thread</li> <li>consistent: snapshots should be taken at isolated heights and should not be affected by concurrent writes, eg. Due to the block processing in the main thread</li> <li>Deterministic: For a given <code>height</code> and <code>format</code>, snapshot <code>chunks</code> and <code>metadata</code> should be the same (at byte level) for all nodes to ensure good availability of <code>chunks</code></li> </ul> <p>For example, this can be achieved as follows:</p> <ol> <li>Use a data store that supports transactions with snapshot isolation, such as RocksDB or BadgerDB.</li> <li>Start a read-only database transaction in the main thread after the block is committed.</li> <li>Pass the database transaction handle to the newly spawned thread.</li> <li>Iterate over all data items in a definite order (for example, sort by key)</li> <li>Serialize the data items (e.g. using Protobuf) and write them to a byte stream.</li> <li>Hash the byte stream and split it into fixed size chunks (say 10 MB)</li> <li>Store the chunks as separate files in the file system.</li> <li>Write snapshot metadata to database or file, including byte stream hash.</li> <li>Close the database transaction and exit the thread.</li> </ol> <p>Applications may also need to take additional steps, such as compressing data, validating blocks, generating proofs for incremental verification, and deleting old snapshots.</p>"},{"location":"gateway/state-sync/#restore-snapshot","title":"restore snapshot","text":"<p>When Tendermint starts, it checks to see if the local node has any state (i.e. whether <code>LastBlockHeight == 0</code>), and if not, it will start discovering snapshots over the P2P network. These snapshots will be made available to native applications via the following ABCI calls:</p> <ul> <li><code>OfferSnapshot(snapshot, apphash)</code>: Offer a discovered snapshot to the application</li> <li><code>ApplySnapshotChunk(index, chunk, sender)</code>: apply snapshot chunk</li> </ul> <p>The discovered snapshot is provided to the application, which can respond by accepting the snapshot, rejecting the snapshot, rejecting the format, rejecting the sender, aborting the state synchronization, etc.</p> <p>Once the snapshot is accepted, Tendermint will fetch blocks from available peers and apply them in order to the application, which can choose to accept blocks, refetch, reject snapshot, reject sender, abort state sync, etc.</p> <p>After all blocks are applied, Tendermint will call the <code>Info</code> ABCI method on the application and check the application hash and The height corresponds to the trusted value in the chain. It will then switch to fast sync for any remaining blocks (if enabled), before finally joining normal consensus operations.</p> <p>How snapshots are actually restored is entirely up to the application, but usually the opposite of how they were generated.</p> <p>Note, however, that Tendermint only verifies snapshots after all blocks have been restored, and will not reject any P2P peers on its own.</p> <p>As long as the trusted hash and application code are correct, it is impossible for an adversary to cause a state-sync node to have an incorrect state when joining consensus, but applications can counteract state-sync denial of service (e.g., by implementing incremental verification, denying invalid node).</p> <p>Note that state sync nodes will have a truncated block history from the height of the restored snapshot, there is currently no backfill of all block data. Networks should consider the wider implications and may wish to ensure that at least a few archiving nodes maintain full block history for auditability and backup purposes.</p>"},{"location":"gateway/state-sync/#cosmos-sdk-state-synchronization","title":"Cosmos SDK state synchronization","text":"<p>Cosmos SDK v0.40+ includes automatic support for state synchronization, so app developers just need to enable it to use. They will not need to implement the state sync protocol described in the above section on Tendermint themselves.</p>"},{"location":"gateway/state-sync/#state-synchronization-snapshot_1","title":"State synchronization snapshot","text":"<p>Tendermint Core handles most of the heavy lifting of discovering, exchanging, and validating state data for state synchronization, but applications must periodically take snapshots of their state, provide these snapshots to Tendermint via ABCI calls, and be able to resume these synchronizations when new nodes are created.</p> <p>The Cosmos SDK stores application state in a data store called IAVL, and each module can set its own IAVL store. At a fixed height interval (configurable), the Cosmos SDK will export the content of each store at that height, Protobuf-encode and compress it , and save it to the snapshot store on the local file system. Since IAVL preserves historical versions of the data, these snapshots can be generated concurrently with the execution of new blocks.</p> <p>Tendermint will fetch these snapshots via ABCI when a new node does a state sync.</p> <p>Note that only IAVL storage managed by the Cosmos SDK can be snapshotted. If an app stores additional data in an external data store, there is currently no mechanism to include these in the state sync snapshot, so apps cannot use automatic state sync via the SDK.</p> <p>However, as described in the ABCI documentation, one is free to implement the state-sync protocol itself.</p> <p>When a new node state syncs, Tendermint will take a snapshot from the peers in the network and serve it to the local (empty) application, which will import it into its IAVL storage.</p> <p>Tendermint then verifies the app's application hash against the main blockchain using a light client validation and proceeds to execute blocks as usual.</p> <p>Note that a state sync node will only restore the application state at the snapshot height and will not include historical data or historical blocks.</p>"},{"location":"gateway/state-sync/#enable-state-sync-snapshot","title":"Enable state sync snapshot","text":"<p>To enable state sync snapshots, an application using the CosmosSDK <code>BaseApp</code> needs to set up a snapshot store (with a database and a filesystem directory) and configure the snapshot interval and the number of historical snapshots to keep. A minimal example is as follows:</p> <pre><code>snapshotDir := filepath.Join(\n  cast.ToString(appOpts.Get(flags.FlagHome)), \"data\", \"snapshots\")\nsnapshotDB, err := sdk.NewLevelDB(\"metadata\", snapshotDir)\nif err != nil {\n  panic(err)\n}\nsnapshotStore, err := snapshots.NewStore(snapshotDB, snapshotDir)\nif err != nil {\n  panic(err)\n}\napp := baseapp.NewBaseApp(\n  \"app\", logger, db, txDecoder,\n  baseapp.SetSnapshotStore(snapshotStore),\n  baseapp.SetSnapshotInterval(cast.ToUint64(appOpts.Get(\n    server.FlagStateSyncSnapshotInterval))),\n  baseapp.SetSnapshotKeepRecent(cast.ToUint32(appOpts.Get(\n    server.FlagStateSyncSnapshotKeepRecent))),\n)\n</code></pre> <p>When the application is started with the appropriate flags, (e.g. <code>--state-sync.snapshot-interval 1000 --state-sync.snapshot-keep-recent 2</code>) it should take a snapshot and output a log message:</p> <pre><code>Creating state snapshot module=main height=3000\nCompleted state snapshot module=main height=3000 format=1\n</code></pre> <p>Note that the snapshot interval must currently be a multiple of <code>pruning-keep-every</code> (default 100) to prevent height clipping when snapshots are taken. It's also usually a good idea to keep at least the 2 most recent snapshots, so that when a node tries to use it for state synchronization, previous snapshots are not deleted.</p>"},{"location":"gateway/state-sync/#state-synchronization-node","title":"State synchronization node","text":"<p>\ud83d\udce3 Tip: Looking for a snapshot or archive node to sync your nodes? Check out this page.</p> <p>Once several nodes in the network have taken state sync snapshots, new nodes can join the network using state sync. To do this, the node should first be configured as usual, and the following information must be obtained for light client authentication:</p> <ul> <li>Two available RPC servers (at least)</li> <li>Confidence height</li> <li>Block ID hash with confidence height</li> </ul> <p>A trusted hash must be obtained from a trusted source (such as a block explorer), but the RPC server does not need to be trusted. Tendermint will use the hash to get the trusted application hash from the blockchain to verify the restored application snapshot. The application hash and corresponding height are the only information that can be trusted when restoring a snapshot. Everything else can be faked by an opponent.</p> <p>In this guide we use Ubuntu 20.04</p>"},{"location":"gateway/state-sync/#prepare-the-system","title":"Prepare the system","text":"<p>update system</p> <pre><code>sudo apt update -y\n</code></pre> <p>Upgrading the system</p> <pre><code>sudo apt upgrade -y\n</code></pre> <p>install dependencies</p> <pre><code>sudo apt-get install ca-certificates curl gnupg lsb-release make gcc git jq wget -y\n</code></pre> <p>Install Go</p> <pre><code>wget -q -O - https://raw.githubusercontent.com/canha/golang-tools-install-script/master/goinstall.sh | bash\nsource ~/.bashrc\n</code></pre> <p>set node name</p> <pre><code>moniker=\"NODE_NAME\"\n</code></pre>"},{"location":"gateway/state-sync/#use-the-following-commands-for-mainnet-settings","title":"Use the following commands for mainnet settings","text":"<pre><code>SNAP_RPC1=\"http://xxx1:26657\"\nSNAP_RPC=\"http://xxx:26657\"\nCHAIN_ID=\"daodst_7777-1\"\nPEER=\"96557e26aabf3b23e8ff5282d03196892a7776fc@xxx,dec587d55ff38827ebc6312cedda6085c59683b6@xxx\"\nwget -O $HOME/genesis.json https://raw.githubusercontent.com/daodst/mainnet/genesis.json\n</code></pre>"},{"location":"gateway/state-sync/#install-stcd","title":"Install stcd","text":"<pre><code>git clone https://github.com/daodst/blockchain.git &amp;&amp; \\\ncd cmd &amp;&amp; cd stcd\ngo build\n</code></pre>"},{"location":"gateway/state-sync/#configuration","title":"configuration","text":"<p>node initialization</p> <pre><code>stcd init $moniker --chain-id $CHAIN_ID\n</code></pre> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>Move the genesis file to the $install_path/.stcd/config folder</p> <pre><code>mv $HOME/genesis.json $install_path/.stcd/config/\n</code></pre> <p>reset node</p> <pre><code>stcd tendermint unsafe-reset-all --home .stcd\n</code></pre> <p>Change config file (set node name, add persistent peer, set indexer=\"null\")</p> <pre><code>sed -i -e \"s%^moniker *=.*%moniker = \\\"$moniker\\\"%; \" $install_path/.stcd/config/config.toml\nsed -i -e \"s%^indexer *=.*%indexer = \\\"null\\\"%; \" $install_path/.stcd/config/config.toml\nsed -i -e \"s%^persistent_peers *=.*%persistent_peers = \\\"$PEER\\\"%; \" $install_path/.stcd/config/config.toml\n</code></pre> <p>Set variables starting from snapshot</p> <pre><code>LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\\nBLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\\nTRUST_HASH=$(curl -s \"$SNAP_RPC/block?height=$BLOCK_HEIGHT\" | jq -r .result.block_id.hash)\n</code></pre> <p>examine</p> <pre><code>echo $LATEST_HEIGHT $BLOCK_HEIGHT $TRUST_HASH\n</code></pre> <p>Example output (numbers will vary):</p> <pre><code>376080 374080 F0C78FD4AE4DB5E76A298206AE3C602FF30668C521D753BB7C435771AEA47189\n</code></pre> <p>If the output is normal, the next step</p> <pre><code>sed -i.bak -E \"s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\\n\ns|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\\"$SNAP_RPC,$SNAP_RPC1\\\"| ; \\\n\ns|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\\n\ns|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\\"$TRUST_HASH\\\"| ; \\\n\ns|^(seeds[[:space:]]+=[[:space:]]+).*$|\\1\\\"\\\"|\" $install_path/.stcd/config/config.toml\n</code></pre>"},{"location":"gateway/state-sync/#create-stcd-service","title":"Create stcd service","text":"<pre><code>echo \"[Unit]\nDescription=Daodst Chain Node\nAfter=network.target\n#\n[Service]\nUser=$USER\nType=simple\nExecStart=$(which stcd) daemon\nRestart=on-failure\nLimitNOFILE=65535\n#\n[Install]\nWantedBy=multi-user.target\" &gt; $HOME/stcd.service; sudo mv $HOME/stcd.service /etc/systemd/system/\n</code></pre> <pre><code>sudo systemctl enable stcd.service &amp;&amp; sudo systemctl daemon-reload\n</code></pre>"},{"location":"gateway/state-sync/#run-stcd","title":"Run stcd","text":"<pre><code>sytemctl start stcd\n</code></pre>"},{"location":"gateway/state-sync/#check-logs","title":"Check logs","text":"<pre><code>journalctl -u stcd -f\n</code></pre> <p>When a node starts up, it will try to find a state sync snapshot in the network, and restore it:</p> <pre><code>Started node module=main nodeInfo=\"...\"\nDiscovering snapshots for 20s\nDiscovered new snapshot height=3000 format=1 hash=0F14A473\nDiscovered new snapshot height=2000 format=1 hash=C6209AF7\nOffering snapshot to ABCI app height=3000 format=1 hash=0F14A473\nSnapshot accepted, restoring height=3000 format=1 hash=0F14A473\nFetching snapshot chunk height=3000 format=1 chunk=0 total=3\nFetching snapshot chunk height=3000 format=1 chunk=1 total=3\nFetching snapshot chunk height=3000 format=1 chunk=2 total=3\nApplied snapshot chunk height=3000 format=1 chunk=0 total=3\nApplied snapshot chunk height=3000 format=1 chunk=1 total=3\nApplied snapshot chunk height=3000 format=1 chunk=2 total=3\nVerified ABCI app height=3000 appHash=F7D66BC9\nSnapshot restored height=3000 format=1 hash=0F14A473\nExecuted block height=3001 validTxs=16 invalidTxs=0\nCommitted state height=3001 txs=16 appHash=0FDBB0D5F\nExecuted block height=3002 validTxs=25 invalidTxs=0\nCommitted state height=3002 txs=25 appHash=40D12E4B3\n</code></pre> <p>Nodes are now in sync and join the network within seconds</p>"},{"location":"gateway/state-sync/#turn-off-state-synchronization-mode","title":"Turn off state synchronization mode","text":"<p>After the node is fully synced, use this command to turn off state sync mode to avoid problems with future node restarts!</p> <pre><code>sed -i.bak -E \"s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1false|\" $install_path/.stcd/config/config.toml\n</code></pre> <p>\u26a0\ufe0f NOTE: The information contained in this document comes from Erik Grinaker, in particular his state synchronization guide Tendermint Core and the Cosmos SDK.</p>"},{"location":"gateway/testnet/","title":"testnet","text":"<p>This document outlines the steps to join an existing testnet.</p>"},{"location":"gateway/testnet/#select-a-testnet","title":"Select a testnet","text":"<p>You can specify the network to join by setting genesis file and seed node. </p> Testnet Chain ID Description Location Version Status <code>daodst_7000-1</code> daodst Testnet Arsia Mons <code>v0.1.x</code> <code>active</code>"},{"location":"gateway/testnet/#install-stcd","title":"Install <code>stcd</code>","text":"<p>Follow the installation documentation to install program.</p> <p>\u26a0\ufe0f Note : Make sure you have the correct version of Program installed.</p>"},{"location":"gateway/testnet/#save-chain-id","title":"Save Chain ID","text":"<p>We recommend saving the testnet <code>chain-id</code> to your <code>client.toml</code>. This will save you from having to manually pass the <code>chain-id</code> flag for every CLI command.</p> <p>\ud83d\udce3 Tips: See the official chain IDs for reference.</p> <pre><code>stcd config chain-id daodst_7000-1\n</code></pre>"},{"location":"gateway/testnet/#initialize-node","title":"Initialize node","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>We need to initialize the node to create all necessary validators and node configuration files:</p> <pre><code>stcd init &lt;your_custom_moniker&gt; --chain-id daodst_7000-4\n</code></pre> <p>\u26a0\ufe0f Note : A moniker can only contain ASCII characters. Using Unicode characters will make your node inaccessible.</p> <p>By default, the <code>init</code> command creates the <code>$install_path/.stcd</code> (ie <code>$HOME</code>) directory with subfolders <code>config/</code> and <code>data/</code>. In the <code>config</code> directory, the most important configuration files are <code>app.toml</code> and <code>config.toml</code>.</p>"},{"location":"gateway/testnet/#genesis-seeds","title":"Genesis &amp; Seeds","text":""},{"location":"gateway/testnet/#copy-the-genesis-file","title":"Copy the genesis file","text":"<p>Download the <code>genesis.json</code> file from <code>github</code> and copy it to the <code>config</code> directory: <code>$install_path/.stcd/config/genesis.json</code>. This is a genesis file that contains the chain ID and the balance of the genesis account.</p> <pre><code>sudo apt install -y unzip wget\nwget -P $install_path/.stcd/config https://github.com/daodst/testnets/daodst_7000-1/genesis.json\n</code></pre> <p>Then verify the correctness of the genesis configuration file:</p> <pre><code>stcd validate-genesis\n</code></pre>"},{"location":"gateway/testnet/#seeds","title":"seeds","text":"<p>Your peers need to know how to find peers. You need to add a healthy seed node to <code>$HOME/.stcd/config/config.toml</code> . The <code>testnets</code> repository contains pointers to some seed nodes.</p> <p>Edit the files located in <code>$install_path/.stcd/config/config.toml</code> and <code>seeds</code> to the following:</p> <pre><code>#################################################### #####\n### P2P Configuration Options ###\n#################################################### #####\n[p2p]\n\n#...\n\n# Comma separated list of seed nodes to connect to\nseeds = \"&lt;node-id&gt;@&lt;ip&gt;:&lt;p2p port&gt;\"\n</code></pre> <p>You can fetch a seed from the repository and add it to your config with the following code:</p> <pre><code>SEEDS=`curl -sL https://raw.githubusercontent.com/daodst/testnets/main/daodst_7000-1/seeds.txt | awk '{print $1}' | paste -s -d, -`\nsed -i.bak -e \"s/^seeds =.*/seeds = \\\"$SEEDS\\\"/\" ~/.stcd/config/config.toml\n</code></pre> <p>\ud83d\udce3 Tips: For more information on torrents and peers, you can visit the Tendermint P2P Documentation.</p>"},{"location":"gateway/testnet/#persistent_peers","title":"persistent_peers","text":"<p>We can set [<code>persistent_peers</code>] in <code>$install_path/.stcd/config/config.toml</code>(https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#persistent- peer) field. to specify the peers with which your node will maintain persistent connections. You can retrieve them from the list of available peers in the <code>testnets</code> repository.</p> <p>You can get 10 random entries from <code>peers.txt</code> by adding the file to the <code>PEERS</code> variable by running:</p> <pre><code>PEERS=`curl -sL https://raw.githubusercontent.com/daodst/testnets/main/daodst_7000-1/peers.txt | sort -R | head -n 10 | awk '{print $1}' | paste -s -d, -`\n</code></pre> <p>Use <code>sed</code> to include them into the configuration. You can also add them manually:</p> <pre><code>sed -i.bak -e \"s/^persistent_peers *=.*/persistent_peers = \\\"$PEERS\\\"/\" $install_path/.stcd/config/config.toml\n</code></pre>"},{"location":"gateway/testnet/#run-the-testnet-validator","title":"Run the testnet validator","text":"<p>Declare your testnet on faucet using your validator account address and submit your validator account address:</p> <p>\ud83d\udce3 Tips: For more details on how to run the validator, please follow these instructions.</p> <pre><code>stcd tx staking create-validator \\\n   --amount=1000000000000dst \\\n   --pubkey=$(stcd tendermint show-validator) \\\n   --moniker=\"Daodst1\" \\\n   --chain-id=&lt;chain_id&gt; \\\n   --commission-rate=\"0.10\" \\\n   --commission-max-rate=\"0.20\" \\\n   --commission-max-change-rate=\"0.01\" \\\n   --min-self-delegation=\"1000000\" \\\n   --gas=\"auto\" \\\n   --gas-prices=\"0.025dst\" \\\n   --from=&lt;key_name&gt;\n</code></pre>"},{"location":"gateway/testnet/#start-the-testnet","title":"Start the testnet","text":"<p>The last step is to start the node. Once enough voting power (+2/3) from genesis validators is up and running, the testnet will start producing blocks.</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"gateway/testnet/#upgrade-your-node","title":"Upgrade your node","text":"<p>\ud83d\udce3 Tip : These instructions are for full nodes who are already running on a previous version and want to upgrade to the latest testnet version.</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p>"},{"location":"gateway/testnet/#reset-data","title":"Reset Data","text":"<p>\u26a0\ufe0f Note : If the version  you are upgrading to does not conflict with the previous version, you should not reset the data. If this is the case, you can skip to Restart <p>First, delete obsolete files and reset data.</p> <pre><code>rm $install_path/.stcd/config/addrbook.json $install_path/.stcd/config/genesis.json\nstcd tendermint unsafe-reset-all --home $install_path/.stcd\n</code></pre> <p>Your node is now in pristine state, while keeping the original <code>priv_validator.json</code> and <code>config.toml</code>. If you previously set up any sentinel nodes or full nodes, your nodes will still attempt to connect to them, but may fail if they have not been upgraded.</p> <p>\u26a0\ufe0f Note : Make sure each node has a unique <code>priv_validator.json</code>. Do not copy <code>priv_validator.json</code> from old nodes to multiple new nodes. Running two nodes with the same <code>priv_validator.json</code> will cause you to double sign.</p>"},{"location":"gateway/testnet/#restart","title":"restart","text":"<p>To restart your node, just type:</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"gateway/testnet/#share-your-node-information","title":"Share your node information","text":"<p>You can share your companions on the Internet and publish them.</p> <p>\ud83d\udce3 Tips: To get your node ID, use</p> <pre><code>stcd tendermint show-node-id\n</code></pre>"},{"location":"gateway/testnet/#state-synchronization-node","title":"State synchronization node","text":"<p>If you want to join the network using state-sync (fast, but not for archive nodes), check out our state-sync page</p>"},{"location":"protocol/account/","title":"account","text":"<p>Crypto wallets (or accounts) can be created and represented in unique ways on different blockchains. For developers interacting with account types on Daodst, during wallet integration on their dApp frontend, it is important to understand that accounts on Daodst are implemented to be compatible with Ethereum type addresses.</p>"},{"location":"protocol/account/#create-an-account","title":"Create an account","text":"<p>To create an account, you create a private key, a keystore file (a password-protected private key), or a seed phrase (a string of words that gives access to multiple private keys).</p> <p>Besides having different security features, the biggest difference between them is that the private key or keystore file only creates an account. Creating a seed phrase can give you control over many accounts, all of which can be accessed using the same phrase.</p> <p>The Cosmos blockchain, like Daodst, supports account creation using mnemonic phrases, also known as Hierarchical Deterministic Key Generation (HD Keys). This allows users to create accounts on multiple blockchains without having to manage multiple keys.</p> <p>HD keys generate addresses by taking a mnemonic phrase and combining it with a piece of information called a derivation path. Blockchains can differ in the derivation paths they support. Therefore, to access all accounts via a mnemonic phrase on a blockchain, it is important to use a specific derivation path for that blockchain.</p>"},{"location":"protocol/account/#proxy-account","title":"Proxy account","text":"<p>The terms 'account' and 'address' are often used interchangeably to describe crypto wallets. In the Cosmos SDK, an account specifies a pair of public key (PubKey) and private key (PrivKey). Derivation paths define private keys, public keys, and addresses.</p> <p>A PubKey can be derived to generate various addresses in different formats, which are used to identify users (among other parties) within the application. A common address form for Cosmos chains is the bech32 format (eg dst1 ...). Addresses are also associated with messages to identify the sender of the message.</p> <p>A PrivKey is used to generate a digital signature attesting that the address associated with the PrivKey approves a given message. Attestation is performed by applying a cryptographic scheme called the Elliptic Curve Digital Signature Algorithm (ECDSA) to the PrivKey to generate a public key that is compared to the address in the message.</p>"},{"location":"protocol/account/#daodst-account","title":"Daodst Account","text":"<p>Daodst defines its own custom account type to implement HD wallet compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve as the key (eth_secp265k1) and satisfies the full BIP44 path of EIP84. Do not confuse this cryptographic curve with Bitcoin's ECDSA secp256k1 curve.</p> <p>The root HD path for Daodst based accounts is <code>m/44'/60'/0'/0</code>. Daodst uses Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains which use Coin type 118 (list of coin types</p> <p>The custom Daodst EthAccount satisfies the AccountI interface from the Cosmos SDK authentication module and contains additional fields required for Ethereum type addresses:</p> <pre><code>// EthAccountI represents the interface of an Daodst compatible account\ntype EthAccountI interface {\n    authtypes.AccountI\n    // EthAddress returns the ethereum Address representation of the AccAddress\n    EthAddress() common.Address\n    // CodeHash is the keccak256 hash of the contract code (if any)\n    GetCodeHash() common.Hash\n    // SetCodeHash sets the code hash to the account fields\n    SetCodeHash(code common.Hash) error\n    // Type returns the type of Ethereum Account (EOA or Contract)\n    Type() int8\n}\n</code></pre>"},{"location":"protocol/account/#address-and-public-key","title":"address and public key","text":"<p>BIP-0173 defines a new format for Segregated Witness output addresses that includes a human-readable portion identifying Bech32 usage. Daodst uses the following HRPs (human-readable prefixes) as base HRPs:</p> Network Mainnet Testnet Daodst dst dst <p>There are 3 main types of HRP for addresses/public keys available by default on Daodst:</p> <ul> <li>The account's address and key, which identify the user (such as the sender of a message). They are derived using the eth_secp256k1 curve.</li> <li>The validator operator's address and key, used to identify the validator's operator. They are derived using the eth_secp256k1 curve.</li> <li>The address and key of the consensus node, used to identify the verification nodes participating in the consensus. They are derived using the ed25519 curve</li> </ul> Name bech32 address prefix bech32 public key prefix curve address byte length public key byte length account dst dstpub eth_secp256k1 20 33 (compressed) Validator operations dstvaloper dstvaloperpub eth_secp256k1 20 33 (compressed) consensus node dstvalcons dstvalconspub ed25519 32"},{"location":"protocol/account/#customers-address-format","title":"Customer's address format","text":"<p>Eth account number can be represented in Bech32 (dst1...) and hexadecimal (0x...) formats for Ethereum's Web3 tooling compatibility.</p> <p>The Bech32 format is the default format for Cosmos-SDK queries and transactions via CLI and REST clients. On the other hand, the hexadecimal format is Ethereum common.Address represents Cosmos sdk.AccAddress.</p> <ul> <li>Address (Bech32): <code>dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw</code></li> <li>Address (EIP55 hexadecimal): <code>0x91defC7fE5603DFA8CC9B655cF5772459BF10c6f</code></li> <li>Compress public key: <code>{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}</code></li> </ul>"},{"location":"protocol/account/#address-translation","title":"address translation","text":"<p>stcd debug addr  can be used to convert addresses between hexadecimal and bech32 formats. For example: Bech32 <pre><code>  $ stcd debug addr dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n   Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n   Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre> <p>Hex</p> <pre><code>  $ stcd debug addr 14574A6DFF2DDF9E07828B4345D3040919AF5652\n   Address: [20 87 74 109 255 45 223 158 7 130 139 67 69 211 4 9 25 175 86 82]\n   Address (hex): 14574A6DFF2DDF9E07828B4345D3040919AF5652\n   Bech32 Acc: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   Bech32 Val: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n</code></pre>"},{"location":"protocol/account/#key-export","title":"Key export","text":"<p>We can use stcd's keys show command with the flags --bech  (acc|val|cons) to get addresses and keys, as described above, <p>Ordinary account</p> <pre><code>  $ stcd keys show dev0 --bech acc\n- name: dev0\n   type: local\n   address: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>validator</p> <pre><code>  $ stcd keys show dev0 --bech val\n- name: dev0\n   type: local\n   address: dstvaloper1z3t55m0l9h0eupuz3dp5t5cypyv674jjn4d6nn\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\"}'\n   mnemonic: \"\"\n</code></pre> <p>consensus</p> <pre><code>  $ stcd keys show dev0 --bech cons\n- name: dev0\n   type: local\n   address: dstvalcons1rllqa5d97n6zyjhy6cnscc7zu30zjn3f7wyj2n\n   pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"A/fVLgIqiLykFQxum96JkSOoTemrXD0tFaFQ1B0cpB2c\"}'\n   mnemonic: \"\"\n</code></pre>"},{"location":"protocol/account/#account-query","title":"Account query","text":"<p>You can use CLI, gRPC or</p> <p>command line interface</p> <pre><code># NOTE: the --output (-o) flag will define the output format in JSON or YAML (text)\nstcd q auth account $(stcd keys show dev0 -a) -o text\n\n'@type': /ethermint.types.v1.EthAccount\nbase_account:\naccount_number: \"0\"\naddress: dst1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw\npub_key:\n   '@type': /ethermint.crypto.v1.ethsecp256k1.PubKey\n   key: AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2\nsequence: \"1\"\ncode_hash: 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n</code></pre> <p>Cosmos gRPC and REST</p> <pre><code># GET /cosmos/auth/v1beta1/accounts/{address}\ncurl -X GET \"http://localhost:10337/cosmos/auth/v1beta1/accounts/dst14au322k9munkmx5wrchz9q30juf5wjgz2cfqku\" -H \"accept: application/json\"\n</code></pre> <p>JSON-RPC To retrieve Ethereum hex addresses using Web3, use the JSON-RPC eth_accounts or personal_listAccounts endpoints</p> <pre><code># query against a local node\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n\ncurl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"personal_listAccounts\",\"params\":[],\"id\":1}' -H \"Content-Type: application/json\" http://localhost:8545\n</code></pre>"},{"location":"protocol/chainid/","title":"chain ID","text":"<p>A chain ID is a unique identifier that represents a blockchain network. We use it to differentiate between different blockchain networks and ensure transactions and messages are sent to the correct network. Daodst network follows the format of identifier_EIP155-version.</p>"},{"location":"protocol/chainid/#mainnet","title":"Mainnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst1 <code>daodst_7777-1</code> daodst 7777 1 yes"},{"location":"protocol/chainid/#testnet","title":"testnet","text":"Name Chain ID Identifier EIP155 Number Version activation Daodst Public Testnet <code>daodst_7000-1</code> daodst 7000 1 yes"},{"location":"protocol/chainid/#chain-identity","title":"chain identity","text":"<p>Every chain must have a unique identifier or <code>chain-id</code>. Tendermint requires each application to define its own <code>chain-id</code> in the genesis.json fields. However, in order to comply with both EIP155 and the Cosmos chain upgrade standard, Daodst-compatible chains must implement a special structure for their chain identifiers.</p>"},{"location":"protocol/chainid/#structure","title":"structure","text":"<p>The Daodst chain ID consists of 3 main components</p> <ul> <li>Identifier: An unstructured string defining the name of the application.</li> <li>EIP155 Number: Immutable EIP155 <code>CHAIN_ID</code>   Defines the number of replay attack protections.</li> <li>version number: is the version number of the chain currently running (always a positive number). This number MUST be incremented every time the chain is upgraded or forked to avoid network or consensus errors.</li> </ul>"},{"location":"protocol/chainid/#format","title":"Format","text":"<p>The format of the Daodst-compatible chain-id specified in genesis is as follows:</p> <pre><code>{identifier}_{EIP155}-{version}\n</code></pre> <p>The following table provides an example, where the second row corresponds to an upgrade of the first row:</p> ChainID Identifier EIP155 Number Version Number <code>daodst_7777-1</code> daodst 7777 1 <code>daodst_7777-2</code> daodst 7777 2 <code>...</code> ... ... ... <code>daodst_7777-N</code> daodst 7777 N"},{"location":"protocol/coin/","title":"token","text":""},{"location":"protocol/coin/#daodst-token","title":"DAODST Token","text":"<p>The denomination used for staking, governance, and gas consumption on the EVM is FM. FM provides the following utilities: securing proof-of-stake chains, tokens for governance proposals, distributing fees to validators and users, and as fuel for running smart contracts on the EVM.</p> <p>DAODST Assets are divided into three categories:</p> <ul> <li>Native FM, DST, HASH tokens</li> <li>IBC tokens (via IBC)</li> <li>Ethereum-type tokens, such as ERC-20</li> </ul>"},{"location":"protocol/coin/#cosmos-tokens","title":"Cosmos Tokens","text":"<p>Accounts can have Cosmos coins in their balances, which are used for operations and transactions with other Cosmos. Examples of these include staking with tokens, IBC transfers, governance deposits, and EVM.</p>"},{"location":"protocol/coin/#evm-token","title":"EVM token","text":"<p>Daodst is compatible with ERC20 tokens and other non-fungible token standards natively supported by EVM (EIP721, EIP1155).</p>"},{"location":"protocol/encode/","title":"encode","text":"<p>Encoding refers to the process of converting data from one format to another to make it more secure and efficient.</p> <p>In the context of blockchain, encoding is used to ensure that data is stored and transmitted in a secure and easily accessible manner.</p> <p>Recursive Length Prefix (RLP) is a serialization format widely used in Ethereum execution clients.</p> <p>Its purpose is to encode arbitrarily nested arrays of binary data, and is the primary encoding used to serialize objects in Ethereum.</p> <p>RLP only encodes structures, leaving the encoding of specific atomic data types (such as strings, integers, and floats) to higher-level protocols.</p> <p>In Ethereum, integers must be represented in big-endian binary form without leading zeros, such that an integer value of zero is equivalent to an empty byte array.</p> <p>The RLP encoding function accepts an item, which is defined as a single byte with a value in the range [0x00, 0x7f] or a string 0-55 bytes long.</p> <p>If the string is longer than 55 bytes, the RLP encoding contains a byte with the value 0xb7 (dec.183) plus the length The length of the string in bytes in binary, followed by the length of the string, followed by the string.</p> <p>RLP is used for hash verification, where a transaction is signed by signing the RLP hash of the transaction data, and a block is identified by the RLP hash of its header.</p> <p>RLP is also used to encode data over networks, and in some cases should support efficient encoding of Merkle tree data structures.</p> <p>The Ethereum execution layer uses RLP as the primary encoding for serializing objects, but the newer Simple Serialize (SSZ) replaces RLP as the encoding for the new consensus layer in Ethereum 2.0.</p> <p>The Cosmos Stargate release introduced protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients, such as transaction messages, genesis, query services, etc., will be implemented as protocol buffer messages.</p> <p>The Cosmos SDK also supports traditional Amino encoding.</p> <p>Protocol Buffers (protobuf) is a language-independent binary serialization format that is smaller and faster than JSON.</p> <p>It is used to serialize structured data, such as messages, and is designed to be efficient and scalable.</p> <p>The encoding format is defined in a language-independent language called Protocol Buffers Language (proto3), and encoded messages can be used to generate code for various programming languages.</p> <p>The main advantage of protobuf is its efficiency, which results in smaller message sizes and faster serialization and deserialization times.</p> <p>The RLP decoding process is as follows: decode the data type, actual data length and offset according to the first byte of the input data (that is, the prefix); decode the data accordingly according to the data type and offset.</p>"},{"location":"protocol/encode/#prerequisites-reading","title":"Prerequisites Reading","text":"<ul> <li>Cosmos SDK Encoding</li> <li>Ethereum RLP</li> </ul>"},{"location":"protocol/encode/#encoding-format","title":"Encoding format","text":"<p>*** Protocol Buffers ***</p> <p>The Cosmos Stargate release introduces protobuf as the primary encoding format for client and state serialization.</p> <p>All EVM module types for state and clients (transaction messages, genesis, query services, etc.) will be implemented as protocol buffer messages.</p> <p>*** Amino ***</p> <p>The Cosmos SDK also supports the legacy Amino encoding format for backward compatibility with previous versions, especially for client-side encoding and signing with Ledger devices.</p> <p>Daodst does not support Amino in the EVM module, but all other Cosmos SDK modules that enable it do.</p> <p>*** RLP ***</p> <p>Recursive Length Prefix (RLP) is an encoding/decoding algorithm that serializes messages and allows fast reconstruction of encoded data.</p> <p>Daodst uses RLP to encode/decode Ethereum messages for JSON-RPC processing so that messages conform to the correct Ethereum format. This allows messages to be encoded and decoded in the exact same format as Ethereum's.</p> <p><code>x/evm</code> transaction (<code>MsgEthereumTx</code>) encoding is performed by converting the message to go-ethereum's <code>Transaction</code> and then using RLP to marshal the transaction data:</p> <pre><code>// TxEncoder overwrites sdk.TxEncoder to support MsgEthereumTx\nfunc (g txConfig) TxEncoder() sdk.TxEncoder {\nreturn func(tx sdk.Tx) ([]byte, error) {\n  msg, ok := tx.(*evmtypes.MsgEthereumTx)\n  if ok {\n    return msg.AsTransaction().MarshalBinary()\n  }\n  return g.TxConfig.TxEncoder()(tx)\n}\n}\n\n// TxDecoder overwrites sdk.TxDecoder to support MsgEthereumTx\nfunc (g txConfig) TxDecoder() sdk.TxDecoder {\nreturn func(txBytes []byte) (sdk.Tx, error) {\n  tx := &amp;ethtypes.Transaction{}\n\n  err := tx.UnmarshalBinary(txBytes)\n  if err == nil {\n    msg := &amp;evmtypes.MsgEthereumTx{}\n    msg.FromEthereumTx(tx)\n    return msg, nil\n  }\n\n  return g.TxConfig.TxDecoder()(txBytes)\n}\n}\n</code></pre>"},{"location":"protocol/gas/","title":"Gas and fees","text":"<p>Users need to pay fees to submit transactions on the Daodst network. Since fees are handled differently in Ethereum and Cosmos, it is important to understand how the Daodst blockchain implements Ethereum-type fee calculations that are compatible with the Cosmos SDK.</p> <p>Thus, this overview explains the basics of gas calculations, how fees are provided for transactions, and how Ethereum-style fee calculations use the fee market (EIP1559) to prioritize transactions.</p> <p>Also note that fees paid for interacting with smart contracts on Daodst can earn revenue for smart contract deployers. For information on this, go to develop.</p>"},{"location":"protocol/gas/#prerequisites-to-read","title":"Prerequisites to read","text":"<ul> <li>Cosmos SDK Gas</li> <li>Ethereum Gas</li> </ul>"},{"location":"protocol/gas/#base","title":"Base","text":""},{"location":"protocol/gas/#why-is-there-a-transaction-fee","title":"Why is there a transaction fee?","text":"<p>If anyone could submit transactions to the network for free, the network could be overwhelmed by a small number of participants sending fraudulent transactions to clog the network and make it non-functional.</p> <p>The solution to this problem is a concept called <code>gas</code>, which is the resource consumed throughout the execution of a transaction.</p> <p>In practice, each step of code execution consumes a small amount of gas, effectively charging validator resource usage and preventing malicious actors from disrupting the network at will.</p>"},{"location":"protocol/gas/#what-is-gas","title":"What is Gas?","text":"<p>In general, gas is a unit of measure for the computational intensity of a particular transaction \u2014 in other words, how much work is required to evaluate and execute it.</p> <p>Complex multi-step transactions, such as a Cosmos transaction that delegates to a dozen validators, require more gas than simple single-step transactions (such as a Cosmos transaction that sends tokens to another address).</p> <p>When referring to a transaction, <code>gas</code> refers to the total amount of gas required for the transaction.</p> <p>For example, a transaction may require 300,000 units of gas to execute.</p> <p>Think of gas as electricity (kWh) in a house or factory, or as fuel for a car.</p> <p>The idea is that it costs some money to get somewhere.</p> <p>More Gas introduction:</p> <ul> <li>Cosmos Gas Fees</li> <li>Cosmos Tx Lifecycle</li> <li>Ethereum Gas</li> </ul>"},{"location":"protocol/gas/#how-to-calculate-gas","title":"How to calculate Gas","text":"<p>In general, there is no way to know exactly how much gas a transaction will cost without simply running it.</p> <p>Using the Cosmos SDK, this can be done with Simulating a Tx.</p> <p>Otherwise, there are ways to estimate the gas a transaction will require based on details of the transaction fields and data.</p> <p>For example, in the case of the EVM, each bytecode operation has a corresponding amount of gas.</p> <p>More about Gas calculation:</p> <ul> <li>Estimate Gas</li> <li>Executing EVM Bytecode</li> <li>Simulate a Cosmos SDK Tx</li> </ul>"},{"location":"protocol/gas/#the-relationship-between-gas-and-handling-fee","title":"The relationship between Gas and handling fee?","text":"<p>Gas refers to the computational work required to perform it, while the fee refers to the amount of tokens you actually spend to execute the transaction.</p> <p>They are derived using the following formulas:</p> <pre><code>Total Fees = Gas * Gas Price (the price per unit of gas)\n</code></pre> <p>If <code>gas</code> is in kWh, then \"gas price\" will be the rate determined by your energy supplier in USD/kWh, and <code>fees</code> will be your bill.</p> <p>Like electricity, gas prices can fluctuate on a given day, depending on network traffic.</p> <p>More about Gas and Fees:</p> <ul> <li>Cosmos Gas and Fees</li> <li>Ethereum Gas and Fees</li> </ul>"},{"location":"protocol/gas/#how-does-cosmos-handle-transaction-fees","title":"How does Cosmos handle transaction fees?","text":"<p>Gas fees in Cosmos are relatively simple. As a user, you specify two fields:</p> <ol> <li>Corresponding to <code>GasLimit</code> of the execution gas limit, defined as <code>GasWanted</code></li> <li>One of <code>Fees</code> or <code>GasPrice</code>, which will be used to specify or calculate the transaction fee</li> </ol> <p>The node will fully consume the provided fee and then start executing the transaction. If the <code>GasLimit</code> is found to be insufficient during execution, the transaction will fail and any changes will be rolled back, the provided fee will not be refunded.</p> <p>Validators of Cosmos SDK-based chains can specify a \"minimum gas price\" that they will enforce when selecting transactions to include in a block.</p> <p>As a result, transactions with insufficient fees will experience delays or fail outright.</p> <p>At the beginning of each block, the previous block's fees are distributed to validators and delegators, after which they can be withdrawn and spent.</p>"},{"location":"protocol/gas/#how-to-handle-fees-on-ethereum","title":"How to handle fees on Ethereum?","text":"<p>Ethereum fees include multiple implementations introduced over time.</p> <p>Initially, the user will specify the <code>GasPrice</code> and <code>GasLimit</code> in the transaction - much like a Cosmos SDK transaction.</p> <p>Block proposers will receive the full gas fee from each transaction in the block, and they will choose which transactions to include accordingly.</p> <p>With the proposal EIP-1559 and the London hard fork, the gas calculation has changed.</p> <p>The above <code>GasPrice</code> is now split into two separate parts: <code>BaseFee</code> and <code>PriorityFee</code>.</p> <p><code>BaseFee</code> is automatically calculated based on the block size and will be destroyed once the block is mined.</p> <p><code>PriorityFee</code> is given to the proposer and represents a tip, or incentive for the proposer to include the transaction in a block.</p> <pre><code>Gas Price = Base Fee + Priority Fee\n</code></pre> <p>In a transaction, in addition to specifying a <code>gas_limit</code> as before, the user can specify a <code>max_fee_per_gas</code> corresponding to the total <code>GasPrice</code> and a <code>max_priority_fee_per_gas</code> corresponding to the maximum <code>PriorityFee</code>.</p> <p>All excess gas not required for execution is returned to the user.</p> <p>More about Ethereum fees:</p> <ul> <li>Gas Calculation Docs</li> <li>Proposal EIP-1559</li> </ul>"},{"location":"protocol/gas/#implementation","title":"Implementation","text":""},{"location":"protocol/gas/#how-to-deal-with-gas-and-fees-on-daodst","title":"How to deal with Gas and fees on Daodst?","text":"<p>Fundamentally, Daodst is a Cosmos SDK chain that enables EVM compatibility as part of a Cosmos SDK module. Due to this architecture, all EVM transactions are ultimately encoded as Cosmos SDK transactions and update the state managed by the Cosmos SDK. Since all transactions are represented as Cosmos SDK transactions, transaction fees can be at different execution layers.</p> <p>In fact, processing fees include standard Cosmos SDK logic, some Ethereum logic, and customDaodst logic. In most cases, fees are collected by the <code>fee_collector</code> module and then paid to validators and delegators. Some key differences are as follows:</p> <p>1.Fee Market Module</p> <p>To support EIP-1559 gas and fee calculations on Daodst's EVM layer, Daodst tracks the gas supplied for each block and uses it to calculate the base fee for future EVM transactions, enabling EIP-specified EVM dynamic fees and transaction prioritization Level -1559.</p> <p>For EVM transactions, each node bypasses its local <code>min-gas-prices</code> configuration and instead applies EIP-1559 fee logic - the gas price must simply be greater than the global <code>min-gas-price</code> and the block's <code>BaseFee</code>, the remainder is considered the priority tip.</p> <p>This allows validators to calculate Ethereum fees without applying the Cosmos SDK fee logic.</p> <p>Unlike Ethereum, the <code>BaseFee</code> on Daodst will not be destroyed, but distributed to validators and delegators</p> <p>Additionally, <code>BaseFee</code> is bounded by the global <code>min-gas-price</code> (currently, the global <code>min-gas-price</code> parameter is set to zero, although it can be updated via governance).</p> <p>2. EVM Gas refund</p> <p>Daodst refunds a small portion (at least 50% by default) of unspent gas for EVM transactions to approximate the current behavior on Ethereum.</p> <p>3. Income module</p> <p>Daodst develops the revenue module as a way to reward developers for creating useful dApps - any contract that registers with the Daodst revenue module rewards the contract developer with a small portion of transaction fees (currently 95% ). Validators and delegators earn the remainder.</p>"},{"location":"protocol/gas/#detailed-schedule","title":"Detailed schedule","text":"<ol> <li> <p>The node executes the previous block and runs the <code>EndBlock</code> hook * As part of this hook, the FeeMarket (EIP-1559) module tracks the total <code>TransientGasWanted</code> from transactions on that block.    This will be used for the <code>BaseFee</code> of the next block.</p> </li> <li> <p>Nodes receive transactions for subsequent blocks and gossip about these transactions to their peers *These can be sorted and prioritized by included fee price (EVM transactions using the EIP-1559 fee priority mechanism will be included in the next block</p> </li> <li> <p>The node runs the <code>BeginBlock</code> * FeeMarket module for the subsequent block to calculate the <code>BaseFee</code> to apply to this block using the total <code>GasWanted</code> from the previous block.</p> </li> <li> <p>Distribution module distributes The previous block's fee rewards to validators and delegators</p> </li> <li> <p>For each valid transaction to be included in this block, the node does the following:</p> </li> </ol> <p>** They run an <code>AnteHandler</code> corresponding to the transaction type **.</p> <p>This process:</p> <ol> <li>Perform basic transaction validation</li> <li>Verify that the provided fee is greater than the global and local minimum validator values and greater than the computed <code>BaseFee</code><ol> <li>(For Ethereum transactions) Preempting EVM transaction consumption gas</li> </ol> </li> <li>Deduct the user's transaction fee and transfer it to the <code>fee_collector</code> module</li> <li>Increase the <code>TransientGasWanted</code> in the current block to calculate the <code>BaseFee</code> of the next block</li> </ol> <p>Then, for standard Cosmos transactions, nodes</p> <ul> <li>Execute transactions and update status</li> <li>Transaction consumes gas</li> </ul> <p>For Ethereum transactions, nodes:</p> <ul> <li>Execute transactions and update status</li> <li>Calculates the gas used and compares it to the supplied gas, then refunds the remainder of the specified portion</li> <li> <p>If the transaction interacts with a registered smart contract, a small portion of the fee used as revenue is sent to the contract developer as part of the revenue module</p> </li> <li> <p>The node runs <code>EndBlock</code> for this block and stores the <code>GasWanted</code> of the block</p> </li> </ul>"},{"location":"protocol/gas/#detailed-practice","title":"Detailed practice","text":""},{"location":"protocol/gas/#cosmos-gas","title":"Cosmos <code>Gas</code>","text":"<p>In the Cosmos SDK, gas is mainly tracked in <code>GasMeter</code> and <code>BlockGasMeter</code>:</p> <ul> <li><code>GasMeter</code>: Tracks gas consumed during executions that lead to state transitions. It is reset every time a transaction is executed.</li> <li><code>BlockGasMeter</code>: Tracks gas consumed in a block and enforces gas not exceeding a predefined limit. This limit is defined in the Tendermint consensus parameters and can be changed through governance parameter change proposals.</li> </ul> <p>Since gas is priced in bytes, the same interaction with larger parameter values will cost more gas than smaller parameter values (unlike Ethereum's <code>uint256</code> values, Cosmos SDK values use Big.Int types, which are dynamically resized).</p> <p>More information on gas as part of the Cosmos SDK can be found here.</p>"},{"location":"protocol/gas/#match-evm-gas-consumption","title":"Match EVM Gas consumption","text":"<p>Daodst is an EVM compatible chain that supports Ethereum Web3 tools. For this reason, gas consumption must be comparable to other EVMs, most importantly Ethereum.</p> <p>The main difference between EVM and Cosmos state transitions is that the EVM uses a gas table for each opcode, Instead, Cosmos uses <code>GasConfig</code> to charge gas for each CRUD operation by setting a fixed per-byte cost for accessing the database.</p> <p>To match the gas consumed by the EVM, the gas consumption logic in the SDK is ignored, instead the gas consumed is calculated by subtracting the state transition remaining gas plus the refund from the gas limit defined on the message.</p> <p>To ignore the SDK's gas consumption, we reset the transaction <code>GasMeter</code> count to 0 and manually set it to the <code>gasUsed</code> value calculated by the EVM module at the end of execution.</p>"},{"location":"protocol/gas/#antehandler","title":"<code>AnteHandler</code>","text":"<p>The Cosmos SDK <code>AnteHandler</code> performs basic checks before transaction execution.</p> <p>These checks are typically signature verification, transaction field verification, transaction fees, etc.</p> <p>Regarding gas consumption and fees, <code>AnteHandler</code> checks that the user has enough balance to cover the tx cost (amount plus the fee), and checks that the gas limit defined in the message is greater than or equal to the computed intrinsic gas message.</p>"},{"location":"protocol/gas/#gas-return","title":"Gas Return","text":"<p>In EVM, gas can be specified before execution. The full amount of gas specified is consumed at the start of execution (during the <code>AnteHandler</code> step), if any gas remains after execution, the remaining gas will be refunded to the user.</p> <p>Additionally, the EVM can also define gas to be returned to the user, but these will be limited to a fraction of the gas used, depending on the fork/version used.</p>"},{"location":"protocol/gas/#zero-fee-transactions","title":"Zero Fee Transactions","text":"<p>In Cosmos, <code>AnteHandler</code> does not enforce minimum gas prices, because <code>min-gas-prices</code> are checked against local nodes/validators.</p> <p>In other words, the minimum fee accepted is determined by the validators of the network, and each validator can specify a different minimum value for their fee.</p> <p>This may allow end users to submit 0-fee transactions if at least one validator is willing to include a <code>0</code> gas price transaction in their proposed block.</p> <p>For the same reason, in Daodst it is possible to send transactions with a <code>0</code> fee for transaction types other than those defined by the <code>evm</code> module.</p> <p>EVM module transactions cannot have a \"0\" fee because the EVM itself requires gas.</p> <p>This check is done by the EVM transaction stateless validation (i.e. <code>ValidateBasic</code>) function as well as a custom <code>AnteHandler</code> defined by Daodst.</p>"},{"location":"protocol/gas/#gas-estimate","title":"Gas Estimate","text":"<p>Ethereum provides a JSON-RPC endpoint <code>eth_estimateGas</code> to help users set the correct gas limit in their transactions.</p> <p>Therefore, a specific query API <code>EstimateGas</code> is implemented in Daodst. It will apply the transaction against the current block/state and perform a binary search to find the best gas value to return to the user (the same transaction will be applied over and over until we find the minimum gas required before failing).</p> <p>The reason we need to use binary search is that the gas required by the transaction may be higher than the value returned by the EVM after applying the transaction, so we need to try until we find the optimal value.</p> <p>A cached context will be used throughout execution to avoid persisting changes in state.</p> <p>For Cosmos Tx, developers can use Cosmos SDK's transaction simulation to create accurate estimates.</p>"},{"location":"protocol/gas/#use-daodst-cli-to-process-gas-and-transaction-fees","title":"Use Daodst CLI to process Gas and transaction fees","text":"<p>Users should consider the available options when broadcasting transactions using the Daodst CLI client. There are three flags to consider when sending a transaction to the network:</p> <ul> <li><code>--fees</code>: Fees to pay with the transaction; eg: 10dst. Defaults to required fee.</li> <li><code>--gas</code>: Gas limit to set per transaction; default is 200000.</li> <li><code>--gas-prices</code>: gas prices to determine transaction fees (e.g. 10dst).</li> </ul> <p>However, not all of these need to be defined in every transaction. The correct combination is:</p> <ul> <li><code>--fees=auto</code>: Automatically estimate fees and gas (same behavior as --gas=auto ).   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas=auto</code>: Same behavior as <code>--fees=auto</code>.   An error is thrown if any other fee-related flags are used (e.g. <code>--gas-prices</code>, <code>--fees</code>)</li> <li><code>--gas={int}</code>: use the specified amount of gas and the transaction fee</li> <li><code>--fees={int}{denom}</code>: use the specified fee for tx. Use the gas default (200000) for tx.</li> <li><code>--fees={int}{denom} --gas={int}</code>: Use the specified gas and fee. Computes the gas-price using the provided parameters</li> <li><code>--gas-prices={int}{denom}</code>: Use provided gas prices and default gas amount (200000)</li> <li><code>--gas-prices={int}{denom} --gas={int}</code>: Use the gas specified for tx and calculate the price with the corresponding parameters.</li> </ul> <p>Readers should note that the first two options provide a more user-friendly experience for new users, while the latter are intended for more advanced users who want more control over these parameters.</p> <p>The team introduced the 'auto' flag option, which automatically calculates the gas and fees required to execute a transaction. In this way, new users or developers can execute transactions without defining specific gas and fee values.</p> <p>Using the <code>auto</code> flag may sometimes not estimate the correct gas and fees based on network traffic. To overcome this, you can use a higher value for the <code>--gas-adjustment</code> flag. By default it is set to <code>1.2</code>. When the estimate is insufficient, retry a higher gas adjustment, such as <code>--gas-adjustment 1.3</code>.</p> <p>The <code>--gas-prices</code> and <code>--fees</code> flags cannot be combined. If so, the user will receive an error message stating that fees and gas prices cannot be provided at the same time.</p> <p>Keep in mind that the above combo may fail if the fee or gas amount offered is insufficient. If this is the case, the CLI will return an error message with the specific reason. For example:</p> <pre><code>raw_log: 'out of gas in location: submit proposal; gasWanted: 200000, gasUsed: 263940.\n  Please retry with a gas (--gas flag) amount higher than gasUsed: out of gas'\n</code></pre>"},{"location":"protocol/key-management/","title":"Key Management","text":"<p>A mnemonic, also known as a mnemonic, is a set of words used to recover or recover a cryptocurrency wallet. It serves as a backup to access your digital assets if you lose access to the original wallet. This phrase is usually a series of 12-24 words generated when you created your wallet and should be kept safe and private.</p> <p>The importance of the seed phrase is that cryptocurrencies are stored in a decentralized manner, meaning that there is no central authority or institution that holds or controls your funds. This means that if you lose access to your wallet (e.g. forget your password, lose your device), you will not be able to get your funds back without your seed phrase. Therefore, it is crucial to store your seed phrase in a safe and secure place, such as physical paper or a secure digital file.</p> <p>Also, it is recommended to make multiple copies and store them in different locations so that you have access to your funds in case of any emergency.</p>"},{"location":"protocol/key-management/#mnemonic-phrase-and-private-key","title":"Mnemonic Phrase and Private Key","text":"<p>A seed phrase, also known as a recovery phrase or backup phrase, is a series of words used to generate a private key. It is usually a set of 12 or 24 words used to recover or restore access to a cryptocurrency wallet if the original private key is lost or damaged. The seed phrase can be used to generate multiple private keys that can be used to access multiple cryptocurrency addresses and balances.</p> <p>A private key, on the other hand, is a long string of characters that is used to sign transactions and provide access to your cryptocurrency funds. Private keys are generated from a seed phrase and are unique to each cryptocurrency address. It is used to create a digital signature for a transaction to ensure that the transaction is legitimate and has been authorized by the rightful owner of the funds.</p> <p>In conclusion, the security of your private key and seed phrase is paramount. If your private key is compromised, it could put all linked accounts at risk. However, losing the mnemonic phrase can have more serious consequences because it is used to generate multiple private keys. Therefore, it is crucial to take proper steps to protect your private key and seed phrase to avoid any catastrophic loss.</p>"},{"location":"protocol/key-management/#mnemonics-in-daodst-cli","title":"Mnemonics in Daodst CLI","text":"<p>Before proceeding with the CLI, make sure you have <code>stcd</code> installed. Installation instructions are located.</p> <p>When you create a new key, you receive a seed phrase that you can use to recover that key. Backup mnemonic:</p> <pre><code>stcd keys add dev0\n{\n  \"name\": \"dev0\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}',\n  \"mnemonic\": \"\"\n}\n\n**Important** write this mnemonic phrase in a safe place.\nIt is the only way to recover your account if you ever forget your password.\n\n# &lt;24 word mnemonic phrase&gt;\n</code></pre> <p>To restore keys:</p> <pre><code>$ stcd keys add dev0-restored --recover\n&gt; Enter your bip39 mnemonic\nbanner genuine height east ghost oak toward reflect asset marble else explain foster car nest make van divide twice culture announce shuffle net peanut\n{\n  \"name\": \"dev0-restored\",\n  \"type\": \"local\",\n  \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n  \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n}\n</code></pre>"},{"location":"protocol/key-management/#key-export","title":"Key export","text":""},{"location":"protocol/key-management/#tendermint-private-key-format","title":"Tendermint-Private Key Format","text":"<p>To back up such a key without a mnemonic:</p> <pre><code>stcd keys export dev0\nEnter passphrase to decrypt your key:\nEnter passphrase to encrypt the exported key:\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\n\n$ echo \"\\\n-----BEGIN TENDERMINT PRIVATE KEY-----\nkdf: bcrypt\nsalt: 14559BB13D881A86E0F4D3872B8B2C82\ntype: secp256k1\n\n# &lt;Tendermint private key&gt;\n-----END TENDERMINT PRIVATE KEY-----\" &gt; dev0.export\n</code></pre>"},{"location":"protocol/key-management/#ethereum-private-key-format","title":"Ethereum-Private Key Format","text":"<p>NOTE: These types of keys are compatible with MetaMask</p> <p>To back up such a key without a mnemonic:</p> <pre><code>stcd keys unsafe-export-eth-key dev0 &gt; dev0.export\n**WARNING** this is an unsafe way to export your unencrypted private key, are you sure? [y/N]: y\nEnter keyring passphrase:\n</code></pre>"},{"location":"protocol/key-management/#key-import","title":"key import","text":""},{"location":"protocol/key-management/#tendermint-private-key-format_1","title":"Tendermint-Private Key Format","text":"<pre><code>$ stcd keys import dev0-imported ./dev0.export\nEnter passphrase to decrypt your key:\n</code></pre>"},{"location":"protocol/key-management/#ethereum-private-key-format_1","title":"Ethereum-Private Key Format","text":"<pre><code>$ stcd keys unsafe-import-eth-key dev0-imported ./dev0.export\nEnter passphrase to encrypt your key:\n</code></pre>"},{"location":"protocol/key-management/#verify","title":"verify","text":"<p>Verify that your key has been restored using the following command:</p> <pre><code>$ stcd keys list\n[\n  {\n    \"name\": \"dev0-imported\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0-restored\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  },\n  {\n    \"name\": \"dev0\",\n    \"type\": \"local\",\n    \"address\": \"dst1n253dl2tgyhxjm592p580c38r4dn8023ctv28d\",\n    \"pubkey\": '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"ArJhve4v5HkLm+F7ViASU/rAGx7YrwU4+XKV2MNJt+Cq\"}'\n  }\n]\n</code></pre>"},{"location":"protocol/keyring/","title":"Keyring Keyring","text":"<p>Create, import, export, and delete keys using the CLI keyring.</p> <p>The keyring holds private/public key pairs used to interact with nodes. For example, a validator key needs to be set up before running a node so that blocks can be properly signed. Private keys can be stored in various locations, called \"backends\", such as files or the operating system's own keystore.</p> <p>\ud83d\udce3 Tips: If you need a refresher on private keys and key management, please refer to our Key Management.</p>"},{"location":"protocol/keyring/#add-key","title":"Add key","text":"<p>You can get help on the <code>keys</code> command and more information on specific subcommands using the following command, respectively:</p> <pre><code>stcd keys\n</code></pre> <pre><code>stcd keys [command] --help\n</code></pre> <p>To create a new key in the keyring, run the <code>add</code> subcommand with the <code>&lt;key_name&gt;</code> argument. You will have to provide a password for newly generated keys. This key will be used in the next section.</p> <pre><code>stcd keys add dev0\n\n# Put the generated address in a variable for later use.\nMY_VALIDATOR_ADDRESS=$(stcd keys show dev0 -a)\n</code></pre> <p>This command generates a new 24-word mnemonic, persists it to the relevant backend, and outputs information about the key pair. If this key pair will be used to hold valuable tokens, be sure to write the seed phrase in a safe place!</p> <p>By default, keyring generates an <code>eth_secp256k1</code> key. Keyring also supports <code>ed25519</code> keys, which can be created by passing the <code>--algo</code> flag. A key ring can of course hold both types of keys.</p> <p>\ud83d\udce3 Tip: The Ethereum address associated with the public key can be derived by taking the full Ethereum public key of type <code>eth_secp256k1</code>, computing the <code>Keccak-256</code> hash, and truncating the first twelve bytes.</p> <p>\ud83d\udea8 DANGER: Daodst does not support Cosmos <code>secp256k1</code> keys due to compatibility issues with Ethereum transactions.</p>"},{"location":"protocol/keyring/#keyring-backend","title":"Keyring backend","text":""},{"location":"protocol/keyring/#os","title":"OS","text":"<p>\ud83d\udce3 Tips: <code>os</code> is the default option because the operating system's default credential manager is designed to meet the most common needs of users and provide them with a comfortable experience without compromising security.</p> <p>The <code>os</code> backend relies on OS-specific defaults to handle key storage securely. Typically, the operating system's credential subsystem handles password prompting, private key storage, and user sessions according to the user's password policy. Below is a list of the most popular operating systems and their respective password managers:</p> <ul> <li>macOS (since Mac OS 8.6): Keychain</li> <li>Windows: Credentials Management API</li> <li>GNU/Linux:</li> <li>libsecret</li> <li>kwallet</li> </ul> <p>GNU/Linux distributions that use GNOME as their default desktop environment usually come with Seahorse. Users of KDE-based distributions usually get the KDE Wallet Manager. The former is actually a convenient <code>libsecret</code> front-end, while the latter is a <code>kwallet</code> client.</p> <p>The recommended backends for headless environments are <code>file</code> and <code>pass</code>.</p>"},{"location":"protocol/keyring/#file","title":"File","text":"<p><code>file</code> stores the encrypted keyring in the application's configuration directory. The password is requested every time this keyring is accessed, which may occur multiple times in a single command, resulting in repeated password prompts. If using a bash script to execute commands via the <code>file</code> option, you may wish to use the following format for multiple prompts:</p> <pre><code># assuming that KEYPASSWD is set in the environment\nyes $KEYPASSWD | stcd keys add me\nyes $KEYPASSWD | stcd keys show me\n# start stcd with keyring-backend flag\nstcd --keyring-backend=file start\n</code></pre> <p>\ud83d\udce3 Tip: The first time you add a key to an empty keyring, you will be prompted for the passphrase twice.</p>"},{"location":"protocol/keyring/#pass","title":"Pass","text":"<p>The <code>pass</code> backend uses the pass utility to manage disk encryption of sensitive data and metadata for keys. Keys are stored in \"gpg\" encrypted files in application-specific directories. <code>pass</code> is available for most popular UNIX operating systems as well as GNU/Linux distributions. See its man page for how to download and install it.</p> <p>\ud83d\udce3 Hint: <code>pass</code> uses GnuPG for encryption. <code>gpg</code> automatically invokes the <code>gpg-agent</code> daemon upon execution, which handles the caching of GnuPG credentials. See the <code>gpg-agent</code> man page for more information on how to configure caching parameters such as credential TTL and password expiration.</p> <p>Password storage must be set up before first use:</p> <pre><code>pass init &lt;GPG_KEY_ID&gt;\n</code></pre> <p>Replace <code>&lt;GPG_KEY_ID&gt;</code> with your GPG key ID. You can use your personal GPG key or an alternative key that you might want to use specifically to encrypt password storage.</p>"},{"location":"protocol/keyring/#kwallet","title":"Kwallet","text":"<p>The <code>kwallet</code> backend uses <code>KDE Wallet Manager</code>, which is installed by default on GNU/Linux distributions with KDE as the default desktop environment. For more information, please refer to KWallet Manual.</p>"},{"location":"protocol/keyring/#testing","title":"Testing","text":"<p>The <code>test</code> backend is a passwordless variant of the <code>file</code> backend. Keys are stored on disk in unencrypted form. This keyring is for testing purposes only. Use at your own risk!</p> <p>\ud83d\udea8 DANGER: NEVER use the <code>test</code> keying backend to create your mainnet validator keys. Doing so may result in Remote access to your funds through the <code>eth_sendTransaction</code> JSON-RPC endpoint, resulting in loss of funds.</p>"},{"location":"protocol/keyring/#memory","title":"Memory","text":"<p>The <code>memory</code> backend stores keys in memory. The key will be deleted immediately after the program exits.</p> <p>\ud83d\udea8 DANGER: For testing purposes only. The <code>memory</code> backend is NOT recommended for production use. Use at your own risk!</p>"},{"location":"protocol/multsign/","title":"Multsignature","text":"<p>Learn how to generate, sign, and broadcast transactions using keyring multisig.</p> <p>Multi-signature account is a Dst account with a special key that requires multiple signatures to sign transactions. This is useful for increasing the security of an account or requiring multiple parties to agree to a transaction. A multi-signature account can be created by specifying:</p> <ul> <li>Threshold number of required signatures</li> <li>The public key involved in the signature</li> </ul> <p>To be signed with a multisig account, the transaction must be signed individually by a different key specified for that account. The signatures are then combined into a multisig that can be used to sign transactions. If the number of signatures present is less than the required threshold number, the resulting multisig is considered invalid.</p>"},{"location":"protocol/multsign/#generate-a-multi-signature-key-pair","title":"Generate a multi-signature key pair","text":"<pre><code>stcd keys add --multisig=name1,name2,name3[...] --multisig-threshold=K new_key_name\n</code></pre> <p><code>K</code> is the minimum number of private keys that must sign a transaction with a public key address as a signer.</p> <p>The <code>--multisig</code> flag must contain the names of the public keys that will be combined into a single public key that will be generated and stored in the local database as <code>new_key_name</code>.</p> <p>All names provided via <code>--multisig</code> must already exist in the local database.</p> <p>The order in which keys are provided on the command line does not matter unless the flag <code>--nosort</code> is set, i.e. the following command produces two identical keys:</p> <pre><code>stcd keys add --multisig=p1,p2,p3 --multisig-threshold=2 multisig_address\nstcd keys add --multisig=p2,p3,p1 --multisig-threshold=2 multisig_address\n</code></pre> <p>Multisig addresses can also be generated on the fly and printed via the which command:</p> <pre><code>stcd keys show --multisig-threshold=K name1 name2 name3 [...]\n</code></pre>"},{"location":"protocol/multsign/#sign-transaction","title":"Sign transaction","text":""},{"location":"protocol/multsign/#step-1-create-a-multi-signature-key","title":"Step 1: Create a multi-signature key","text":"<p>Suppose you have <code>test1</code> and <code>test2</code> and want to create a multisignature account using <code>test3</code>.</p> <p>First import the public key of <code>test3</code> into your keyring.</p> <pre><code>stcd keys add \\\n     test3\\\n     --pubkey=dstpub1addwnpepqgcxazmq6wgt2j4rdfumsfwla0zfk8e5sws3p3zg5dkm9007hmfysxas0u2\n</code></pre> <p>Generate a multi-signature key with a 2/3 threshold.</p> <pre><code>stcd keys add \\\n     multi \\\n     --multisig=test1,test2,test3 \\\n     --multisig-threshold=2\n</code></pre> <p>You can see its address and details:</p> <pre><code>stcd keys show multi\n\n- name: multi\n   type: multi\n   address: dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\n   pubkey: dstpub1ytql0csgqgfzd666axrjzq3mxw59ys6yqcd3ydjvhgs0uzs6kdk5fp4t73gmkl8t6y02yfq7tvfzd666axrjzq3sd69kp5usk492x6nehqjal67ynv0nfqapzrz y3gmdk27la0kjfqfzd666axrjzq6utqt639ka2j3xkncgk65dup06t297ccljmxhvhu3rmk92u3afjuyz9dg9\n   mnemonic: \"\"\n   threshold: 0\n   pubkeys: []\n</code></pre> <p>Let's add 10 DST to the multisig wallet:</p> <pre><code>stcd tx bank send \\\n     test1\\\n     dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\\\n     100000000000000000000dst\\\n     --chain-id=daodst_7000-1 \\\n     --gas=auto \\\n     --fees=1000000dst \\\n     --broadcast-mode=block\n</code></pre>"},{"location":"protocol/multsign/#step-2-create-a-multi-signature-transaction","title":"Step 2: Create a multi-signature transaction","text":"<p>We want to send 5 DST from our multisig account to <code>dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft</code>.</p> <pre><code>stcd tx bank send \\\n     dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\\\n     dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq \\\n     50000000000000000000dst \\\n     --gas=200000 \\\n     --fees=1000000dst \\\n     --chain-id=daodst_7000-1 \\\n     --generate-only &gt; unsignedTx.json\n</code></pre> <p>The file <code>unsignedTx.json</code> contains unsigned transactions encoded in JSON.</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": []\n}\n</code></pre>"},{"location":"protocol/multsign/#step-3-sign-alone","title":"Step 3: Sign alone","text":"<p>Sign with <code>test1</code> and <code>test2</code> and create individual signatures.</p> <pre><code>stcd tx sign \\\n     unsignedTx.json \\\n     --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m \\\n     --from=test1 \\\n     --output-document=test1sig.json\\\n     --chain-id=daodst_7000-1\n</code></pre> <pre><code>stcd tx sign \\\n     unsignedTx.json \\\n     --multisig=dst1e0fx0q9meawrcq7fmma9x60gk35lpr4xk3884m\\\n     --from=test2 \\\n     --output-document=test2sig.json\\\n     --chain-id=daodst_7000-1\n</code></pre>"},{"location":"protocol/multsign/#step-4-create-multisig","title":"Step 4: Create Multisig","text":"<p>Combined with the signature to sign the transaction.</p> <pre><code>stcd tx multisign \\\n     unsignedTx.json \\\n     multi \\\n     test1sig.json test2sig.json\\\n     --output-document=signedTx.json\\\n     --chain-id=daodst_7000-1\n</code></pre> <p>TX is now signed:</p> <pre><code>{\n  \"body\": {\n    \"messages\": [\n      {\n        \"@type\": \"/cosmos.bank.v1beta1.MsgSend\",\n        \"from_address\": \"dst1rgjxswhuxhcrhmyxlval0qa70vxwvqn2e0srft\",\n        \"to_address\": \"dst157g6rn6t6k5rl0dl57zha2wx72t633axqyvvwq\",\n        \"amount\": [\n          {\n            \"denom\": \"dst\",\n            \"amount\": \"5000000000000000000\"\n          }\n        ]\n      }\n    ],\n    \"memo\": \"\",\n    \"timeout_height\": \"0\",\n    \"extension_options\": [],\n    \"non_critical_extension_options\": []\n  },\n  \"auth_info\": {\n    \"signer_infos\": [\n      {\n        \"public_key\": {\n          \"@type\": \"/cosmos.crypto.multisig.LegacyAminoPubKey\",\n          \"threshold\": 2,\n          \"public_keys\": [\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"ApCzSG8k7Tr4aM6e4OJRExN7cNtvH21L9azbh+uRrvt4\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"Ah91erz8ChNanqLe9ea948rvAiXMCRlR5Ka7EE/c0xUK\"\n            },\n            {\n              \"@type\": \"/cosmos.crypto.secp256k1.PubKey\",\n              \"key\": \"A0OjtIUCFJM3AobJ9HJTWKP9RZV2+WPcwVjLgsAidrZ/\"\n            }\n          ]\n        },\n        \"mode_info\": {\n          \"multi\": {\n            \"bitarray\": {\n              \"extra_bits_stored\": 3,\n              \"elems\": \"wA==\"\n            },\n            \"mode_infos\": [\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              },\n              {\n                \"single\": {\n                  \"mode\": \"SIGN_MODE_LEGACY_AMINO_JSON\"\n                }\n              }\n            ]\n          }\n        },\n        \"sequence\": \"1\"\n      }\n    ],\n    \"fee\": {\n      \"amount\": [\n        {\n          \"denom\": \"dst\",\n          \"amount\": \"1000000\"\n        }\n      ],\n      \"gas_limit\": \"200000\",\n      \"payer\": \"\",\n      \"granter\": \"\"\n    }\n  },\n  \"signatures\": [\n    \"CkCEeIbeGc+I1ipZuhp/0KhVNnWAv2tTlvgo5x61lzk1KHmLPV38m/YFurrFt5cm5+fqIXrn+FlOjrJuzBhw8ogYCkCawm9mpXsBHk0CFsE5618fVnvScEkfrzW0c2jCcjqV8EPuj3ut74UWzZyQkwtJGxUWtro9EgnGsB7Di1Gzizst\"\n  ]\n}\n</code></pre>"},{"location":"protocol/multsign/#step-5-broadcast-transaction","title":"Step 5: broadcast transaction","text":"<pre><code>stcd tx broadcast signedTx.json \\\n    --chain-id=daodst_7000-1 \\\n    --broadcast-mode=block\n</code></pre>"},{"location":"protocol/pending/","title":"waiting queue","text":"<p>When a transaction is submitted to the Ethereum network, it first enters the pending state, waiting for the node to execute it.</p> <p>If the gas price in a transaction is set very low and the node is busy processing other transactions with higher gas prices, the transaction may remain pending for a longer period of time.</p> <p>During the pending state, transaction initiators are allowed to change transaction fields at any time.</p> <p>They can do this by sending another transaction with the same nonce.</p>"},{"location":"protocol/pending/#prerequisites-to-read","title":"Prerequisites to read","text":"<ul> <li>Cosmos SDK Mempool</li> </ul>"},{"location":"protocol/pending/#daodst-vs-ethereum","title":"Daodst vs Ethereum","text":"<p>In Ethereum, pending blocks are generated when miners are queued for production.</p> <p>These pending blocks consist of pending transactions picked by miners based on the highest gas reward paid.</p> <p>This mechanism exists because block finality is not possible on the Ethereum network.</p> <p>Blocks are committed with probabilistic determinism, meaning that over time (and blocks) transactions and blocks become less likely to be reverted.</p> <p>Daodst is designed completely differently in this regard, as there is no concept of \"pending state\".</p> <p>Daodst uses Tendermint Core BFT consensus to provide instant finality for transactions.</p> <p>For this reason, Ethermint does not need to suspend the state mechanism, since all (if not most) transactions will be committed to the next block (the average block time on the Cosmos chain is about 8 seconds).</p> <p>However, this causes problems with some Ethereum Web3 compatible queries, which may enter a pending state.</p> <p>Another notable difference from Ethereum is that blocks are generated by validators, or block producers, who include transactions from their local mempool into blocks in a first-in-first-out (FIFO) fashion.</p> <p>Transactions on Daodst cannot be ordered or picked from the Tendermint node mempool.</p>"},{"location":"protocol/pending/#pending-status-queue","title":"Pending status queue","text":"<p>Daodst will make queries to account for any unconfirmed transactions that exist in the node's transaction mempool.</p> <p>Pending state queries made will be subjective and will be queried on the mempool of the target node.</p> <p>So for the same query on two different nodes, the pending status will not be the same.</p> <p>** JSON-RPC Calls on Pending Transactions **</p> <ul> <li><code>eth_getBalance</code></li> <li><code>eth_getTransactionCount</code></li> <li><code>eth_getBlockTransactionCountByNumber</code></li> <li><code>eth_getBlockByNumber</code></li> <li><code>eth_getTransactionByHash</code></li> <li><code>eth_getTransactionByBlockNumberAndIndex</code></li> <li><code>eth_sendTransaction</code></li> </ul>"},{"location":"protocol/state-migrate/","title":"State import and export","text":"<p>Daodst can dump the entire application state into a JSON file. In addition to upgrade, this is useful for manually analyzing the status at a specified height.</p>"},{"location":"protocol/state-migrate/#export-status","title":"export status","text":"<p>Export status:</p> <pre><code>stcd export &gt; new_genesis.json\n</code></pre> <p>You can also export state from a specific height (at the end of the block that handles that height):</p> <pre><code>stcd export --height [height] &gt; new_genesis.json\n</code></pre> <p>If you plan to start a new network with height 0 (i.e. genesis) from the exported state, export with the <code>--for-zero-height</code> flag:</p> <pre><code>stcd export --height [height] --for-zero-height &gt; new_genesis.json\n</code></pre>"},{"location":"protocol/state-migrate/#manually-migrate-state","title":"Manually migrate state","text":"<p>If you want to migrate state manually, e.g. for local testing purposes. Note that for regular chain upgrades, no manual state migration is required.</p> <p>After exporting state to json file, you can replace old <code>genesis.json</code> with <code>new_genesis.json</code></p> <pre><code>cp -f genesis.json new_genesis.json\nmv new_genesis.json genesis.json\n</code></pre> <p>At this point, you may want to run a script to update the exported genesis to a genesis state compatible with your new version.</p> <p>You can migrate from a given version to the next version (eg: <code>v0.X.X</code> to <code>v1.X.X</code>) using the <code>migrate</code> command:</p> <pre><code>stcd migrate TARGET_VERSION GENESIS_FILE --chain-id=&lt;new_chain_id&gt; --genesis-time=&lt;yyyy-mm-ddThh:mm:ssZ&gt;\n</code></pre>"},{"location":"protocol/transfer/","title":"Transfer","text":"<p>A transaction is an action initiated by an account that changes the state of the blockchain. In order to perform state changes efficiently, each transaction is broadcast to the entire network.</p> <p>Any node can broadcast a transaction requesting execution on the blockchain state machine; once this occurs, validators will validate, execute the transaction, and propagate the resulting state change to the rest of the network.</p> <p>To process each transaction, computing resources on the network are consumed. Thus, the concept of <code>gas</code> emerged as a reference to the computation required by a validator to process a transaction.</p> <p>Users have to pay for this computation, and all transactions have an associated fee. The fee is calculated based on the gas and gas price required to execute the transaction.</p> <p>Additionally, transactions need to be signed with the sender's private key. This proves that transactions can only come from the sender and not sent fraudulently.</p> <p>In short, the transaction life cycle after submitting a signed transaction to the network is as follows:</p> <ul> <li>Transaction hashes are cryptographically generated.</li> <li>The transaction is broadcast to the network and added to the pool of all other pending network transactions.</li> <li>A validator has to pick your transaction and include it in a block in order to validate the transaction and consider it \"successful\".</li> </ul> <p>For a more detailed explanation of the transaction lifecycle, see the corresponding section.</p> <p>A transaction hash is a unique identifier that can be used to check transaction information, for example, whether the emitted event was successful.</p> <p>Transactions can fail for various reasons. For example, the gas or fee provided may not be sufficient. Additionally, transaction validation may fail.</p> <p>Each transaction has specific conditions that must be met in order to be considered valid. A broad verification is that the sender is the transaction signer.</p> <p>In this case, if you send the transaction where the sender's address is different from the signer's address, the transaction will fail even if the fee is sufficient.</p> <p>Today, transactions can not only make state transitions on the chain they were committed to, but they can also be transacted on another blockchain.</p> <p>Inter-chain transactions can be implemented through the Inter-Blockchain Communication Protocol (IBC).</p> <p>Find a more detailed explanation in the sections below.</p>"},{"location":"protocol/transfer/#transaction-type","title":"Transaction Type","text":"<p>Daodst supports two transaction types:</p> <ol> <li>Cosmos transactions</li> <li>Ethereum transactions</li> </ol> <p>This is possible because Daodst uses the Cosmos-SDK and implements the Ethereum Virtual Machine as a module.</p> <p>In this way, Daodst provides the features and functionality of the combined Ethereum and Cosmos chains, and more.</p> <p>Although most of the information contained in these two transaction types is similar, there are differences between them.</p> <p>An important difference is that Cosmos transactions allow multiple messages to be sent in the same transaction.</p> <p>In contrast, Ethereum transactions do not have this possibility.</p> <p>To bring these two types together, Daodst implements Ethereum transactions as a single <code>sdk.Msg</code> Included in <code>auth.StdTx</code>.</p> <p>This message contains all relevant Ethereum transaction information.</p> <p>This includes signatures, gases, payloads, etc.</p> <p>Find out more about both types in the following sections.</p>"},{"location":"protocol/transfer/#cosmos-transactions","title":"Cosmos Transactions","text":"<p>On the Cosmos chain, transactions are triggered by the metadata held in the context and the <code>sdk.Msg</code> of state changes within the module through the module's Protobuf Msg service composition/message service).</p> <p>When users want to interact with the application and change state (such as sending coins), they create transactions. A Cosmos transaction can have multiple <code>sdk.Msg</code>. Before a transaction can be broadcast to the network, each of them must be signed with the private key associated with the appropriate account.</p> <p>A Cosmos transaction includes the following information:</p> <ul> <li><code>Msgs</code>: an array of messages (<code>sdk.Msg</code>)</li> <li><code>GasLimit</code>: an option chosen by the user to calculate how much gas they need to pay</li> <li><code>FeeAmount</code>: the maximum amount the user is willing to pay</li> <li><code>TimeoutHeight</code>: the effective block height of the transaction</li> <li><code>Signatures</code>: array of signatures from all signers of tx</li> <li><code>Memo</code>: notes or comments sent with the transaction</li> </ul> <p>To submit Cosmos transactions, users must use one of the provided clients.</p>"},{"location":"protocol/transfer/#ethereum-transactions","title":"Ethereum Transactions","text":"<p>An Ethereum transaction refers to an operation initiated by an EOA (externally owned account, managed by a human), not an internal smart contract call. Ethereum transactions change the state of the EVM and therefore must be broadcast to the entire network.</p> <p>Ethereum transactions also require a fee, called <code>gas</code>. (EIP-1559) introduced the concept of base fees, as well as priority fees, to incentivize miners to include specific transactions in blocks.</p> <p>Ethereum transactions are divided into several categories:</p> <ul> <li>Regular transactions: transactions from one account to another</li> <li>Contract deployment transaction: a transaction without a <code>to</code> address, the contract code is sent in the <code>data</code> field</li> <li>Execution of the contract: a transaction that interacts with the deployed smart contract, where the <code>to</code> address is the smart contract address</li> </ul> <p>An Ethereum transaction includes the following information:</p> <ul> <li><code>recipient</code>: recipient address</li> <li><code>signature</code>: the sender's signature</li> <li><code>nonce</code>: a counter from the account's tx number</li> <li><code>value</code>: Amount of ETH to transfer (in wei)</li> <li><code>data</code>: Include arbitrary data. Used when deploying smart contracts or making smart contract method calls</li> <li><code>gasLimit</code>: the maximum amount of gas to consume</li> <li><code>maxPriorityFeePerGas</code>: mas gas as validator tip</li> <li><code>maxFeePerGas</code>: the maximum amount of gas paid for tx</li> </ul> <p>For more information on Ethereum transactions and the transaction lifecycle, go here.</p> <p>Daodst supports the following Ethereum transactions.</p> <p>\ud83d\udce3 Tip : Unprotected legacy transactions are not supported by default. :::</p> <ul> <li>Dynamic fee transactions (EIP-1559)</li> <li>Access list transactions (EIP-2930)</li> <li>Legacy transactions (EIP-2718)</li> </ul> <p>Daodst is capable enough to handle them through the Ethereum transaction package on <code>sdk.Msg</code>. Daodst achieves this by using <code>MsgEthereumTx</code>. This message encapsulates the Ethereum transaction as an SDK message and contains necessary transaction data fields.</p> <p>A note about <code>MsgEthereumTx</code> is that it implements <code>sdk.Msg</code> and <code>sdk.Tx</code> interfaces at the same time (generally SDK messages only appear in the former, while the latter is a set of messages peeling off.</p> <p>The reason for this is because <code>MsgEthereumTx</code> cannot be included in <code>auth.StdTx</code> (the SDK's standard transaction type), because it uses Geth's Ethereum send instead of the Cosmos SDK `in token An.</p>"},{"location":"protocol/transfer/#inter-chain-transaction","title":"Inter-chain transaction","text":"<p>Cross-chain transactions refer to the transfer of digital assets or data between two or more different blockchain networks.</p> <p>Each blockchain network has its own unique protocols and data structures, making it difficult to transfer assets or data directly from one blockchain to another. Cross-chain transactions allow assets and data to be transferred between different blockchains by using an intermediary mechanism or protocol.</p> <p>One such mechanism is a cross-chain bridge, which acts as a connector between different blockchains, enabling the transfer of assets or data.</p> <p>Cross-chain bridges typically require some form of trust or consensus mechanism to ensure the security and integrity of transactions.</p> <p>Another possibility is to use the IBC (Inter-Blockchain Communication) protocol.</p> <p>To use IBC for cross-chain transactions, users need to:</p> <ul> <li>Select the source and target blockchain networks between which the user wants to transfer assets or data.</li> <li>Ensure that both blockchain networks implement the IBC protocol</li> <li>Ensure connection and channel between two blockchain networks using IBC</li> <li>Initiate the transfer of assets or data: this is done by sending a transaction from the source blockchain to the target blockchain through the IBC channel</li> </ul> <p>As the number of different blockchain networks and applications continues to grow, cross-chain transactions are becoming increasingly important. They support the interoperability of different blockchain networks, enabling greater flexibility and efficiency in the transfer of digital assets and data.</p>"},{"location":"protocol/transfer/#transaction-credentials","title":"Transaction Credentials","text":"<p>A transaction receipt shows the data returned by an Ethereum client to represent the outcome of a particular transaction, including the transaction's hash, block number, amount of gas used, and, in the case of a smart contract deployed, the contract address. Additionally, it includes custom information from events emitted in smart contracts.</p> <p>The receipt contains the following information:</p> <ul> <li><code>transactionHash</code>: The hash of the transaction.</li> <li><code>transactionIndex</code>: Integer of transaction index position in the block.</li> <li><code>blockHash</code>: The hash value of the block where the transaction is located.</li> <li><code>blockNumber</code>: The block number where the transaction is located.</li> <li><code>from</code>: The address of the sender.</li> <li><code>to</code>: The recipient's address. null when it is a contract creation transaction.</li> <li><code>cumulativeGasUsed</code>: The total amount of gas used when executing this transaction in the block.</li> <li><code>effectiveGasPrice</code>: The sum of the base fee and the tip paid per unit of gas.</li> <li><code>gasUsed</code>: The amount of gas used by this particular transaction only.</li> <li><code>contractAddress</code>: the address of the created contract, if the transaction is a contract creation, otherwise it is empty.</li> <li><code>logs</code>: Array of log objects generated by this transaction.</li> <li><code>logsBloom</code>: Bloom filter for light clients to quickly retrieve related logs.</li> <li><code>type</code>: integer of transaction type, 0x00 for old transaction, 0x01 for access list type,   0x02 is for dynamic fees. It also returns.</li> <li><code>root</code>: transaction state root (pre-Byzantine)</li> <li><code>status</code>: 1 (success) or 0 (failure)</li> </ul>"},{"location":"protocol/stcd/","title":"CLI","text":"<p><code>stcd</code> is an all-in-one Command Line Interface (CLI). It allows you to run Daodst chain nodes, manage wallets and interact with Daodst network through queries and transactions. This introduction will explain how to install the <code>stcd</code> binary on your system and walk you through some simple examples on how to use stcd.</p>"},{"location":"protocol/stcd/#prerequisites","title":"prerequisites","text":""},{"location":"protocol/stcd/#go","title":"Go","text":"<p>Daodst is built using Go version <code>1.20+</code>. Check your version:</p> <pre><code>go version\n</code></pre> <p>Once the correct version is installed, confirm that your <code>GOPATH</code> is properly configured by running the following command and adding it to your shell startup script:</p> <pre><code>export PATH=$PATH:$(go env GOPATH)/bin\n</code></pre>"},{"location":"protocol/stcd/#jq","title":"jq","text":"<p>Daodst scripts use jq version <code>1.6+</code>. Check your version:</p> <pre><code>jq --version\n</code></pre>"},{"location":"protocol/stcd/#install","title":"Install","text":"<p>You can build and install <code>stcd</code> binaries from source.</p>"},{"location":"protocol/stcd/#build-from-source","title":"Build from source","text":"<p>Clone and build Daodst from source using <code>git</code>. <code>&lt;tag&gt;</code> refers to the release tag on Github. Latest Daodst Version</p> <pre><code>git clone https://github.com/daodst/blockchain.git\ncd blockchain\ngit fetch\ngit checkout &lt;tag&gt;\nmake install\n</code></pre> <p>Once the installation is complete, check that the stcd binary was successfully installed:</p> <pre><code>stcd version\n</code></pre> <p>\ud83d\udce3 Tips: If a <code>stcd: command not found</code> error message is returned, please confirm that you have configured Go correctly.</p>"},{"location":"protocol/stcd/#run-daodst-node","title":"Run Daodst node","text":"<p>To get familiar with Daodst, you can run a local blockchain node to generate blocks and expose EVM and Cosmos endpoints. This allows you to deploy and interact with smart contracts locally or test core protocol functionality.</p> <p>Run local node by executing the <code>local_node.sh</code> script in the base directory of the repository:</p> <pre><code>./local_node.sh\n</code></pre> <p>This script stores node configuration, including local default endpoints under <code>~/.tmp-stcd/config/config.toml</code>. If you have run the script before, this script allows you to override the existing configuration and start a new local node.</p> <p>Once the node is running, you will see it validating and producing blocks in the local Daodst blockchain:</p> <pre><code>12:59PM INF executed block height=1 module=state num_invalid_txs=0 num_valid_txs=0 server=node\n#...\n1:00PM INF indexed block exents height=7 module=txindex server=node\n</code></pre> <p>For more information on how to customize your local node, go to the single-node page.</p>"},{"location":"protocol/stcd/#using-stcd","title":"Using <code>stcd</code>","text":"<p>After installing the <code>stcd</code> binary, you can run commands with:</p> <pre><code>stcd [command]\n</code></pre> <p>There is also a <code>-h</code>, <code>--help</code> command available</p> <pre><code>stcd -h\n</code></pre> <p>Multiple node configurations can be maintained concurrently. To specify configuration, use the <code>--home</code> flag. In the following examples we will use the default configuration of the local node located in <code>~/.tmp-stcd</code>.</p>"},{"location":"protocol/stcd/#manage-wallets","title":"Manage wallets","text":"<p>You can use the stcd binary to manage your wallet to store private keys and sign transactions via the CLI. To see all keys use:</p> <pre><code>stcd keys list \\\n--home ~/.tmp-stcd\\\n--keyring-backend test\n\n# Example Output:\n# - address: dst19xnmslvl0pcmydu4m52h2gf0std5ee5pfgpyuf\n# name: dev0\n# pubkey: '{\"@type\":\"/ethermint.crypto.v1.ethsecp256k1.PubKey\",\"key\":\"AzKouyoUL0UUS1qRUZdqyVsTPkCAFWwxx3+BTOw36nKp\"}'\n# type: local\n</code></pre> <p>You can use <code>$NAME</code> to generate a new key/mnemonic:</p> <pre><code>stcd keys add [name] \\\n--home ~/.tmp-stcd \\\n--keyring-backend test\n</code></pre> <p>Export your daodst key as an Ethereum private key for [Metamask] eg):</p> <pre><code>stcd keys unsafe-export-eth-key [name] \\\n--home ~/.tmp-stcd\\\n--keyring-backend test\n</code></pre> <p>For more information on available key commands, use the <code>--help</code> flag</p> <pre><code>stcd keys -h\n</code></pre> <p>\ud83d\udce3 Tips: For more information on Keyring and its backend options, click here. :::</p>"},{"location":"protocol/stcd/#interacting-with-the-network","title":"Interacting with the network","text":"<p>You can use stcd to query information or submit transactions on the blockchain. Queries and transactions are requests you send to Daodst nodes via Tendermint RPC.</p> <p>\ud83d\udce3 \ud83d\udc49 To use the CLI, you need to provide the Tendermint RPC address to the <code>--node</code> flag. Find publicly available addresses for testnet and mainnet in the [Networks] page.</p>"},{"location":"protocol/stcd/#set-network-configuration","title":"Set network configuration","text":"<p>In the local setup, the node is set to <code>tcp://localhost:26657</code>. You can view your node configuration with:</p> <pre><code>stcd config\\\n--home ~/.tmp-stcd\n# Example Output\n# {\n# \"chain-id\": \"daodst_7000-1\",\n# \"keyring-backend\": \"test\",\n# \"output\": \"text\",\n# \"node\": \"tcp://localhost:26657\",\n# \"broadcast-mode\": \"sync\"\n# }\n</code></pre> <p>You can set up your node configuration to send requests to a different network by changing the endpoint:</p> <pre><code>stcd config node [tendermint-rpc-endpoint] \\\n--home ~/.tmp-stcd\n</code></pre> <p>here for more node configuration.</p>"},{"location":"protocol/stcd/#inquire","title":"Inquire","text":"<p>You can use <code>stcd query</code> (or <code>stcd q</code> for short) to query information on the blockchain. Click to view account balance Addresses stored in the bank module, using:</p> <pre><code>stcd q bank balances [adress] \\\n--home ~/.tmp-stcd\n# # Example Output:\n# balances:\n# - amount: \"99999000000000000000002500\"\n# denom: dst\n</code></pre> <p>To see other available query commands, use:</p> <pre><code># for all Queries\nstcd q\n\n# for querying commands in the bank module\nstcd q bank\n</code></pre>"},{"location":"protocol/stcd/#trade","title":"trade","text":"<p>You can submit transactions to the network using <code>stcd tx</code>. This creates, signs and broadcasts the tx in one command. To use the bank module to send tokens from an account in the keyring to another address, use:</p> <pre><code>stcd tx bank send [from_key_or_address] [to_address] [amount] \\\n--home ~/.tmp-stcd \\\n--fees 50000000000dst \\\n-b block\n\n# Example Output:\n# ...\n# txhash: 7BA2618295B789CC24BB13E654D9187CDD264F61FC446EB756EAC07AF3E7C40A\n</code></pre> <p>To see other available transaction commands, use:</p> <pre><code># for all transaction commands\nstcd tx\n\n# for Bank transaction subcommands\nstcd tx bank\n</code></pre> <p>Now that you know the basics of how to run and interact with the Daodst network, go to Configuration for further customization.</p>"},{"location":"protocol/stcd/command/","title":"CLI commands","text":""},{"location":"protocol/stcd/command/#cli-flags","title":"CLI flags","text":"<p>The following is a list of commonly used flags for stcd:</p> option description type default <code>--chain-id</code> full chain ID <code>string</code> <code>\"\"</code> <code>--home</code> configuration and data directory <code>string</code> <code>directory where binaries are located/.stcd</code> <code>--keyring-backend</code> select keyring backend <code>string</code> <code>\"os\"</code> <code>--output</code> output format <code>string</code> <code>\"text\"</code> <code>--node</code> Tendermint RPC interface address <code>&lt;host&gt;:&lt;port&gt;</code> <code>\"tcp://localhost:26657\"</code> <code>--from</code> name or address of account to sign from <code>string</code> <code>\"\"</code>"},{"location":"protocol/stcd/command/#command-list","title":"command list","text":"<p>List of commonly used <code>stcd</code> commands. You can get a complete list with the <code>stcd -h</code> command.</p> command description subcommand (example) <code>keys</code> key management <code>list</code>, <code>show</code>, <code>add</code>, <code>add --recover</code>, <code>delete</code> <code>tx</code> Transaction subcommands <code>bank send</code>, <code>ibc-transfer transfer</code>, <code>distribution withdraw-all-rewards</code> <code>query</code> query subcommands <code>bank balance</code>, <code>staking validators</code>, <code>gov proposals</code> <code>tendermint</code> Tendermint subcommands <code>show-address</code>, <code>show-node-id</code>, <code>version</code> <code>config</code> Client configuration <code>init</code> Initialize daodst <code>daemon</code> start daodst <code>version</code> Daodst version <code>validate-genesis</code> Validate genesis file <code>status</code> Query remote node status"},{"location":"protocol/stcd/config/","title":"configure","text":"<p>The following pages will guide you through the configuration of nodes and clients. This node is used to run the blockchain network, produce blocks and verify transactions. Clients act as gateways, interacting with the blockchain network by sending transactions and querying state. Additionally, we introduced running the JSON-RPC server.</p> <p>These configurations affect the performance, security, and functionality of the node. Therefore, it is crucial to understand and properly configure your nodes and clients.</p>"},{"location":"protocol/stcd/config/#configuration-and-data-directories","title":"Configuration and data directories","text":"<p>By default, your configuration and data are stored in folders located in the ~/.stcd directory. You can easily change the default directory with the <code>--home</code> flag. It's important to note that you can have multiple home directories, each representing a different blockchain.</p> <pre><code>.# ~/.stcd\n   \u251c\u2500\u2500 data/ # Contains the databases used by the node.\n   \u2514\u2500\u2500 config/\n       \u251c\u2500\u2500 app.toml # Application-related configuration file.\n       \u251c\u2500\u2500 config.toml # Tendermint-related configuration file.\n       \u251c\u2500\u2500 genesis.json # The genesis file.\n       \u251c\u2500\u2500 node_key.json # Private key to use for node authentication in the p2p protocol.\n       \u2514\u2500\u2500 priv_validator_key.json # Private key to use as a validator in the consensus protocol.\n</code></pre> <p>Specifies the <code>stcd</code> configuration and data storage directory; you can update it with the global flag <code>--home &lt;directory&gt;</code>.</p>"},{"location":"protocol/stcd/config/#node-configuration","title":"node configuration","text":"<p>The Cosmos SDK automatically generates two configuration files in <code>~/.stcd/config</code>:</p> <ul> <li><code>config.toml</code>: used to configure Tendermint, read more in Tendermint's documentation, - <code>app .toml</code> : Generated by the Cosmos SDK to configure your application, such as state pruning strategies, telemetry, gRPC and REST server configuration, state sync, JSON-RPC, etc.</li> </ul> <p>Both files are heavily commented, please refer to them directly to tune your node.</p> <p>An example configuration to tune is the <code>minimum-gas-prices</code> field in <code>app.toml</code>, which defines the minimum amount a validator is willing to accept in order to process a transaction. This is an anti-spam mechanism that will reject incoming transactions below a minimum gas price.</p> <p>If it's empty, make sure to edit the field with some value, such as <code>0dst</code>, otherwise the node will stop on startup.</p> <pre><code> # The minimum gas prices a validator is willing to accept for processing a\n # transaction. A transaction's fees must meet the minimum of any denomination\n # specified in this config (e.g. 0.25token1;0.0001token2).\n minimum-gas-prices = \"0dst\"\n</code></pre>"},{"location":"protocol/stcd/config/#state-pruning","title":"State pruning","text":"<p>There are four strategies for pruning state. These policies only apply to state, not to block storage. To set up pruning, adjust the <code>pruning</code> parameter in the <code>~/.stcd/config/app.toml</code> file. The following trim state settings are available:</p> <ul> <li><code>everything</code>: Prune all saved states except the current state.</li> <li><code>nothing</code>: save all state, do not delete anything.</li> <li><code>default</code>: Save the last 100 states and the state every 10,000 blocks.</li> <li><code>custom</code>: Use <code>pruning-keep-recent</code>, <code>pruning-keep-every</code>, and <code>pruning-interval</code> parameters to specify pruning settings.</li> </ul> <p>By default, each node is in <code>default</code> mode, which is the recommended setting for most environments. If you want to change your node pruning strategy, then you must do so at node initialization time. Passing a flag when starting <code>daodst</code> will always override the setting in the <code>app.toml</code> file, if you want to change the node to <code>everything</code> mode, then you can pass the <code>--pruning everything</code> flag when calling <code>stcd stc-start</code>.</p> <p>\ud83d\udea8 Dangerous: When you trim the state, you won't be able to query the height that has been trimmed off.</p>"},{"location":"protocol/stcd/config/#client-configuration","title":"Client Configuration","text":"<p>We can view the default client configuration settings with the <code>stcd config</code> command:</p> <pre><code>stcd config\n{\n  \"chain-id\": \"\",\n  \"keyring-backend\": \"os\",\n  \"output\": \"text\",\n  \"node\": \"tcp://localhost:26657\",\n  \"broadcast-mode\": \"sync\"\n}\n</code></pre> <p>We can make changes to the default settings according to our choice, so it allows the user to pre-set all configurations at once, so that the same configuration can be used afterwards.</p> <p>For example, the chain identifier can be changed from a blank name to <code>daodst_7000-1</code> with the following command:</p> <pre><code>stcd config \"chain-id\" daodst_7000-1\nstcd config\n{\n \"chain-id\": \"daodst_7000-1\",\n \"keyring-backend\": \"os\",\n \"output\": \"text\",\n \"node\": \"tcp://localhost:26657\",\n \"broadcast-mode\": \"sync\"\n}\n</code></pre> <p>Other values can be changed in the same way.</p> <p>Alternatively, we can directly change configuration values in one place in client.toml .</p> <p>Under the <code>.stcd/config/client.toml</code> path in the folder where we installed daodst:</p> <pre><code>############################################################################\n### Client Configuration ###\n\n############################################################################\n\n# The network chain ID\n\nchain-id = \"daodst_7000-1\"\n\n# The keyring's backend, where the keys are stored (os|file|kwallet|pass|test|memory)\n\nkeyring-backend = \"os\"\n\n# CLI output format (text|json)\n\noutput = \"number\"\n\n# &lt;host&gt;:&lt;port&gt; to Tendermint RPC interface for this chain\n\nnode = \"tcp://localhost:26657\"\n\n# Transaction broadcasting mode (sync|async|block)\n\nbroadcast-mode = \"sync\"\n</code></pre> <p>After making the necessary changes in <code>client.toml</code>, then save. For example, if we directly change the chain-id from <code>daodst_7000-1</code> to <code>daodst_7000-2</code> and output it as a number, it will instantly change as shown below.</p> <pre><code>stcd config\n{\n \"chain-id\": \"daodst_7000-2\",\n \"keyring-backend\": \"os\",\n \"output\": \"number\",\n \"node\": \"tcp://localhost:26657\",\n \"broadcast-mode\": \"sync\"\n}\n</code></pre>"},{"location":"protocol/stcd/config/#run-the-json-rpc-server","title":"Run the JSON-RPC server","text":"<p>This section describes the steps to enable a JSON-RPC server. JSON-RPC is provided over several transports. Daodst supports JSON-RPC over HTTP and WebSocket. In terms of requirements, we recommend a server with at least an 8-core CPU and 64GB of RAM. You must open ports 8545 and 8546 on your firewall.</p> <p>\ud83d\udce3 Tip: Unless your nodes store an entire copy of the blockchain locally, you cannot use all JSON RPC methods. Do you need an archive/snapshot of our network? Go to this section.</p>"},{"location":"protocol/stcd/config/#enable-server","title":"Enable server","text":"<p>To enable the RPC server, use the following flag (set to true by default).</p> <pre><code>stcd start --json-rpc.enable\n</code></pre>"},{"location":"protocol/stcd/config/#define-the-namespace","title":"Define the namespace","text":"<p><code>Eth</code>, <code>Net</code> and <code>Web3</code> namespaces are enabled by default, but for JSON-RPC you need to add more namespaces. In order to enable additional namespaces, edit the app.toml file.</p> <pre><code># API defines a list of JSON-RPC namespaces that should be enabled\n# Example: \"eth,txpool,personal,net,debug,web3\"\napi = \"eth,net,web3,txpool,debug,personal\"\n</code></pre>"},{"location":"protocol/stcd/config/#set-a-gas-amount","title":"Set a Gas amount","text":"<p><code>eth_call</code> and <code>eth_estimateGas</code> define a global gas cap over rpc for DoS protection. You can override the default gas cap value of 25,000,000 by passing a custom value in app.toml:</p> <pre><code># GasCap sets a cap on gas that can be used in eth_call/estimateGas (0=infinite). Default: 25,000,000.\ngas-cap = 25000000\n</code></pre>"},{"location":"protocol/stcd/config/#cors","title":"CORS","text":"<p>If accessing RPC from a browser, you need to enable CORS with the appropriate domain set. Otherwise, JavaScript calls are restricted by the same-origin policy and the request will fail.</p> <p>CORS settings can be updated from <code>app.toml</code></p> <pre><code>###############################################################################\n###                           API Configuration                             ###\n###############################################################################\n\n[api]\n\n# ...\n\n# EnableUnsafeCORS defines if CORS should be enabled (unsafe - use it at your own risk).\nenabled-unsafe-cors = true # default false\n</code></pre>"},{"location":"protocol/stcd/config/#prune","title":"prune","text":"<p>In order for all methods to work, your node must be archival (storing an entire copy of the blockchain locally). Trimming must be disabled. Prune settings can be updated from <code>app.toml</code></p> <pre><code>###############################################################################\n###                           Base Configuration                            ###\n###############################################################################\n\n# The minimum gas prices a validator is willing to accept for processing a\n# transaction. A transaction's fees must meet the minimum of any denomination\n# specified in this config (e.g. 0.25token1;0.0001token2).\n\n# ...\n\n# default: the last 100 states are kept in addition to every 500th state; pruning at 10 block intervals\n# nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)\n# everything: all saved states will be deleted, storing only the current state; pruning at 10 block intervals\n# custom: allow pruning options to be manually specified through 'pruning-keep-recent', 'pruning-keep-every', &gt;\npruning = \"nothing\"\npruning-keep-recent = \"0\"\npruning-keep-every = \"0\"\npruning-interval = \"0\"\n</code></pre>"},{"location":"protocol/stcd/config/#websocket-server","title":"WebSocket server","text":"<p>Websocket is a two-way transport protocol. A Websocket connection is maintained by both client and server until it is explicitly terminated by one. Most modern browsers support Websockets, which means it has good tools.</p> <p>Because Websockets are bidirectional, the server can push events to the client. This makes Websockets a good choice for use cases involving event subscriptions. Another benefit of Websockets is the low overhead of a single message after the handshake process, making it ideal for sending large numbers of requests. WebSocket server can be enabled from <code>app.toml</code></p> <pre><code># Address defines the EVM WebSocket server address to bind to.\nws-address = \"0.0.0.0:8546\"\n</code></pre>"},{"location":"protocol/stcd/single-node/","title":"single node","text":"<p>After this page, you can run a single-node local network manually or with an already prepared automated script. Running a single-node setup is useful for developers who want to test the functionality of their applications and protocols because of its simplicity and speed. For more complex setups, please refer to the Multi-node setup page.</p>"},{"location":"protocol/stcd/single-node/#prerequisites","title":"prerequisites","text":"<ul> <li>Install</li> </ul>"},{"location":"protocol/stcd/single-node/#automation-script","title":"Automation script","text":"<p>The easiest way to start a local Daodst node is to use the provided helper script, which will create a sensible default configuration for testing purposes:</p> <pre><code>$ local_node.sh\n...\n</code></pre> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>\ud83d\udce3 Tips: To avoid overwriting any data from real nodes used in production, it was decided to store the auto-generated test configuration in <code>~/.tmp-stcd</code> instead of the default <code>$install_path/.stcd</code>.</p> <p>When using the <code>local_node.sh</code> script, it is necessary to extend all <code>stcd</code> commands targeting the local test node with the <code>--home ~/.tmp-stcd</code> flag. This is mandatory because the <code>home</code> directory cannot be stored in the <code>stcd</code> configuration, which can be seen in the output below. For ease of use, it may be wise to export this directory path as an environment variable:</p> <pre><code>$ export TMP=$HOME/.tmp-stcd`\n$ stcd config --home $TMP\n{\n\"chain-id\": \"daodst_7000-1\",\n\"keyring-backend\": \"test\",\n\"output\": \"text\",\n\"node\": \"tcp://localhost:26657\",\n\"broadcast-mode\": \"sync\"\n}\n</code></pre> <p>You can customize local node scripts by changing configuration variables. See the following script excerpt for ideas on what can be adjusted:</p> <pre><code># Customize the name of your keys, the chain-id, moniker of the node, keyring backend, and more\nKEYS[0]=\"dev0\"\nKEYS[1]=\"dev1\"\nKEYS[2]=\"dev2\"\nCHAINID=\"daodst_7000-1\"\nMONIKER=\"localtestnet\"\n# Remember to change to other types of keyring like 'file' in-case exposing to outside world,\n# otherwise your balance will be wiped quickly\n# The keyring test does not require private key to steal tokens from you\nKEYRING=\"test\"\nKEYALGO=\"eth_secp256k1\"\nLOGLEVEL=\"info\"\n# Set dedicated home directory for the stcd instance\nHOMEDIR=\"$HOME/.tmp-stcd\"\n# to trace evm\n#TRACE=\"--trace\"\nTRACE=\"\"\n\n[...]\n\n  # Adjust this set a different maximum gas limit\n  jq '.consensus_params[\"block\"][\"max_gas\"]=\"10000000\"' \"$GENESIS\" &gt;\"$TMP_GENESIS\" &amp;&amp; mv \"$TMP_GENESIS\" \"$GENESIS\"\n\n[...]\n\n</code></pre>"},{"location":"protocol/stcd/single-node/#manual-deployment","title":"Manual deployment","text":"<p>This guide helps you create a single validator node that runs the network locally for testing and other development-related purposes.</p>"},{"location":"protocol/stcd/single-node/#initialize-the-chain","title":"Initialize the chain","text":"<p>Before actually running the node, we need to initialize the chain, most importantly its genesis file. This is done with the <code>init</code> subcommand:</p> <pre><code>$MONIKER=testing\n$KEY=dev0\n$CHAINID=\"daodst_7000-1\"\n\n# The argument $MONIKER is the custom username of your node, it should be human-readable.\nstcd init $MONIKER --chain-id=$CHAINID\n</code></pre> <p>\ud83d\udce3 Tips: You can modify this moniker later by updating the <code>config.toml</code> file.</p> <p>The command above creates all the configuration files your node and validators need to run, as well as a default genesis file which defines the initial state of the network. By default all these configuration files are in <code>~/.stcd</code>, but you can override the location of this folder by passing the <code>--home</code> flag.</p>"},{"location":"protocol/stcd/single-node/#genesis-program","title":"Genesis program","text":""},{"location":"protocol/stcd/single-node/#add-genesis-account","title":"Add genesis account","text":"<p>Before starting the chain, you need to populate the state with at least one account using keyring:</p> <pre><code>stcd keys add my_validator\n</code></pre> <p>After creating the local account, go ahead and grant it some <code>dst</code> tokens in the chain's genesis file. Doing this will also ensure your chain is aware of the existence of this account:</p> <pre><code>stcd add-genesis-account my_validator 10000000000dst\n</code></pre> <p>Now that your account has some tokens, you need to add a validator to your chain.</p> <p>For this guide, you will add your local node (created via the <code>init</code> command above) as a validator for the chain. Validators can be claimed via a special transaction called <code>gentx</code> included in the genesis file before the chain is first launched:</p> <pre><code># Create a gentx\n# NOTE: this command lets you set the number of coins.\n# Make sure this account has some coins with the genesis.app_state.staking.params.bond_denom denom\nstcd add-genesis-account my_validator 1000000000dst,10000000000fm\n</code></pre> <p><code>gentx</code> does three things:</p> <ol> <li>Register the <code>validator</code> account you created as the validator operator account (that is, the account that controls the validator).</li> <li>Delegate the pledged tokens of the provided <code>amount</code> by yourself.</li> <li>Associate the operator account with the Tendermint node public key that will be used to sign blocks. If the <code>--pubkey</code> flag is not provided, it defaults to the local node pubkey created via the <code>stcd init</code> command above.</li> </ol> <p>For more information on <code>gentx</code>, use the following command:</p> <pre><code>stcd gentx --help\n</code></pre>"},{"location":"protocol/stcd/single-node/#collect-gentx","title":"Collect <code>gentx</code>","text":"<p>By default, the genesis file does not contain any <code>gentxs</code>. <code>gentx</code> is a transaction that binds staked tokens present in the genesis file under <code>accounts</code> to a validator, essentially creating a validator at genesis. The chain starts once more than 2/3 validators (weighted by voting power) that are valid <code>gentx</code> recipients come online after <code>genesis_time</code>.</p> <p><code>gentx</code> can be added manually to the genesis file, or via the following command:</p> <pre><code># Add the gentx to the genesis file\nstcd collect-gentxs\n</code></pre> <p>This command will add all <code>gentxs</code> stored in <code>~/.stcd/config/gentx</code> to the genesis file.</p>"},{"location":"protocol/stcd/single-node/#daemon-running-single-node","title":"daemon running single node","text":"<p>Finally, check the <code>genesis.json</code> file for correctness:</p> <pre><code>stcd validate-genesis\n</code></pre> <p>Now that everything is set up, you can finally start your node:</p> <pre><code>stcd daemon\n</code></pre> <p>\ud83d\udce3 Tips: To inspect all available customizable options when running node, use the --help flag.</p> <p>You should see blocks coming in.</p> <p>The preceding commands allow you to run a single node. This is enough for the next section about interacting with this node, But you might want to run multiple nodes at the same time and see how consensus is reached between them.</p> <p>You can then stop the node with <code>Ctrl+C</code>.</p>"},{"location":"protocol/stcd/single-node/#further-configuration","title":"Further configuration","text":""},{"location":"protocol/stcd/single-node/#key-management","title":"Key Management","text":"<p>Run node with the same key each time: replace <code>stcd keys add $KEY</code> in <code>./local_node.sh</code> with:</p> <pre><code>echo \"your mnemonic here\" | stcd keys add $KEY --recover\n</code></pre> <p>\ud83d\udce3 Tips: Daodst currently supports 12-word mnemonics. :::</p> <p>You can generate a new key/mnemonic using:</p> <pre><code>stcd keys add $KEY\n</code></pre> <p>Export your Daodst key as an Ethereum private key (for Metamask for example):</p> <pre><code>stcd keys unsafe-export-eth-key $KEY\n</code></pre> <p>For more information on available key commands, use the <code>--help</code> flag</p> <pre><code>stcd keys -h\n</code></pre>"},{"location":"protocol/stcd/single-node/#keyring-backend-options","title":"Keyring backend options","text":"<p>The instructions above include the command to use <code>test</code> as <code>keyring-backend</code>. This is an insecure keyring that does not require a password and should not be used in production. Otherwise, Daodst supports using file or OS keyring backends for key storage. To create and use a file to store keys instead of the default operating system keyring, add the flag <code>--keyring-backend file</code> to any relevant command and a password prompt will appear via the command line. This can also be saved as a CLI configuration option:</p> <pre><code>stcd config keyring-backend file\n</code></pre> <p>\ud83d\udce3 Tips: For more information on Keyring and its backend options, click here.</p>"},{"location":"protocol/stcd/single-node/#enable-tracing","title":"Enable tracing","text":"<p>To enable tracing while running node, modify the last line of the <code>local_node.sh</code> script to the following command, Where:</p> <ul> <li><code>$TRACER</code> is the EVM tracer type used to collect execution traces from EVM transaction executions (e.g. <code>json|struct|access_list|markdown</code>)</li> <li><code>$TRACESTORE</code> is the output file containing the KVStore trace (e.g. <code>store.txt</code>)</li> </ul> <pre><code>stcd start --evm.tracer $TRACER --tracestore $TRACESTORE --pruning=nothing $TRACE --log_level $LOGLEVEL --minimum-gas-prices=0.0001dst --json-rpc.api eth,txpool,personal,net ,debug,web3\n</code></pre>"},{"location":"protocol/stcd/single-node/#clear-data-from-the-chain","title":"Clear data from the chain","text":""},{"location":"protocol/stcd/single-node/#reset-data","title":"Reset Data","text":"<p>Alternatively, you can reset the blockchain database, delete the node's address book file, and reset <code>priv_validator.json</code> to the genesis state.</p> <p>\ud83d\udce3 Tips: Always be careful when doing <code>stcd unsafe-reset-all</code> if you are running a validator node. If you don't switch <code>chain-id</code>, you should never use this command.</p> <p>\ud83d\udea8 DANGER: Make sure each node has a unique <code>priv_validator.json</code>. DO NOT copy <code>priv_validator.json</code> from old nodes to multiple new nodes. Running two nodes with the same <code>priv_validator.json</code> will result in you dual signing and will be permanently jailed!</p> <p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>First, delete obsolete files and reset data.</p> <pre><code>rm $install_path/.stcd/config/addrbook.json $install_path/.stcd/config/genesis.json\nstcd tendermint unsafe-reset-all --home .stcd\n</code></pre> <p>Your node is now in pristine state, while keeping the original <code>priv_validator.json</code> and <code>config.toml</code>. If you previously set up any sentinel nodes or full nodes, your nodes will still attempt to connect to them, but may fail if they have not been upgraded.</p>"},{"location":"protocol/stcd/single-node/#delete-data","title":"delete data","text":"<p>Binaries are stored in <code>$install_path/.stcd</code> by default, to remove existing binaries and configurations, run:</p> <pre><code>rm -rf $install_path/.stcd\n</code></pre> <p>To clear all data except the keystore (if the keyring backend is selected), you can then re-run the full node install command from above to start the node again.</p>"},{"location":"protocol/stcd/single-node/#transactions-per-second-tps","title":"Transactions per second (TPS)","text":"<p>To get a cumulative value of transactions per second, we use the Prometheus return value. The Prometheus exporter runs at address http://localhost:8877, so add this section to your Prometheus installation config.yaml file ,As follows</p> <pre><code>global:\nscrape_interval: 10s\n\nexternal_labels:\n   monitor: 'daodst'\n\nscrape_configs:\n- job_name: 'daodst'\n\n   scrape_interval: 10s\n\n   static_configs:\n     - targets: ['localhost:8877']\n</code></pre> <p>Then run Prometheus like this</p> <pre><code>prometheus --config.file=prom_config.yaml\n</code></pre> <p>Then visit the Prometheus dashboard at http://localhost:9090/ and navigate to the expression area and enter the following expression</p> <pre><code>rate(daodst_transactions_processed[1m])\n</code></pre> <p>This will show the speed at which transactions are processed.</p> <p>\ud83d\udce3 Tips: Daodst currently supports 12-word mnemonics.</p>"},{"location":"ttts/ttts/","title":"TTTS Service","text":"<p>TTTS\uff1aTranslation and Text-to-Speech. The TTTS service is configured to be enabled and controlled through the config.toml--&gt;ttts.enabled option under the gateway service.</p>"},{"location":"ttts/ttts/#preconditions","title":"Preconditions","text":"<p>The TTTS service internally relies on python's numpy module, which requires a VC++ compilation environment. An installation program named vs_BuildTools.exe is included in the ttts directory of the Windows version. Double-click to run and check as shown below:</p> <p></p> <p>After the installation is complete, you can modify the configuration items to start the TTTS service and wait for the service initialization to complete.</p> <p>Note: Since the Linux version is easier to install in the vc++ environment than Windows, you can directly modify the configuration items and start the service (dependencies will be installed automatically).</p>"},{"location":"upgrade/","title":"Overview","text":"<p>Learn how to manage chain upgrades for full nodes and validators. There are 3 different upgrade categories:</p> <ul> <li>Planned or Unplanned: Chained upgrades can be scheduled at a given height via upgrade proposals.</li> <li>BREAKING OR NON-BREAKING: Upgrades can be API or state machine breaking, which affects backwards compatibility.   To fix this, the application state or genesis files need to be migrated in preparation for the upgrade.</li> <li>DATA RESET UPGRADE: Some upgrades require a full data reset to clear the state. This sometimes happens with rollbacks or hard forks.</li> </ul> <p>Additionally, validators can choose how upgrades are managed according to their preferences:</p> <ul> <li>Automatic or manual upgrades: Validators can run the <code>cosmovisor</code> process to perform upgrades automatically or manually.</li> </ul>"},{"location":"upgrade/#plan-to-upgrade","title":"Plan to upgrade","text":"<p>A planned upgrade is a coordinated planned upgrade using the logic of the upgrade module. This facilitates smooth upgrades of Daodst to new (broken) software versions, as it automatically handles state migration for new versions.</p>"},{"location":"upgrade/#governance-proposal","title":"Governance Proposal","text":""},{"location":"upgrade/#governance-proposal_1","title":"Governance Proposal","text":"<p>Governance proposals are a mechanism to coordinate upgrades at a given height or time using <code>SoftwareProposal</code>.</p> <p>\ud83d\udce3 Tips: All governance proposals, including software upgrades, will need to wait until the voting period ends before the upgrade can be implemented. Please consider this duration when submitting software upgrade proposals.</p> <p>If the proposal is passed, the upgrade <code>plan</code> for the specific upgrade logic to migrate the state will be persisted to the blockchain state and scheduled at a given upgrade height. Upgrades can be delayed or accelerated by updating <code>Plan.Height</code> in new proposals.</p>"},{"location":"upgrade/#hard-fork","title":"Hard Fork","text":"<p>A special type of planned upgrade is a hard-fork. In contrast to governance proposals, hard forks do not need to wait for the entire voting period. This makes them ideal for coordinating security holes and patches.</p> <p>The upgraded (forked) block height is set in the application's <code>BeginBlock</code> (i.e. before processing transactions for the block). Once the blockchain reaches that height, it automatically schedules an upgrade \"schedule\" for the same height, which then triggers the upgrade process. After the upgrade, block operations (<code>BeginBlock</code>, transaction processing, and state <code>Commit</code>) continue to proceed normally.</p> <p>\ud83d\udce3 Tips: In order to perform an upgrade hard fork, one needs to first release patch-versions using the <code>BeginBlock</code> upgrade scheduling logic. After +2/3 of the validators have upgraded to the new patch version, their nodes will automatically stop and upgrade the binaries.</p>"},{"location":"upgrade/#unplanned-upgrades","title":"Unplanned upgrades","text":"<p>An unplanned upgrade is one in which all validators need to gracefully stop and shut down their nodes at the same point in the process. This can be done by setting the <code>--halt-height</code> flag when running the <code>stcd start</code> command.</p> <p>If breaking changes occur during an unplanned upgrade (see below), validators will need to migrate state and origins before restarting their nodes.</p> <p>\ud83d\udce3 Tips: The main considerations for unplanned upgrades are the need to export the genesis state and the need to [reset] (#data-reset-upgrades) the blockchain data. This primarily affects infrastructure providers, tools, and clients such as block explorers and clients that must use archive nodes to serve queries for pre-upgrade heights.</p>"},{"location":"upgrade/#destructive-and-non-destructive-upgrades","title":"Destructive and non-destructive upgrades","text":"<p>Upgrades can be classified as breaking or non-breaking/releases according to the semantic versioning (Semver) of the corresponding software release version )(ie <code>vX.Y.Z</code>):</p> <ul> <li>Major Version (<code>X</code>): Backwards incompatible API and state machine breaking changes.</li> <li>Minor Version (<code>Y</code>): New backward compatibility features. These may also be state machine interrupts.</li> <li>Patch Release (<code>Z</code>): Backward compatible bug fixes, minor refactorings and improvements.</li> </ul>"},{"location":"upgrade/#major-versions","title":"Major Versions","text":"<p>If the new version you are upgrading to has breaking changes, you will have to:</p> <ol> <li>Migrating Genesis JSON</li> <li>Migrate application state</li> <li>Restart the node</li> </ol> <p>This is required to prevent double-signing or stopping the chain during consensus.</p> <p>To upgrade the genesis file, you can obtain it from a trusted source, or export it locally using the <code>stcd export</code> command.</p>"},{"location":"upgrade/#minor-version","title":"Minor version","text":"<p>If the new version you are upgrading to has breaking changes, you will have to:</p> <ol> <li>Migration status (if applicable)</li> <li>Restart the node</li> </ol>"},{"location":"upgrade/#patch-version","title":"Patch version","text":"<p>In order to update the patch:</p> <ol> <li>Stop the node</li> <li>Manually download the new release binaries<ol> <li>Restart the node</li> </ol> </li> </ol>"},{"location":"upgrade/#data-reset-upgrade","title":"Data reset upgrade","text":"<p>Data reset upgrades require node operators to completely reset the blockchain state and restart their nodes from a clean state, but with the same validator keys.</p>"},{"location":"upgrade/#automatic-or-manual-upgrade","title":"Automatic or manual upgrade","text":"<p>For each new software release, we strongly recommend that full node and validator operators perform a software upgrade.</p> <p>You can upgrade your node in any of the following ways:</p> <ul> <li>auto upgrades the software version and restarts the node after the upgrade occurs, or</li> <li>Download the new binaries and perform a manual upgrade</li> </ul> <p>Follow the links in the options above to learn how to upgrade your node according to your preferred option.</p>"},{"location":"upgrade/auto/","title":"auto update","text":"<p>We strongly recommend that validators use Cosmovisor to run their nodes. This will allow for smoother upgrades with low downtime, since validators don't have to manually upgrade binaries during upgrades. Instead, users can pre-install new binaries and Cosmovisor will automatically update them based on on-chain software upgrade recommendations.</p> <p><code>cosmovisor</code> is a small process manager for Cosmos SDK application binaries, a governance module that monitors incoming chain upgrade proposals.</p> <p>If it sees a proposal approved, cosmovisor can automatically download the new binary, stop the current binary, switch from the old binary to the new binary, and finally replace the new binary with the new binary. file to restart the node.</p>"},{"location":"upgrade/auto/#prerequisites","title":"prerequisites","text":"<ul> <li>Install Cosmovisor</li> </ul>"},{"location":"upgrade/auto/#1-configure-cosmovisor","title":"1. Configure Cosmovisor","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>Set Cosmovisor environment variables. We recommend setting these in your <code>.profile</code> so that they are set automatically on each session.</p> <pre><code>echo \"# Setup Cosmovisor\" &gt;&gt; ~/.profile\necho \"export DAEMON_NAME=stcd\" &gt;&gt; ~/.profile\necho \"export DAEMON_HOME=$install_path/.stcd\" &gt;&gt; ~/.profile\nsource ~/.profile\n</code></pre> <p>After this, you must create the necessary folders for <code>cosmosvisor</code> in your <code>DAEMON_HOME</code> directory ($install_path/.stcd`) and copy the current binaries.</p> <pre><code>mkdir -p $install_path/.stcd/cosmovisor\nmkdir -p $install_path/.stcd/cosmovisor/genesis\nmkdir -p $install_path/.stcd/cosmovisor/genesis/bin\nmkdir -p $install_path/.stcd/cosmovisor/upgrades\n\ncp $GOPATH/bin/stcd $install_path/.stcd/cosmovisor/genesis/bin\n</code></pre> <p>To check that you are doing this correctly, make sure your <code>cosmovisor</code> and <code>stcd</code> versions are the same:</p> <pre><code>cosmovisor run version\nstcd version\n</code></pre>"},{"location":"upgrade/auto/#2-download-daodst-version","title":"2. Download Daodst version","text":""},{"location":"upgrade/auto/#manual-download","title":"Manual download","text":"<p>Cosmovisor will constantly poll <code>$DAEMON_HOME/data/upgrade-info.json</code> for new upgrade instructions. When upgrading, node operators need to:</p> <ol> <li>Download (NOT INSTALLED) the binaries for the new version</li> <li>Put it under <code>$DAEMON_HOME/cosmovisor/upgrades/&lt;name&gt;/bin</code>, where <code>&lt;name&gt;</code> is the URI-encoded name of the upgrade specified in the software upgrade plan.</li> </ol> <p>Example: For a <code>plan</code> named <code>v3.0.0</code> and the following <code>upgrade-info.json</code>:</p> <pre><code>{\n     \"binaries\": {\n         \"linux/arm64\": \"https://github.com/daodst/blockchain/releases/download/v3.0.0/daodst_3.0.0_Linux_arm64.tar.gz\",\n         \"linux/amd64\": \"https://github.com/daodst/blockchain/releases/download/v3.0.0/daodst_3.0.0_Linux_amd64.tar.gz\",\n         \"windows/x86_64\": \"https://github.com/daodst/blockchain/releases/download/v3.0.0/daodst_3.0.0_Windows_x86_64.zip\"\n     }\n}\n</code></pre> <p>Your <code>cosmovisor/</code> directory should look like this:</p> <pre><code>cosmovisor/\n\u251c\u2500\u2500 current/ # either genesis or upgrades/&lt;name&gt;\n\u251c\u2500\u2500 genesis\n\u2502 \u2514\u2500\u2500 bin\n\u2502 \u2514\u2500\u2500 stcd\n\u2514\u2500\u2500 upgrades\n     \u2514\u2500\u2500 v3.0.0\n         \u251c\u2500\u2500 bin\n         \u2502 \u2514\u2500\u2500 stcd\n         \u2514\u2500\u2500 upgrade-info.json\n</code></pre>"},{"location":"upgrade/auto/#automatic-download","title":"Automatic download","text":"<p>\u26a0\ufe0f NOTE : Automatic downloads do not verify in advance that binaries are available. If there is any problem downloading the binary, <code>cosmovisor</code> will stop and not restart the chain (which might cause it to stop).</p> <p>It is possible to have Cosmovisor auto-download new binaries. Validators can use the automatic download option to prevent unnecessary downtime during upgrades.</p> <p>This option will automatically restart the chain with the upgrade binary once the chain stops at the recommended upgrade-height.</p> <p>The main benefit of this option is that validators can prepare upgrade binaries ahead of time and then relax while upgrading.</p> <p>To set up automatic downloads use set the following environment variables:</p> <pre><code>echo \"export DAEMON_ALLOW_DOWNLOAD_BINARIES=true\" &gt;&gt; ~/.profile\n</code></pre>"},{"location":"upgrade/auto/#3-start-your-node","title":"3. Start your node","text":"<p>Now everything is set up and ready to go, you can start your node.</p> <pre><code>cosmovisor run start\n</code></pre> <p>You're going to need some way to keep the process running all the time. If you are on linux you can do this by creating a service.</p> <pre><code>sudo tee /etc/systemd/system/stcd.service &gt; /dev/null &lt;&lt;EOF\n[Unit]\nDescription=Daodst Chain Daemon\nAfter=network-online.target\n\n[Service]\nUser=$USER\nExecStart=$(which cosmovisor) start\nRestart=always\nRestartSec=3\nLimitNOFILE=infinity\n\nEnvironment=\"DAEMON_HOME=$HOME/.stcd\"\nEnvironment=\"DAEMON_NAME=stcd\"\nEnvironment=\"DAEMON_ALLOW_DOWNLOAD_BINARIES=false\"\nEnvironment=\"DAEMON_RESTART_AFTER_UPGRADE=true\"\n\n[Install]\nWantedBy=multi-user.target\nEOF\n</code></pre> <p>Then update and start the node</p> <pre><code>sudo -S systemctl daemon-reload\nsudo -S systemctl enable stcd\nsudo -S systemctl start stcd\n</code></pre> <p>You can check the status with:</p> <pre><code>systemctl status stcd\n</code></pre>"},{"location":"upgrade/hard-fork/","title":"hard fork upgrade","text":"<p>One of the significant limitations of the normal upgrade procedure via governance is that it needs to wait for the entire voting period.</p> <p>This duration makes it unsuitable for automated upgrades involving patches for security vulnerabilities or other critical components.</p> <p>A faster alternative to using governance is to create a hard fork procedure. This process automatically applies changes to upgrade plans, allowing them to execute at a given block height without creating a governance proposal.</p> <p>The high-level strategy for coordinated upgrades is as follows:</p> <ol> <li>Bugfixes are on private branches that contain breaking changes.</li> <li>Need to create a new patch release (e.g. <code>v8.0.0</code> -&gt; <code>v8.0.1</code>) which contains the hard fork logic and performs upgrades to the next breaking version (e.g. <code>v9.0.0</code>) pre-defined blocks high.</li> <li>Validators upgrade their nodes to a patched version (eg \"v8.0.1\").    In order to successfully perform a hard fork, it is important that enough validators upgrade to the patched version such that they represent at least 2/3 of the total validator voting power.</li> <li>One hour before the upgrade time (corresponding to the upgrade block height), a new main version (such as <code>v9.0.0</code>) containing bug fixes will be released.</li> </ol> <p>IMPORTANT: Posts need to be created 1 hour in advance because It takes about 30 minutes to create release binaries, validators need buffer time to download them and update them cosmovisor setting.</p>"},{"location":"upgrade/list/","title":"upgrade list","text":"<p>Check the details and requirements for each mainnet and testnet upgrade.</p>"},{"location":"upgrade/list/#mainnet","title":"Mainnet","text":"Version Planned Outage Data Reset Manual Upgrade Only Upgrade Height <code>v1.0.0</code> (genesis) <code>N/A</code> <code>N/A</code> <code>N/A</code> \u274c 1"},{"location":"upgrade/list/#test-network","title":"Test network","text":"Version Planned Outage Data Reset Manual Upgrade Only Upgrade Height <code>v1.0.0-beta1</code> (genesis) <code>N/A</code> <code>N/A</code> <code>N/A</code> \u274c 1"},{"location":"upgrade/manual/","title":"Manual upgrade","text":"<p>Learn how to manually upgrade your nodes.</p>"},{"location":"upgrade/manual/#prerequisites","title":"prerequisites","text":"<ul> <li>install stcd</li> </ul>"},{"location":"upgrade/manual/#1-upgrade-daodst-version","title":"1. Upgrade Daodst version","text":"<p>Before upgrading Daodst version. Stop your daodst instance with <code>Ctrl/Cmd+C</code>.</p> <p>Next, upgrade the software to the desired release version. Check out Daodst release page Details about each release.</p> <p>\u26a0\ufe0f NOTE : Make sure the version installed matches the version required for the network you are running (mainnet or testnet).</p> <pre><code>cd blockchain\ngit fetch --all &amp;&amp; git checkout &lt;new_version&gt;\nmake install\n</code></pre> <p>\ud83d\udce3 Tip : If you have trouble at this step, please check that you have the latest stable version of Golang installed.</p> <p>Verify that you have successfully installed Daodst on your system using the <code>version</code> command:</p> <pre><code>$ stcd version --long\n\nname: daodst\nserver_name: daodst\nversion: 3.0.0\ncommit: \nbuild_tags: \ngo: go version go1.20 darwin/amd64\n...\n</code></pre> <p>\ud83d\udce3 Tip: If there is a software version mismatch, check your <code>$PATH</code> to make sure the correct <code>stcd</code> is running.</p>"},{"location":"upgrade/manual/#2-replace-genesis-file","title":"2. Replace Genesis file","text":"<p>\ud83d\udce3 Tip : You can find the latest <code>genesis.json</code> file for mainnet or testnet in the following repositories:</p> <ul> <li>Mainnet: github.com/daodst/mainnet</li> <li>Testnet: github.com/daodst/testnets</li> </ul> <p>Save the new genesis as <code>new_genesis.json</code>. Then, replace the old <code>genesis.json</code> located in the <code>config/</code> directory with <code>new_genesis.json</code>:</p> <pre><code>cd $install_path/.stcd/config\ncp -f genesis.json new_genesis.json\nmv new_genesis.json genesis.json\n</code></pre> <p>\ud83d\udce3 Tips:</p> <p>We recommend using <code>sha256sum</code> to check the hash of the origin of the download against the expected origin.</p> <pre><code>cd ~/.stcd/config\necho \"&lt;expected_hash&gt; genesis.json\" | sha256sum -c\n</code></pre> <p>:::</p>"},{"location":"upgrade/manual/#3-data-reset","title":"3. Data reset","text":"<p>\u26a0\ufe0f Note : If the version you want to upgrade requires a data reset (hard fork), please check here. If this is not the case, you can skip to Reboot.</p> <p>Delete obsolete files and reset data:</p> <pre><code>rm $install_path/.stcd/config/addrbook.json\nstcd tendermint unsafe-reset-all --home $install_path/.stcd\n</code></pre> <p>Your node is now in pristine state, while keeping the original <code>priv_validator.json</code> and <code>config.toml</code>. If you previously set up any sentinel nodes or full nodes, your nodes will still attempt to connect to them, but may fail if they have not been upgraded.</p> <p>\ud83d\udea8 IMPORTANT \ud83d\udea8</p> <p>Make sure each node has a unique <code>priv_validator.json</code>. DO NOT copy <code>priv_validator.json</code> from old nodes to multiple new nodes. Running two nodes with the same <code>priv_validator.json</code> will result in you double signing.</p>"},{"location":"upgrade/manual/#4-restart-the-node","title":"4. Restart the node","text":"<p>To restart a node after a new genesis update, use the <code>daemon</code> command:</p> <pre><code>stcd daemon\n</code></pre>"},{"location":"upgrade/rollback/","title":"rollback","text":"<p>\ud83d\udce3 Tip: <code>$install_path</code> is used to indicate the path where you installed the <code>stcd</code> binary</p> <p>Learn how to rollback a chain version if a chain upgrade fails.</p> <p>In order to restore a previous chain version, a validator must restore the following data:</p> <ul> <li>A database containing the state of the previous chain (by default in <code>$install_path/.stcd/data</code>)</li> <li>Validator's <code>priv_validator_state.json</code> file (also in <code>$install_path/.stcd/data</code> by default)</li> </ul> <p>If a validator does not own their database data, another validator should share a copy of the database. Validators will be able to download a copy of the data and validate it before launching their nodes.</p> <p>If validators do not have a backup <code>priv_validator_state.json</code> file, then those validators will not have double-signature protection on their first block.</p>"},{"location":"upgrade/rollback/#restore-status-program","title":"restore status program","text":"<ol> <li> <p>First, stop your node.</p> </li> <li> <p>Then, copy the contents of the backup data directory back to the <code>$DAODST_HOME/data</code> directory (should be <code>$install_path/.stcd/data</code> by default)</p> </li> </ol> <pre><code># Assumes backup is stored in \"backup\" directory\nrm -rf $install_path/.stcd/data\nmv backup/.stcd/data $install_path/.stcd/data\n</code></pre> <ol> <li>Next, install the previous version of Daodst.</li> </ol> <pre><code># from Daodst directory\ngit checkout &lt;prev_version&gt;\nmake install\n## verify version\nstcd version --long\n</code></pre> <ol> <li>Finally, start the node.</li> </ol> <pre><code>stcd daemon\n</code></pre>"},{"location":"upgrade/template/","title":"Upgrade proposal content template","text":"<p>The upgrade includes three parts, the gateway client upgrade, the main chain node upgrade, and the APP upgrade. The gateway and the main chain are divided into two versions, linux and windows, and only support 64-bit systems. The upgrade file package needs to be sha256 encoded, and then spliced \u200b\u200bto the download link according to the given format for file validity verification. The upgrade_script script is suitable for upgrading data or programs that require additional processing besides the client.</p> <p>Execute the sha256 command:</p> <pre><code>sha256sum file\n#output:\n27a1ed5d502d4148f837f2a74c6d87b574ce52391fda253618e60486e0304c5b file\n</code></pre> <ul> <li>Gateway client upgrade proposal content:</li> </ul> <pre><code>{\n  \"gateway\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n\n}\n</code></pre> <ul> <li>Main chain node upgrade proposal content:</li> </ul> <pre><code>{\n  \"blockchain\": {\n        \"version\": \"22.10.08\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/daodst.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n}\n</code></pre> <ul> <li>APP upgrade proposal content:</li> </ul> <pre><code>{\n    \"app\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"android\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n}\n</code></pre> <p>Support for one proposal to upgrade multiple programs:</p> <pre><code>{\n  \"gateway\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    },\n  \"blockchain\": {\n        \"version\": \"22.10.08\",\n        \"binaries\": {\n            \"linux/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            },\n            \"windows/amd64\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    },\n    \"app\": {\n        \"version\": \"22.09.07\",\n        \"binaries\": {\n            \"android\": {\n                \"url\": \"https://example.com/gaia.zip?checksum=sha256:aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f\",\n                \"size\": 123877163\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"window/info/","title":"Instructions for use","text":""},{"location":"window/info/#1-enter-the-password-to-log-in-remember-to-save-this-password","title":"1. Enter the password to log in, remember to save this password","text":""},{"location":"window/info/#2-enter-the-private-key-to-add-the-wallet-address","title":"2. Enter the private key to add the wallet address","text":""},{"location":"window/info/#3-create-order-tasks","title":"3. Create order tasks","text":""},{"location":"window/info/#4-view-order-task-list","title":"4. View order task list","text":""},{"location":"window/info/#5-view-order-list","title":"5. View order list","text":""},{"location":"window/introduce/","title":"Introduce","text":""},{"location":"window/introduce/#function-description","title":"Function Description","text":"<p>Through this program, sellers can achieve functions such as creating pending order tasks, automatically placing orders based on pending order tasks, automatically withdrawing money, automatically canceling pending orders, etc. Cross-chain is a completely decentralized point-to-point cross-chain through HASH locking contracts.</p>"},{"location":"window/introduce/#hash-lock-contract-process-introduction","title":"HASH lock contract process introduction","text":"<p>Suppose there are two chains A and B. As a seller, Zhang San owns the USDT assets of chain A and wants to exchange them for USDT assets of chain B. As a buyer, Li Si owns the USDT assets of chain B and wants to exchange them for USDT assets of chain A.</p> <ol> <li> <p>Zhang San needs to call the creation sell order method of the HASH-locked cross-chain contract of chain A, and pass in the chain ID, selling quantity, locking time, and signature generated off-chain of chain B (the seller, according to the chain ID of chain A, The chain ID of chain B, the seller\u2019s customized password, and the quantity signature) generate an order. The order has a unique Key (obtained from sha256(signature)), and the corresponding amount of USDT assets is transferred to the contract.</p> </li> <li> <p>If Li Si wants to buy, he first calls the contract method of the purchase order of the cross-chain contract locked by the A chain HASH, and confirms that he wants to buy Zhang San's order. At this time, the order is in a locked state.</p> </li> <li> <p>Secondly, Li Si needs to bring the key of the order, the chain ID of chain A, the quantity sold, the order end time, signature, and the withdrawal lock time defined by the buyer (order end time &gt;= withdrawal lock time + current time) to call chain B How to create a sell order for a HASH-locked cross-chain contract and transfer the USDT assets of chain B into the contract</p> </li> <li> <p>After Zhang San sees that Li Si has successfully paid on chain B, he calls the method of extracting order assets of chain B and passes in the password customized by the seller when creating the order. The password will be disclosed to Li Si after the transaction is successful.</p> </li> <li> <p>After Li Si gets the password, he needs to call the method of extracting order assets of chain A, pass in the password, and obtain the USDT assets of chain A.</p> </li> </ol>"}]}